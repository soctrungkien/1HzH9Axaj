{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/fengari/src/fengari.js","webpack:///./node_modules/fengari/src/defs.js","webpack:///./node_modules/fengari/src/lua.js","webpack:///./node_modules/fengari/src/luaconf.js","webpack:///./node_modules/fengari/src/llimits.js","webpack:///./node_modules/fengari/src/fengaricore.js","webpack:///./node_modules/fengari/src/lobject.js","webpack:///./node_modules/fengari/src/lauxlib.js","webpack:///./node_modules/fengari/src/ldo.js","webpack:///./node_modules/fengari/src/ltable.js","webpack:///./node_modules/fengari/src/lstring.js","webpack:///./node_modules/fengari/src/ldebug.js","webpack:///./node_modules/fengari/src/lstate.js","webpack:///./node_modules/fengari/src/lfunc.js","webpack:///./node_modules/fengari/src/ltm.js","webpack:///./node_modules/fengari/src/lvm.js","webpack:///./node_modules/fengari/src/lopcodes.js","webpack:///./node_modules/fengari/src/lualib.js","webpack:///./node_modules/fengari/src/lapi.js","webpack:///./node_modules/fengari/src/lzio.js","webpack:///./node_modules/fengari/src/llex.js","webpack:///./node_modules/fengari-interop/src/js.js","webpack:///./node_modules/fengari/src/ljstype.js","webpack:///./node_modules/fengari/src/lparser.js","webpack:///./node_modules/fengari/src/lbaselib.js","webpack:///./node_modules/fengari/src/lcorolib.js","webpack:///./node_modules/fengari/src/ltablib.js","webpack:///./node_modules/fengari/src/loslib.js","webpack:///./node_modules/fengari/src/lstrlib.js","webpack:///./node_modules/fengari/src/lutf8lib.js","webpack:///./node_modules/fengari/src/lmathlib.js","webpack:///./node_modules/fengari/src/ldblib.js","webpack:///./node_modules/fengari/src/loadlib.js","webpack:///./node_modules/fengari/src/fengarilib.js","webpack:///./src/fengari-web.js","webpack:///./node_modules/fengari/src/lcode.js","webpack:///./node_modules/fengari/src/lundump.js","webpack:///./node_modules/fengari/src/ldump.js","webpack:///./node_modules/sprintf-js/src/sprintf.js","webpack:///./node_modules/fengari/src/linit.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","core","FENGARI_AUTHORS","FENGARI_COPYRIGHT","FENGARI_RELEASE","FENGARI_VERSION","FENGARI_VERSION_MAJOR","FENGARI_VERSION_MINOR","FENGARI_VERSION_NUM","FENGARI_VERSION_RELEASE","luastring_eq","luastring_indexOf","luastring_of","to_jsstring","to_luastring","to_uristring","luaconf","lua","lauxlib","lualib","luastring_from","Uint8Array","from","a","len","length","v","indexOf","array_indexOf","Error","of","arguments","is_luastring","unicode_error_message","uri_allowed","split","reduce","charCodeAt","to_luastring_cache","str","cache","TypeError","cached","outU8Array","Array","outIdx","u","b","to","replacement_char","Math","min","u0","String","fromCharCode","RangeError","u1","u2","s1","s2","u3","toString","from_userstring","LUA_SIGNATURE","LUA_VERSION_MAJOR","LUA_VERSION_MINOR","LUA_VERSION_NUM","LUA_VERSION_RELEASE","LUA_VERSION","LUA_RELEASE","LUA_COPYRIGHT","LUA_AUTHORS","constant_types","LUA_TNONE","LUA_TNIL","LUA_TBOOLEAN","LUA_TLIGHTUSERDATA","LUA_TNUMBER","LUA_TSTRING","LUA_TTABLE","LUA_TFUNCTION","LUA_TUSERDATA","LUA_TTHREAD","LUA_NUMTAGS","LUA_TSHRSTR","LUA_TLNGSTR","LUA_TNUMFLT","LUA_TNUMINT","LUA_TLCL","LUA_TLCF","LUA_TCCL","LUAI_MAXSTACK","LUA_REGISTRYINDEX","LUA_HOOKCALL","LUA_HOOKCOUNT","LUA_HOOKLINE","LUA_HOOKRET","LUA_HOOKTAILCALL","LUA_MASKCALL","LUA_MASKCOUNT","LUA_MASKLINE","LUA_MASKRET","LUA_MINSTACK","LUA_MULTRET","LUA_OPADD","LUA_OPBAND","LUA_OPBNOT","LUA_OPBOR","LUA_OPBXOR","LUA_OPDIV","LUA_OPEQ","LUA_OPIDIV","LUA_OPLE","LUA_OPLT","LUA_OPMOD","LUA_OPMUL","LUA_OPPOW","LUA_OPSHL","LUA_OPSHR","LUA_OPSUB","LUA_OPUNM","LUA_RIDX_GLOBALS","LUA_RIDX_LAST","LUA_RIDX_MAINTHREAD","lua_Debug","[object Object]","this","event","NaN","namewhat","what","source","currentline","linedefined","lastlinedefined","nups","nparams","isvararg","istailcall","short_src","i_ci","lua_upvalueindex","thread_status","LUA_OK","LUA_YIELD","LUA_ERRRUN","LUA_ERRSYNTAX","LUA_ERRMEM","LUA_ERRGCMM","LUA_ERRERR","defs","lapi","ldebug","ldo","lstate","lua_absindex","lua_arith","lua_atpanic","lua_atnativeerror","lua_call","lua_callk","lua_checkstack","lua_close","lua_compare","lua_concat","lua_copy","lua_createtable","lua_dump","lua_error","lua_gc","lua_getallocf","lua_getextraspace","lua_getfield","lua_getglobal","lua_gethook","lua_gethookcount","lua_gethookmask","lua_geti","lua_getinfo","lua_getlocal","lua_getmetatable","lua_getstack","lua_gettable","lua_gettop","lua_getupvalue","lua_getuservalue","lua_insert","lua_isboolean","lua_iscfunction","lua_isfunction","lua_isinteger","lua_islightuserdata","lua_isnil","lua_isnone","lua_isnoneornil","lua_isnumber","lua_isproxy","lua_isstring","lua_istable","lua_isthread","lua_isuserdata","lua_isyieldable","lua_len","lua_load","lua_newstate","lua_newtable","lua_newthread","lua_newuserdata","lua_next","lua_pcall","lua_pcallk","lua_pop","lua_pushboolean","lua_pushcclosure","lua_pushcfunction","lua_pushfstring","lua_pushglobaltable","lua_pushinteger","lua_pushjsclosure","lua_pushjsfunction","lua_pushlightuserdata","lua_pushliteral","lua_pushlstring","lua_pushnil","lua_pushnumber","lua_pushstring","lua_pushthread","lua_pushvalue","lua_pushvfstring","lua_rawequal","lua_rawget","lua_rawgeti","lua_rawgetp","lua_rawlen","lua_rawset","lua_rawseti","lua_rawsetp","lua_register","lua_remove","lua_replace","lua_resume","lua_rotate","lua_setallof","lua_setfield","lua_setglobal","lua_sethook","lua_seti","lua_setlocal","lua_setmetatable","lua_settable","lua_settop","lua_setupvalue","lua_setuservalue","lua_status","lua_stringtonumber","lua_toboolean","lua_todataview","lua_tointeger","lua_tointegerx","lua_tojsstring","lua_tolstring","lua_tonumber","lua_tonumberx","lua_topointer","lua_toproxy","lua_tostring","lua_tothread","lua_touserdata","lua_type","lua_typename","lua_upvalueid","lua_upvaluejoin","lua_version","lua_xmove","lua_yield","lua_yieldk","lua_tocfunction","conf","LUA_PATH_SEP","LUA_PATH_MARK","LUA_EXEC_DIR","LUA_VDIR","LUA_DIRSEP","LUA_LDIR","LUA_JSDIR","LUA_PATH_DEFAULT","LUA_JSPATH_DEFAULT","LUA_COMPAT_FLOATSTRING","LUA_IDSIZE","LUAL_BUFFERSIZE","ldexp","mantissa","exponent","steps","ceil","abs","result","pow","floor","LUA_INTEGER_FMT","LUA_INTEGER_FRMLEN","LUA_MAXINTEGER","LUA_MININTEGER","LUA_NUMBER_FMT","LUA_NUMBER_FRMLEN","frexp","data","DataView","ArrayBuffer","setFloat64","bits","getUint32","lua_getlocaledecpoint","lua_integer2str","lua_number2str","Number","toPrecision","lua_numbertointeger","luai_apicheck","e","lua_assert","api_check","msg","LUAI_MAXCCALLS","LUA_MINBUFFER","luai_nummod","L","MAX_INT","MIN_INT","lisdigit","lisprint","lisspace","lisxdigit","luaS_bless","luaS_new","ltable","lvm","ltm","LUA_TPROTO","LUA_TDEADKEY","TValue","type","ttnov","checktype","checktag","ttisnil","ttisboolean","x","tv","ttisstring","tsvalue","getstr","tsslen","svalue","setsvalue2s","newidx","ts","stack","setsvalue","luaO_nilobject","freeze","LClosure","id","l_G","id_counter","nupvalues","upvals","CClosure","f","upvalue","Udata","size","metatable","uservalue","RETS","PRE","POS","luaO_hexavalue","luaO_utf8esc","buff","UTF8BUFFSZ","mfb","l_str2dloc","neg","sigdig","nosigdig","hasdot","neg1","exp1","lua_strx2number","exec","flt","parseFloat","isNaN","lua_str2number","SIGILS","modes","46","120","88","110","78","MAXBY10","MAXLASTD","luaO_tostring","obj","ttisinteger","test","pushstr","luaD_inctop","top","luaO_pushvfstring","fmt","argp","subarray","luaO_pushfstring","setivalue","setfltvalue","lua_State","Table","JSON","stringify","ids","set","luaG_runerror","luaD_checkstack","luaV_concat","intarith","op","v1","v2","luaV_imul","luaV_mod","luaV_div","luaV_shiftl","numarith","LocVar","varname","startpc","endpc","luaO_arith","p1","p2","p3","res","i1","i2","tointeger","n1","n2","tonumber","luaT_trybinTM","TMS","TM_ADD","luaO_chunkid","bufflen","out","nli","out_i","luaO_int2fb","luaO_str2num","s2i","empty","l_str2int","pmode","l_str2d","pushobj2s","pushsvalue2s","setobjs2s","oldidx","setfrom","setobj2s","oldtv","LUA_ERRFILE","LUA_LOADED_TABLE","LUA_PRELOAD_TABLE","LUA_FILEHANDLE","__name","__tostring","luaL_Buffer","findfield","objidx","level","pushglobalfuncname","ar","pushfuncname","panic","luaL_argerror","arg","extramsg","luaL_error","typeerror","tname","typearg","luaL_getmetafield","luaL_typename","luaL_where","luaL_fileresult","stat","fname","message","errno","luaL_getmetatable","luaL_testudata","ud","tag_error","tag","luaL_checklstring","undefined","luaL_checkstring","luaL_optlstring","def","luaL_optstring","luaL_checknumber","luaL_checkinteger","interror","luaL_prepbuffsize","B","sz","newend","newsize","max","newbuff","luaL_buffinit","luaL_addlstring","luaL_addsize","luaL_addstring","luaL_pushresult","luaL_opt","getS","string","luaL_loadbufferx","luaL_loadbuffer","luaL_loadstring","tt","luaL_callmeta","p_I","p_f","find_subarray","arr","subarr","from_index","sl","loop","j","luaL_getsubtable","idx","luaL_setfuncs","nup","luaL_checkstack","lib","space","errfile","fnameindex","error","serr","filename","getc","utf8_bom","skipcomment","lf","skipBOM","skipped","luaL_loadfilex","LoadF","pos","err","getF","bytes","path","xhr","XMLHttpRequest","open","window","responseType","send","status","statusText","response","com","readstatus","luaL_loadfile","luaL_checkversion_","ver","LUA_NOREF","LUA_REFNIL","luaL_addchar","luaL_addvalue","luaL_argcheck","cond","luaL_buffinitsize","luaL_checkany","luaL_checkoption","lst","luaL_checktype","luaL_checkudata","luaL_checkversion","luaL_dofile","luaL_dostring","luaL_execresult","signal","luaL_gsub","wild","luaL_len","luaL_newlib","luaL_newlibtable","luaL_newmetatable","luaL_newstate","luaL_optinteger","luaL_optnumber","luaL_prepbuffer","luaL_pushresultsize","luaL_ref","ref","luaL_requiref","modname","openf","glb","luaL_setmetatable","luaL_tolstring","kind","luaL_traceback","L1","last","li","le","lastlevel","LEVELS1","luaL_unref","lua_writestringerror","console","lfunc","lobject","lopcodes","lparser","luaS_newliteral","lundump","MBuffer","adjust_top","newtop","seterrorobj","errcode","oldtop","current_top","ERRORSTACKSIZE","luaD_reallocstack","stack_last","EXTRA_STACK","luaD_growstack","luaD_throw","needed","luaD_shrinkstack","inuse","lim","ci","previous","stackinuse","goodsize","luaE_freeCI","luaD_precall","off","nresults","func","luaE_extendCI","funcOff","callstatus","hookmask","luaD_hook","api_checknelems","luaD_poscall","base","fsize","maxstacksize","is_vararg","adjust_varargs","numparams","l_base","l_code","code","l_savedpc","CIST_LUA","callhook","tryfuncTM","firstResult","nres","wanted","oldpc","next","moveresults","setnilvalue","line","hook","allowhook","ci_top","CIST_HOOKED","opcode","OpCodesI","OP_TAILCALL","CIST_TAIL","actual","nfixargs","fixed","tm","luaT_gettmbyobj","TM_CALL","ttisfunction","luaG_typeerror","luaD_call","nResults","nCcalls","stackerror","luaV_execute","errorJmp","g","mainthread","luaD_rawrunprotected","oldnCcalls","lj","atnativeerror","luaD_callnoyield","errfunc","e2","finishCcall","c_k","nny","CIST_YPCALL","c_old_errfunc","c_ctx","unroll","base_ci","luaV_finishOp","recover","findpcall","extra","luaF_close","CIST_OAH","resume_error","narg","resume","firstArg","ctx","k","luaD_pcall","old_top","ef","old_ci","old_allowhooks","old_nny","old_errfunc","checkmode","f_parser","cl","z","zgetc","luaU_undump","luaY_parser","dyd","upvalues","luaF_initupvals","luaD_protectedparser","Dyndata","nargs","oldnny","luaS_hashlongstr","TString","lightuserdata_hashes","WeakMap","get_lightuserdata_hash","hash","table_hash","strong","Map","dead_strong","dead_weak","flags","add","clear","prev","entry","mark_dead","setdeadvalue","delete","is_valid_weakmap_key","getgeneric","luaH_getint","invalidateTMcache","luaH_get","ttisfloat","luaH_getn","luaH_getstr","luaH_setfrom","kv","luaH_setint","luaH_new","luaH_next","table","keyI","keyO","ttisdeadkey","realstring","luaS_hash","luaS_eqlngstr","llex","currentpc","lineinfo","swapextra","temp","upvalname","uv","findlocal","findvararg","luaF_getlocalname","funcinfo","getfuncname","funcname","CIST_FIN","funcnamefromcode","kname","pc","ISK","kvalue","INDEXK","getobjname","filterpc","jmptarget","lastpc","reg","setreg","OCi","A","OP_LOADNIL","OP_TFORCALL","OP_CALL","OP_JMP","dest","sBx","testAMode","findsetreg","OP_MOVE","OP_GETTABUP","OP_GETTABLE","C","vn","LUA_ENV","OP_GETUPVAL","OP_LOADK","OP_LOADKX","Bx","Ax","OP_SELF","TM_INDEX","OP_SETTABUP","OP_SETTABLE","TM_NEWINDEX","OP_ADD","OP_SUB","TM_SUB","OP_MUL","TM_MUL","OP_MOD","TM_MOD","OP_POW","TM_POW","OP_DIV","TM_DIV","OP_IDIV","TM_IDIV","OP_BAND","TM_BAND","OP_BOR","TM_BOR","OP_BXOR","TM_BXOR","OP_SHL","TM_SHL","OP_SHR","TM_SHR","OP_UNM","TM_UNM","OP_BNOT","TM_BNOT","OP_LEN","TM_LEN","OP_CONCAT","TM_CONCAT","OP_EQ","TM_EQ","OP_LT","TM_LT","OP_LE","TM_LE","tmname","varinfo","getupvalname","stkid","isinstack","luaT_objtypename","luaG_addinfo","src","luaG_errormsg","luaG_concaterror","cvt2str","luaG_opinterror","luaG_ordererror","t1","t2","luaG_tointerror","luaG_traceexec","mask","counthook","hookcount","basehookcount","CIST_HOOKYIELD","npc","newline","auxgetinfo","ttisclosure","api_incr_top","collectvalidlines","ttisLclosure","local","count","BASIC_STACK_SIZE","CallInfo","stack_init","freestack","f_luaopen","registry","l_registry","sethvalue","init_registry","luaT_init","version","CIST_FRESH","CIST_LEQ","close_state","TM_N","mt","luaE_freethread","MAXUPVAL","Proto","locvars","luaF_findupval","old","local_number","luaF_newLclosure","luaT_typenames_","map","ttypename","TM_GC","TM_MODE","luaT_callTM","hasres","luaT_callbinTM","luaT_gettm","events","ename","fasttm","et","luaT_callorderTM","l_isfalse","ttistable","ttisfulluserdata","LFIELDS_PER_FLUSH","OP_CLOSURE","OP_EXTRAARG","OP_FORLOOP","OP_FORPREP","OP_LOADBOOL","OP_NEWTABLE","OP_NOT","OP_RETURN","OP_SETLIST","OP_SETUPVAL","OP_TEST","OP_TESTSET","OP_TFORLOOP","OP_VARARG","RA","RB","RKB","RKC","dojump","donextjump","luaV_lessthan","ttisnumber","LTnum","l_strcmp","luaV_lessequal","LEnum","luaV_equalobj","ttype","forlimit","step","stopnow","ilimit","luaV_tointeger","cvt2num","vslen","ls","rs","luaV_objlen","ra","rb","h","imul","aLo","bLo","y","getcached","encup","instack","pushclosure","ncl","setclLvalue","tostring","isemptystr","copy2buff","tl","total","luaV_gettable","slot","settable","val","newframe","konst","setbvalue","upval","rc","numberop1","numberop2","op1","op2","numberop","rbIdx","nci","oci","nfunc","nfuncOff","ofuncOff","aux","limit","chgivalue","chgfltvalue","forlim","init","plimit","pstep","initv","nlimit","nstep","ninit","cb","inst","luaV_rawequalobj","luaP_opmodes","MASK1","MASK0","setarg","fullins","SETARG_Bx","ins","BITRK","CREATE_ABC","CREATE_ABx","bc","CREATE_Ax","GET_OPCODE","GETARG_A","GETARG_B","GETARG_C","GETARG_Bx","GETARG_Ax","GETARG_sBx","MAXARG_A","MAXARG_Ax","MAXARG_B","MAXARG_Bx","MAXARG_C","MAXARG_sBx","MAXINDEXRK","NO_REG","OpArgK","OpArgN","OpArgR","OpArgU","OpCodes","POS_A","POS_Ax","POS_B","POS_Bx","POS_C","POS_OP","RKASK","SETARG_A","SETARG_Ax","SETARG_B","SETARG_C","SETARG_sBx","SET_OPCODE","SIZE_A","SIZE_Ax","SIZE_B","SIZE_Bx","SIZE_C","SIZE_OP","getBMode","getCMode","getOpMode","iABC","iABx","iAsBx","iAx","testTMode","LUA_VERSUFFIX","luaopen_base","LUA_COLIBNAME","luaopen_coroutine","LUA_TABLIBNAME","luaopen_table","LUA_OSLIBNAME","luaopen_os","LUA_STRLIBNAME","luaopen_string","LUA_UTF8LIBNAME","luaopen_utf8","LUA_BITLIBNAME","LUA_MATHLIBNAME","luaopen_math","LUA_DBLIBNAME","luaopen_debug","LUA_LOADLIBNAME","luaopen_package","LUA_FENGARILIBNAME","luaopen_fengari","linit","luaL_openlibs","luaU_dump","ZIO","fengari_argcheck","fengari_argcheckinteger","isvalid","index2addr","ttislcf","index2addr_","reverse","fromtv","pIdx","fromidx","toidx","fn","setclCvalue","auxsetstr","auxgetstr","narray","nrec","aux_upvalue","fi","seen","f_call","default_chunkname","checkresults","na","nr","getupvalref","fidx","panicf","errorf","index1","index2","o1","o2","writer","strip","warn","objindex","funcindex","up","ttisCclosure","G","ttislightuserdata","reader","chunkname","gt","luaS_newudata","lua_setallocf","u8","buffer","byteOffset","byteLength","jsstring","proxy","create_proxy","ttisthread","fidx1","fidx2","ref1","ref2","up2","luaZ_fill","EOZ","luaZ_buffer","luaZ_buffremove","luaZ_read","b_offset","luaZ_resetbuffer","luaZ_resizebuffer","lislalnum","lislalpha","RESERVED","TK_AND","TK_BREAK","FIRST_RESERVED","TK_DO","TK_ELSE","TK_ELSEIF","TK_END","TK_FALSE","TK_FOR","TK_FUNCTION","TK_GOTO","TK_IF","TK_IN","TK_LOCAL","TK_NIL","TK_NOT","TK_OR","TK_REPEAT","TK_RETURN","TK_THEN","TK_TRUE","TK_UNTIL","TK_WHILE","TK_IDIV","TK_CONCAT","TK_DOTS","TK_EQ","TK_GE","TK_LE","TK_NE","TK_SHL","TK_SHR","TK_DBCOLON","TK_EOS","TK_FLT","TK_INT","TK_NAME","TK_STRING","luaX_tokens","SemInfo","Token","token","seminfo","save","lexerror","luaX_token2str","currIsNewline","current","save_and_next","TVtrue","luaX_newstring","tpair","inclinenumber","linenumber","check_next1","check_next2","read_numeral","expo","first","txtToken","skip_sep","read_long_string","sep","skip","esccheck","gethexa","readhexaesc","utf8esc","readutf8desc","readdecesc","read_string","del","will","token_to_index","forEach","kidx","LexState","lastline","lookahead","fs","envn","isreserved","w","luaX_lookahead","luaX_next","luaX_setinput","firstchar","luaX_syntaxerror","global_env","WorkerGlobalScope","self","eval","apply","construct","Reflect_deleteProperty","Reflect","deleteProperty","fApply","Function","target","thisArgument","argumentsList","args","push","concat","isobject","js_tname","testjs","checkjs","pushjs","getmainthread","mainL","states","objects_seen","tojs","wrap","jscall","invoke","thisarg","n_results","gettable","prop","has","iter_next","iter","state","done","js_proxy","iterator","jsiterator","toPrimitive","hint","jslib","new","instanceof","typeof","get_iterator","getiter","Proxy","L_symbol","p_symbol","proxy_handlers","arg_length","desc","getOwnPropertyDescriptor","getPrototypeOf","ownKeys","setPrototypeOf","raw_function","make_arrow_function","raw_arrow_function","createproxy","valid_types","valid_types_as_luastring","fengariProxy","jsmt","__index","__newindex","__call","__pairs","for","index","keys","isArray","__len","FENGARI_INTEROP_VERSION","FENGARI_INTEROP_VERSION_MAJOR","FENGARI_INTEROP_VERSION_NUM","FENGARI_INTEROP_RELEASE","luaopen_js","luai_ctype_","BinOpr","OPR_ADD","OPR_AND","OPR_BAND","OPR_BOR","OPR_BXOR","OPR_CONCAT","OPR_DIV","OPR_EQ","OPR_GE","OPR_GT","OPR_IDIV","OPR_LE","OPR_LT","OPR_MOD","OPR_MUL","OPR_NE","OPR_NOBINOPR","OPR_OR","OPR_POW","OPR_SHL","OPR_SHR","OPR_SUB","UnOpr","OPR_BNOT","OPR_LEN","OPR_MINUS","OPR_NOT","OPR_NOUNOPR","NO_JUMP","getinstruction","luaK_checkstack","luaK_codeABC","luaK_codeABx","luaK_codeAsBx","luaK_codek","luaK_concat","luaK_dischargevars","luaK_exp2RK","luaK_exp2anyreg","luaK_exp2anyregup","luaK_exp2nextreg","luaK_exp2val","luaK_fixline","luaK_getlabel","luaK_goiffalse","luaK_goiftrue","luaK_indexed","luaK_infix","luaK_intK","luaK_jump","luaK_jumpto","luaK_nil","luaK_patchclose","luaK_patchlist","luaK_patchtohere","luaK_posfix","luaK_prefix","luaK_reserveregs","luaK_ret","luaK_self","luaK_setlist","luaK_setmultret","luaK_setoneret","luaK_setreturns","luaK_storevar","luaK_stringK","R","hasmultret","expkind","VCALL","VVARARG","eqstr","BlockCnt","firstlabel","firstgoto","nactvar","isloop","VVOID","VNIL","VTRUE","VFALSE","VK","VKFLT","VKINT","VNONRELOC","VLOCAL","VUPVAL","VINDEXED","VJMP","VRELOCABLE","expdesc","ival","nval","info","ind","vt","FuncState","bl","lasttarget","jpc","nk","np","firstlocal","nlocvars","freereg","Labellist","semerror","error_expected","checklimit","where","errorlimit","testnext","check","checknext","check_condition","check_match","who","str_checkname","init_exp","codestring","checkname","new_localvar","registerlocalvar","actvar","new_localvarliteral","getlocvar","adjustlocalvars","nvars","newupvalue","singlevaraux","vr","searchvar","markupval","searchupvalue","singlevar","adjust_assign","nexps","enterlevel","leavelevel","closegoto","label","gl","vname","findlabel","lb","newlabelentry","findgotos","enterblock","open_func","leaveblock","breaklabel","tolevel","removevars","movegotosout","undefgoto","close_func","block_follow","withuntil","statlist","statement","fieldsel","yindex","expr","recfield","cc","nh","rkkey","closelistfield","tostore","listfield","field","constructor","lastlistfield","body","ismethod","new_fs","clp","addprototype","parlist","codeclosure","explist","funcargs","suffixedexp","primaryexp","priority","left","right","subexpr","uop","getunopr","simpleexp","getbinopr","nextop","block","LHS_assign","assignment","lh","vkisvar","nv","conflict","check_conflict","gotostat","labelstat","ll","checkrepeated","skipnoopstat","forbody","isnum","endfor","prep","forstat","fornum","indexname","forlist","test_then_block","escapelist","jf","funcstat","ifstat","whileinit","condexit","whilestat","repeat_init","bl1","bl2","repeatstat","localfunc","localstat","nret","retstat","exprstat","lexstate","funcstate","mainfunc","vkisinreg","lua_writestring","lua_writeline","TextDecoder","decoder","decode","stream","log","copy","opts","luaB_next","ipairsaux","luaB_error","finishpcall","load_aux","envidx","generic_reader","dofilecont","d1","d2","base_funcs","assert","collectgarbage","dofile","getmetatable","ipairs","load","env","loadfile","pairs","method","iszero","pairsmeta","pcall","print","rawequal","rawget","rawlen","rawset","select","setmetatable","parseInt","b_str2int","xpcall","getco","co","auxresume","luaB_auxwrap","luaB_cocreate","NL","co_funcs","isyieldable","running","yield","checkfield","checktab","aux_getn","addfield","set2","sort_comp","partition","lo","choosePivot","rnd","r4","auxsort","random","tab_funcs","lsep","insert","move","pack","remove","sort","unpack","MAX_SAFE_INTEGER","LUA_STRFTIMEOPTIONS","setfield","setallfields","time","utc","getUTCSeconds","getSeconds","getUTCMinutes","getMinutes","getUTCHours","getHours","getUTCDate","getDate","getUTCMonth","getMonth","getUTCFullYear","getFullYear","getUTCDay","getDay","Date","L_MAXDATEFIELD","getfield","delta","locale","days","shortDays","months","shortMonths","AM","PM","am","pm","formats","D","F","T","X","week_number","date","start_of_week","weekday","yday","push_pad_2","pad","strftime","checkoption","tzString","match","day","getTimezoneOffset","conv","option","oplen","l_checktime","syslib","stm","difftime","clock","performance","now","sprintf","L_ESC","strlen","posrelat","SIZELENMOD","lua_number2strx","is","Infinity","zero","fe","num2straux","FLAGS","isalpha","isdigit","iscntrl","isgraph","islower","isupper","isalnum","ispunct","isspace","isxdigit","addliteral","repeat","addquoted","point","ppoint","checkdp","scanformat","strfrmt","form","addlenmod","lenmod","lm","spec","Header","islittle","maxalign","digit","getnum","df","getnumlimit","getoption","opt","getdetails","totalsize","ntoalign","align","packint","unpackint","issigned","unpacknum","dv","setUint8","getFloat32","getFloat64","SPECIALS","MatchState","src_init","src_end","p_end","matchdepth","capture","classend","ms","match_class","matchbracketclass","ec","sig","singlematch","ep","matchbalance","cont","max_expand","min_expand","start_capture","end_capture","capture_to_close","match_capture","check_capture","ai","bi","array_cmp","gotodefault","gotoinit","push_onecapture","push_captures","nlevels","prepstate","lp","reprepstate","str_find_aux","find","nospecials","anchor","gmatch_aux","gm","lastmatch","add_value","tr","news","add_s","strlib","byte","posi","pose","char","dump","format","gmatch","gsub","srcl","max_s","lower","details","setFloat32","packsize","rep","totallen","pi","sub","start","end","ld","upper","createmetatable","iscont","u_posrelat","limits","utf8_decode","p_U","pushutfchar","iter_aux","dec","funcs","codepoint","codes","posj","offset","UTF8PATT","rand_state","l_rand","pushnumint","mathlib","acos","asin","atan","atan2","cos","deg","PI","exp","fmod","log2","log10","imax","imin","modf","ip","rad","low","randomseed","l_srand","sin","sqrt","tan","ult","checkstack","getthread","thread","settabss","settabsi","settabsb","treatstackoption","auxupvalue","checkupval","argf","argnup","HOOKKEY","hooknames","hookf","dblib","gethook","smask","unmakemask","getinfo","options","getlocal","nvar","getregistry","getupvalue","getuservalue","sethook","hooktable","makemask","setlocal","setupvalue","setuservalue","traceback","upvalueid","upvaluejoin","getinput","input","prompt","debug","fengari","JSLIBS","LUA_CSUBSEP","LUA_LSUBSEP","LUA_POF","LUA_OFSEP","AUXMARK","lsys_load","seeglb","readable","lookforfunc","sym","checkjslib","addtojslib","lsys_sym","setpath","fieldname","envname","dft","nver","noenv","plib","pushnexttemplate","searchpath","dirsep","findfile","pname","checkload","searcher_Lua","loadfunc","openfunc","mark","searcher_C","searcher_Croot","searcher_preload","findloader_cont","ll_require_cont","ll_require_cont2","pk_funcs","loadlib","ll_funcs","require","findloader","createjslibstable","searchers","createsearcherstable","__webpack_exports__","fengari__WEBPACK_IMPORTED_MODULE_0__","fengari_interop__WEBPACK_IMPORTED_MODULE_1__","ok","SyntaxError","document","HTMLDocument","crossorigin_to_credentials","crossorigin","msghandler","ErrorEvent","bubbles","cancelable","lineno","run_lua_script","location","syntaxerror","configurable","currentScript","dispatchEvent","process_xhr_response","Event","run_lua_script_tag","readyState","async","fetch","credentials","redirect","integrity","then","resp","arrayBuffer","catch","reason","onreadystatechange","innerHTML","contentTypeRegexp","luaVersionRegex","try_tag","tagName","contentTypeMatch","mimetype","hasAttribute","getAttribute","MutationObserver","records","observer","record","addedNodes","observe","childList","subtree","selector","querySelectorAll","hasjumps","tonumeral","make_tvalue","ek","pfrom","pl","getjump","fixjump","jmp","l1","l2","list","condjump","getjumpcontroloffset","getjumpcontrol","patchtestreg","node","removevalues","patchlistaux","vtarget","dtarget","luaK_code","dischargejpc","codeextraarg","newstack","freeexp","freeexps","e1","r1","r2","addk","luaK_numberK","boolK","code_loadbool","jump","discharge2reg","discharge2anyreg","need_value","exp2reg","final","p_t","fj","vk","nilK","negatecondition","jumponcond","ie","constfolding","validop","codebinexpval","rk2","rk1","opr","codecomp","codeunexpval","codenot","ereg","nelems","ex","LUAC_DATA","BytecodeParser","Z","intSize","size_tSize","instructionSize","integerSize","numberSize","arraybuffer","getInt32","LoadInteger","LoadByte","LoadSize_t","read","LoadInt","LoadNumber","LoadString","LoadFunction","psource","LoadCode","LoadConstants","LoadUpvalues","LoadProtos","LoadDebug","checkliteral","checksize","why","S","checkHeader","LUAC_VERSION","DumpBlock","DumpByte","DumpInt","ab","setInt32","DumpInteger","DumpNumber","DumpString","DumpFunction","DumpCode","DumpConstants","DumpUpvalues","DumpProtos","DumpDebug","write","DumpHeader","__WEBPACK_AMD_DEFINE_RESULT__","re","not_string","not_bool","not_type","not_primitive","number","numeric_arg","json","not_json","text","modulo","placeholder","key_access","index_access","sign","parse_tree","argv","pad_character","pad_length","is_positive","cursor","tree_length","output","toExponential","toFixed","substring","slice","toLowerCase","valueOf","toUpperCase","replace","charAt","sprintf_format","sprintf_cache","_fmt","arg_names","field_list","replacement_field","field_match","sprintf_parse","vsprintf","loadedlibs"],"mappings":"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","file":"fengari-web.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 34);\n","/**\n@license MIT\n\nCopyright © 2017-2018 Benoit Giannangeli\nCopyright © 2017-2018 Daurnimator\nCopyright © 1994–2017 Lua.org, PUC-Rio.\n*/\n\n\"use strict\";\n\nconst core = require(\"./fengaricore.js\");\n\nmodule.exports.FENGARI_AUTHORS         = core.FENGARI_AUTHORS;\nmodule.exports.FENGARI_COPYRIGHT       = core.FENGARI_COPYRIGHT;\nmodule.exports.FENGARI_RELEASE         = core.FENGARI_RELEASE;\nmodule.exports.FENGARI_VERSION         = core.FENGARI_VERSION;\nmodule.exports.FENGARI_VERSION_MAJOR   = core.FENGARI_VERSION_MAJOR;\nmodule.exports.FENGARI_VERSION_MINOR   = core.FENGARI_VERSION_MINOR;\nmodule.exports.FENGARI_VERSION_NUM     = core.FENGARI_VERSION_NUM;\nmodule.exports.FENGARI_VERSION_RELEASE = core.FENGARI_VERSION_RELEASE;\n\nmodule.exports.luastring_eq      = core.luastring_eq;\nmodule.exports.luastring_indexOf = core.luastring_indexOf;\nmodule.exports.luastring_of      = core.luastring_of;\nmodule.exports.to_jsstring       = core.to_jsstring;\nmodule.exports.to_luastring      = core.to_luastring;\nmodule.exports.to_uristring      = core.to_uristring;\n\nconst luaconf = require('./luaconf.js');\nconst lua     = require('./lua.js');\nconst lauxlib = require('./lauxlib.js');\nconst lualib  = require('./lualib.js');\n\nmodule.exports.luaconf = luaconf;\nmodule.exports.lua     = lua;\nmodule.exports.lauxlib = lauxlib;\nmodule.exports.lualib  = lualib;\n","\"use strict\";\n\n/*\n * Fengari specific string conversion functions\n */\n\nlet luastring_from;\nif (typeof Uint8Array.from === \"function\") {\n    luastring_from = Uint8Array.from.bind(Uint8Array);\n} else {\n    luastring_from = function(a) {\n        let i = 0;\n        let len = a.length;\n        let r = new Uint8Array(len);\n        while (len > i) r[i] = a[i++];\n        return r;\n    };\n}\n\nlet luastring_indexOf;\nif (typeof (new Uint8Array().indexOf) === \"function\") {\n    luastring_indexOf = function(s, v, i) {\n        return s.indexOf(v, i);\n    };\n} else {\n    /* Browsers that don't support Uint8Array.indexOf seem to allow using Array.indexOf on Uint8Array objects e.g. IE11 */\n    let array_indexOf = [].indexOf;\n    if (array_indexOf.call(new Uint8Array(1), 0) !== 0) throw Error(\"missing .indexOf\");\n    luastring_indexOf = function(s, v, i) {\n        return array_indexOf.call(s, v, i);\n    };\n}\n\nlet luastring_of;\nif (typeof Uint8Array.of === \"function\") {\n    luastring_of = Uint8Array.of.bind(Uint8Array);\n} else {\n    luastring_of = function() {\n        return luastring_from(arguments);\n    };\n}\n\nconst is_luastring = function(s) {\n    return s instanceof Uint8Array;\n};\n\n/* test two lua strings for equality */\nconst luastring_eq = function(a, b) {\n    if (a !== b) {\n        let len = a.length;\n        if (len !== b.length) return false;\n        /* XXX: Should this be a constant time algorithm? */\n        for (let i=0; i<len; i++)\n            if (a[i] !== b[i]) return false;\n    }\n    return true;\n};\n\nconst unicode_error_message = \"cannot convert invalid utf8 to javascript string\";\nconst to_jsstring = function(value, from, to, replacement_char) {\n    if (!is_luastring(value)) throw new TypeError(\"to_jsstring expects a Uint8Array\");\n\n    if (to === void 0) {\n        to = value.length;\n    } else {\n        to = Math.min(value.length, to);\n    }\n\n    let str = \"\";\n    for (let i = (from!==void 0?from:0); i < to;) {\n        let u0 = value[i++];\n        if (u0 < 0x80) {\n            /* single byte sequence */\n            str += String.fromCharCode(u0);\n        } else if (u0 < 0xC2 || u0 > 0xF4) {\n            if (!replacement_char) throw RangeError(unicode_error_message);\n            str += \"�\";\n        } else if (u0 <= 0xDF) {\n            /* two byte sequence */\n            if (i >= to) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            let u1 = value[i++];\n            if ((u1&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            str += String.fromCharCode(((u0 & 0x1F) << 6) + (u1 & 0x3F));\n        } else if (u0 <= 0xEF) {\n            /* three byte sequence */\n            if (i+1 >= to) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            let u1 = value[i++];\n            if ((u1&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            let u2 = value[i++];\n            if ((u2&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            let u = ((u0 & 0x0F) << 12) + ((u1 & 0x3F) << 6) + (u2 & 0x3F);\n            if (u <= 0xFFFF) { /* BMP codepoint */\n                str += String.fromCharCode(u);\n            } else { /* Astral codepoint */\n                u -= 0x10000;\n                let s1 = (u >> 10) + 0xD800;\n                let s2 = (u % 0x400) + 0xDC00;\n                str += String.fromCharCode(s1, s2);\n            }\n        } else {\n            /* four byte sequence */\n            if (i+2 >= to) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            let u1 = value[i++];\n            if ((u1&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            let u2 = value[i++];\n            if ((u2&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            let u3 = value[i++];\n            if ((u3&0xC0) !== 0x80) {\n                if (!replacement_char) throw RangeError(unicode_error_message);\n                str += \"�\";\n                continue;\n            }\n            /* Has to be astral codepoint */\n            let u = ((u0 & 0x07) << 18) + ((u1 & 0x3F) << 12) + ((u2 & 0x3F) << 6) + (u3 & 0x3F);\n            u -= 0x10000;\n            let s1 = (u >> 10) + 0xD800;\n            let s2 = (u % 0x400) + 0xDC00;\n            str += String.fromCharCode(s1, s2);\n        }\n    }\n    return str;\n};\n\n/* bytes allowed unescaped in a uri */\nconst uri_allowed = (\";,/?:@&=+$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,-_.!~*'()#\").split('').reduce(function(uri_allowed, c) {\n    uri_allowed[c.charCodeAt(0)] = true;\n    return uri_allowed;\n}, {});\n\n/* utility function to convert a lua string to a js string with uri escaping */\nconst to_uristring = function(a) {\n    if (!is_luastring(a)) throw new TypeError(\"to_uristring expects a Uint8Array\");\n    let s = \"\";\n    for (let i=0; i<a.length; i++) {\n        let v = a[i];\n        if (uri_allowed[v]) {\n            s += String.fromCharCode(v);\n        } else {\n            s += \"%\" + (v<0x10?\"0\":\"\") + v.toString(16);\n        }\n    }\n    return s;\n};\n\nconst to_luastring_cache = {};\n\nconst to_luastring = function(str, cache) {\n    if (typeof str !== \"string\") throw new TypeError(\"to_luastring expects a javascript string\");\n\n    if (cache) {\n        let cached = to_luastring_cache[str];\n        if (is_luastring(cached)) return cached;\n    }\n\n    let len = str.length;\n    let outU8Array = Array(len); /* array is at *least* going to be length of string */\n    let outIdx = 0;\n    for (let i = 0; i < len; ++i) {\n        let u = str.charCodeAt(i);\n        if (u <= 0x7F) {\n            outU8Array[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n            outU8Array[outIdx++] = 0xC0 | (u >> 6);\n            outU8Array[outIdx++] = 0x80 | (u & 63);\n        } else {\n            /* This part is to work around possible lack of String.codePointAt */\n            if (u >= 0xD800 && u <= 0xDBFF && (i+1) < len) {\n                /* is first half of surrogate pair */\n                let v = str.charCodeAt(i+1);\n                if (v >= 0xDC00 && v <= 0xDFFF) {\n                    /* is valid low surrogate */\n                    i++;\n                    u = (u - 0xD800) * 0x400 + v + 0x2400;\n                }\n            }\n            if (u <= 0xFFFF) {\n                outU8Array[outIdx++] = 0xE0 | (u >> 12);\n                outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n                outU8Array[outIdx++] = 0x80 | (u & 63);\n            } else {\n                outU8Array[outIdx++] = 0xF0 | (u >> 18);\n                outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n                outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n                outU8Array[outIdx++] = 0x80 | (u & 63);\n            }\n        }\n    }\n    outU8Array = luastring_from(outU8Array);\n\n    if (cache) to_luastring_cache[str] = outU8Array;\n\n    return outU8Array;\n};\n\nconst from_userstring = function(str) {\n    if (!is_luastring(str)) {\n        if (typeof str === \"string\") {\n            str = to_luastring(str);\n        } else {\n            throw new TypeError(\"expects an array of bytes or javascript string\");\n        }\n    }\n    return str;\n};\n\nmodule.exports.luastring_from    = luastring_from;\nmodule.exports.luastring_indexOf = luastring_indexOf;\nmodule.exports.luastring_of      = luastring_of;\nmodule.exports.is_luastring      = is_luastring;\nmodule.exports.luastring_eq      = luastring_eq;\nmodule.exports.to_jsstring       = to_jsstring;\nmodule.exports.to_uristring      = to_uristring;\nmodule.exports.to_luastring      = to_luastring;\nmodule.exports.from_userstring   = from_userstring;\n\n\n/* mark for precompiled code ('<esc>Lua') */\nconst LUA_SIGNATURE = to_luastring(\"\\x1bLua\");\n\nconst LUA_VERSION_MAJOR   = \"5\";\nconst LUA_VERSION_MINOR   = \"3\";\nconst LUA_VERSION_NUM     = 503;\nconst LUA_VERSION_RELEASE = \"4\";\n\nconst LUA_VERSION         = \"Lua \" + LUA_VERSION_MAJOR + \".\" + LUA_VERSION_MINOR;\nconst LUA_RELEASE         = LUA_VERSION + \".\" + LUA_VERSION_RELEASE;\nconst LUA_COPYRIGHT       = LUA_RELEASE + \"  Copyright (C) 1994-2017 Lua.org, PUC-Rio\";\nconst LUA_AUTHORS         = \"R. Ierusalimschy, L. H. de Figueiredo, W. Celes\";\n\nmodule.exports.LUA_SIGNATURE       = LUA_SIGNATURE;\nmodule.exports.LUA_VERSION_MAJOR   = LUA_VERSION_MAJOR;\nmodule.exports.LUA_VERSION_MINOR   = LUA_VERSION_MINOR;\nmodule.exports.LUA_VERSION_NUM     = LUA_VERSION_NUM;\nmodule.exports.LUA_VERSION_RELEASE = LUA_VERSION_RELEASE;\nmodule.exports.LUA_VERSION         = LUA_VERSION;\nmodule.exports.LUA_RELEASE         = LUA_RELEASE;\nmodule.exports.LUA_COPYRIGHT       = LUA_COPYRIGHT;\nmodule.exports.LUA_AUTHORS         = LUA_AUTHORS;\n\n\nconst thread_status = {\n    LUA_OK:        0,\n    LUA_YIELD:     1,\n    LUA_ERRRUN:    2,\n    LUA_ERRSYNTAX: 3,\n    LUA_ERRMEM:    4,\n    LUA_ERRGCMM:   5,\n    LUA_ERRERR:    6\n};\n\nconst constant_types = {\n    LUA_TNONE:          -1,\n    LUA_TNIL:           0,\n    LUA_TBOOLEAN:       1,\n    LUA_TLIGHTUSERDATA: 2,\n    LUA_TNUMBER:        3,\n    LUA_TSTRING:        4,\n    LUA_TTABLE:         5,\n    LUA_TFUNCTION:      6,\n    LUA_TUSERDATA:      7,\n    LUA_TTHREAD:        8,\n    LUA_NUMTAGS:        9\n};\n\nconstant_types.LUA_TSHRSTR = constant_types.LUA_TSTRING | (0 << 4);  /* short strings */\nconstant_types.LUA_TLNGSTR = constant_types.LUA_TSTRING | (1 << 4);  /* long strings */\n\nconstant_types.LUA_TNUMFLT = constant_types.LUA_TNUMBER | (0 << 4);  /* float numbers */\nconstant_types.LUA_TNUMINT = constant_types.LUA_TNUMBER | (1 << 4);  /* integer numbers */\n\nconstant_types.LUA_TLCL = constant_types.LUA_TFUNCTION | (0 << 4);  /* Lua closure */\nconstant_types.LUA_TLCF = constant_types.LUA_TFUNCTION | (1 << 4);  /* light C function */\nconstant_types.LUA_TCCL = constant_types.LUA_TFUNCTION | (2 << 4);  /* C closure */\n\n/*\n** Comparison and arithmetic functions\n*/\n\nconst LUA_OPADD  = 0;   /* ORDER TM, ORDER OP */\nconst LUA_OPSUB  = 1;\nconst LUA_OPMUL  = 2;\nconst LUA_OPMOD  = 3;\nconst LUA_OPPOW  = 4;\nconst LUA_OPDIV  = 5;\nconst LUA_OPIDIV = 6;\nconst LUA_OPBAND = 7;\nconst LUA_OPBOR  = 8;\nconst LUA_OPBXOR = 9;\nconst LUA_OPSHL  = 10;\nconst LUA_OPSHR  = 11;\nconst LUA_OPUNM  = 12;\nconst LUA_OPBNOT = 13;\n\nconst LUA_OPEQ = 0;\nconst LUA_OPLT = 1;\nconst LUA_OPLE = 2;\n\nconst LUA_MINSTACK = 20;\n\nconst { LUAI_MAXSTACK } = require('./luaconf.js');\nconst LUA_REGISTRYINDEX = -LUAI_MAXSTACK - 1000;\n\nconst lua_upvalueindex = function(i) {\n    return LUA_REGISTRYINDEX - i;\n};\n\n/* predefined values in the registry */\nconst LUA_RIDX_MAINTHREAD = 1;\nconst LUA_RIDX_GLOBALS    = 2;\nconst LUA_RIDX_LAST       = LUA_RIDX_GLOBALS;\n\nclass lua_Debug {\n    constructor() {\n        this.event = NaN;\n        this.name = null;           /* (n) */\n        this.namewhat = null;       /* (n) 'global', 'local', 'field', 'method' */\n        this.what = null;           /* (S) 'Lua', 'C', 'main', 'tail' */\n        this.source = null;         /* (S) */\n        this.currentline = NaN;     /* (l) */\n        this.linedefined = NaN;     /* (S) */\n        this.lastlinedefined = NaN; /* (S) */\n        this.nups = NaN;            /* (u) number of upvalues */\n        this.nparams = NaN;         /* (u) number of parameters */\n        this.isvararg = NaN;        /* (u) */\n        this.istailcall = NaN;      /* (t) */\n        this.short_src = null;      /* (S) */\n        /* private part */\n        this.i_ci = null;           /* active function */\n    }\n}\n\n/*\n** Event codes\n*/\nconst LUA_HOOKCALL     = 0;\nconst LUA_HOOKRET      = 1;\nconst LUA_HOOKLINE     = 2;\nconst LUA_HOOKCOUNT    = 3;\nconst LUA_HOOKTAILCALL = 4;\n\n\n/*\n** Event masks\n*/\nconst LUA_MASKCALL  = (1 << LUA_HOOKCALL);\nconst LUA_MASKRET   = (1 << LUA_HOOKRET);\nconst LUA_MASKLINE  = (1 << LUA_HOOKLINE);\nconst LUA_MASKCOUNT = (1 << LUA_HOOKCOUNT);\n\nmodule.exports.LUA_HOOKCALL            = LUA_HOOKCALL;\nmodule.exports.LUA_HOOKCOUNT           = LUA_HOOKCOUNT;\nmodule.exports.LUA_HOOKLINE            = LUA_HOOKLINE;\nmodule.exports.LUA_HOOKRET             = LUA_HOOKRET;\nmodule.exports.LUA_HOOKTAILCALL        = LUA_HOOKTAILCALL;\nmodule.exports.LUA_MASKCALL            = LUA_MASKCALL;\nmodule.exports.LUA_MASKCOUNT           = LUA_MASKCOUNT;\nmodule.exports.LUA_MASKLINE            = LUA_MASKLINE;\nmodule.exports.LUA_MASKRET             = LUA_MASKRET;\nmodule.exports.LUA_MINSTACK            = LUA_MINSTACK;\nmodule.exports.LUA_MULTRET             = -1;\nmodule.exports.LUA_OPADD               = LUA_OPADD;\nmodule.exports.LUA_OPBAND              = LUA_OPBAND;\nmodule.exports.LUA_OPBNOT              = LUA_OPBNOT;\nmodule.exports.LUA_OPBOR               = LUA_OPBOR;\nmodule.exports.LUA_OPBXOR              = LUA_OPBXOR;\nmodule.exports.LUA_OPDIV               = LUA_OPDIV;\nmodule.exports.LUA_OPEQ                = LUA_OPEQ;\nmodule.exports.LUA_OPIDIV              = LUA_OPIDIV;\nmodule.exports.LUA_OPLE                = LUA_OPLE;\nmodule.exports.LUA_OPLT                = LUA_OPLT;\nmodule.exports.LUA_OPMOD               = LUA_OPMOD;\nmodule.exports.LUA_OPMUL               = LUA_OPMUL;\nmodule.exports.LUA_OPPOW               = LUA_OPPOW;\nmodule.exports.LUA_OPSHL               = LUA_OPSHL;\nmodule.exports.LUA_OPSHR               = LUA_OPSHR;\nmodule.exports.LUA_OPSUB               = LUA_OPSUB;\nmodule.exports.LUA_OPUNM               = LUA_OPUNM;\nmodule.exports.LUA_REGISTRYINDEX       = LUA_REGISTRYINDEX;\nmodule.exports.LUA_RIDX_GLOBALS        = LUA_RIDX_GLOBALS;\nmodule.exports.LUA_RIDX_LAST           = LUA_RIDX_LAST;\nmodule.exports.LUA_RIDX_MAINTHREAD     = LUA_RIDX_MAINTHREAD;\nmodule.exports.constant_types          = constant_types;\nmodule.exports.lua_Debug               = lua_Debug;\nmodule.exports.lua_upvalueindex        = lua_upvalueindex;\nmodule.exports.thread_status           = thread_status;\n","\"use strict\";\n\nconst defs   = require(\"./defs.js\");\nconst lapi   = require(\"./lapi.js\");\nconst ldebug = require(\"./ldebug.js\");\nconst ldo    = require(\"./ldo.js\");\nconst lstate = require(\"./lstate.js\");\n\nmodule.exports.LUA_AUTHORS             = defs.LUA_AUTHORS;\nmodule.exports.LUA_COPYRIGHT           = defs.LUA_COPYRIGHT;\nmodule.exports.LUA_ERRERR              = defs.thread_status.LUA_ERRERR;\nmodule.exports.LUA_ERRGCMM             = defs.thread_status.LUA_ERRGCMM;\nmodule.exports.LUA_ERRMEM              = defs.thread_status.LUA_ERRMEM;\nmodule.exports.LUA_ERRRUN              = defs.thread_status.LUA_ERRRUN;\nmodule.exports.LUA_ERRSYNTAX           = defs.thread_status.LUA_ERRSYNTAX;\nmodule.exports.LUA_HOOKCALL            = defs.LUA_HOOKCALL;\nmodule.exports.LUA_HOOKCOUNT           = defs.LUA_HOOKCOUNT;\nmodule.exports.LUA_HOOKLINE            = defs.LUA_HOOKLINE;\nmodule.exports.LUA_HOOKRET             = defs.LUA_HOOKRET;\nmodule.exports.LUA_HOOKTAILCALL        = defs.LUA_HOOKTAILCALL;\nmodule.exports.LUA_MASKCALL            = defs.LUA_MASKCALL;\nmodule.exports.LUA_MASKCOUNT           = defs.LUA_MASKCOUNT;\nmodule.exports.LUA_MASKLINE            = defs.LUA_MASKLINE;\nmodule.exports.LUA_MASKRET             = defs.LUA_MASKRET;\nmodule.exports.LUA_MINSTACK            = defs.LUA_MINSTACK;\nmodule.exports.LUA_MULTRET             = defs.LUA_MULTRET;\nmodule.exports.LUA_NUMTAGS             = defs.constant_types.LUA_NUMTAGS;\nmodule.exports.LUA_OK                  = defs.thread_status.LUA_OK;\nmodule.exports.LUA_OPADD               = defs.LUA_OPADD;\nmodule.exports.LUA_OPBAND              = defs.LUA_OPBAND;\nmodule.exports.LUA_OPBNOT              = defs.LUA_OPBNOT;\nmodule.exports.LUA_OPBOR               = defs.LUA_OPBOR;\nmodule.exports.LUA_OPBXOR              = defs.LUA_OPBXOR;\nmodule.exports.LUA_OPDIV               = defs.LUA_OPDIV;\nmodule.exports.LUA_OPEQ                = defs.LUA_OPEQ;\nmodule.exports.LUA_OPIDIV              = defs.LUA_OPIDIV;\nmodule.exports.LUA_OPLE                = defs.LUA_OPLE;\nmodule.exports.LUA_OPLT                = defs.LUA_OPLT;\nmodule.exports.LUA_OPMOD               = defs.LUA_OPMOD;\nmodule.exports.LUA_OPMUL               = defs.LUA_OPMUL;\nmodule.exports.LUA_OPPOW               = defs.LUA_OPPOW;\nmodule.exports.LUA_OPSHL               = defs.LUA_OPSHL;\nmodule.exports.LUA_OPSHR               = defs.LUA_OPSHR;\nmodule.exports.LUA_OPSUB               = defs.LUA_OPSUB;\nmodule.exports.LUA_OPUNM               = defs.LUA_OPUNM;\nmodule.exports.LUA_REGISTRYINDEX       = defs.LUA_REGISTRYINDEX;\nmodule.exports.LUA_RELEASE             = defs.LUA_RELEASE;\nmodule.exports.LUA_RIDX_GLOBALS        = defs.LUA_RIDX_GLOBALS;\nmodule.exports.LUA_RIDX_LAST           = defs.LUA_RIDX_LAST;\nmodule.exports.LUA_RIDX_MAINTHREAD     = defs.LUA_RIDX_MAINTHREAD;\nmodule.exports.LUA_SIGNATURE           = defs.LUA_SIGNATURE;\nmodule.exports.LUA_TNONE               = defs.constant_types.LUA_TNONE;\nmodule.exports.LUA_TNIL                = defs.constant_types.LUA_TNIL;\nmodule.exports.LUA_TBOOLEAN            = defs.constant_types.LUA_TBOOLEAN;\nmodule.exports.LUA_TLIGHTUSERDATA      = defs.constant_types.LUA_TLIGHTUSERDATA;\nmodule.exports.LUA_TNUMBER             = defs.constant_types.LUA_TNUMBER;\nmodule.exports.LUA_TSTRING             = defs.constant_types.LUA_TSTRING;\nmodule.exports.LUA_TTABLE              = defs.constant_types.LUA_TTABLE;\nmodule.exports.LUA_TFUNCTION           = defs.constant_types.LUA_TFUNCTION;\nmodule.exports.LUA_TUSERDATA           = defs.constant_types.LUA_TUSERDATA;\nmodule.exports.LUA_TTHREAD             = defs.constant_types.LUA_TTHREAD;\nmodule.exports.LUA_VERSION             = defs.LUA_VERSION;\nmodule.exports.LUA_VERSION_MAJOR       = defs.LUA_VERSION_MAJOR;\nmodule.exports.LUA_VERSION_MINOR       = defs.LUA_VERSION_MINOR;\nmodule.exports.LUA_VERSION_NUM         = defs.LUA_VERSION_NUM;\nmodule.exports.LUA_VERSION_RELEASE     = defs.LUA_VERSION_RELEASE;\nmodule.exports.LUA_YIELD               = defs.thread_status.LUA_YIELD;\nmodule.exports.lua_Debug               = defs.lua_Debug;\nmodule.exports.lua_upvalueindex        = defs.lua_upvalueindex;\nmodule.exports.lua_absindex            = lapi.lua_absindex;\nmodule.exports.lua_arith               = lapi.lua_arith;\nmodule.exports.lua_atpanic             = lapi.lua_atpanic;\nmodule.exports.lua_atnativeerror       = lapi.lua_atnativeerror;\nmodule.exports.lua_call                = lapi.lua_call;\nmodule.exports.lua_callk               = lapi.lua_callk;\nmodule.exports.lua_checkstack          = lapi.lua_checkstack;\nmodule.exports.lua_close               = lstate.lua_close;\nmodule.exports.lua_compare             = lapi.lua_compare;\nmodule.exports.lua_concat              = lapi.lua_concat;\nmodule.exports.lua_copy                = lapi.lua_copy;\nmodule.exports.lua_createtable         = lapi.lua_createtable;\nmodule.exports.lua_dump                = lapi.lua_dump;\nmodule.exports.lua_error               = lapi.lua_error;\nmodule.exports.lua_gc                  = lapi.lua_gc;\nmodule.exports.lua_getallocf           = lapi.lua_getallocf;\nmodule.exports.lua_getextraspace       = lapi.lua_getextraspace;\nmodule.exports.lua_getfield            = lapi.lua_getfield;\nmodule.exports.lua_getglobal           = lapi.lua_getglobal;\nmodule.exports.lua_gethook             = ldebug.lua_gethook;\nmodule.exports.lua_gethookcount        = ldebug.lua_gethookcount;\nmodule.exports.lua_gethookmask         = ldebug.lua_gethookmask;\nmodule.exports.lua_geti                = lapi.lua_geti;\nmodule.exports.lua_getinfo             = ldebug.lua_getinfo;\nmodule.exports.lua_getlocal            = ldebug.lua_getlocal;\nmodule.exports.lua_getmetatable        = lapi.lua_getmetatable;\nmodule.exports.lua_getstack            = ldebug.lua_getstack;\nmodule.exports.lua_gettable            = lapi.lua_gettable;\nmodule.exports.lua_gettop              = lapi.lua_gettop;\nmodule.exports.lua_getupvalue          = lapi.lua_getupvalue;\nmodule.exports.lua_getuservalue        = lapi.lua_getuservalue;\nmodule.exports.lua_insert              = lapi.lua_insert;\nmodule.exports.lua_isboolean           = lapi.lua_isboolean;\nmodule.exports.lua_iscfunction         = lapi.lua_iscfunction;\nmodule.exports.lua_isfunction          = lapi.lua_isfunction;\nmodule.exports.lua_isinteger           = lapi.lua_isinteger;\nmodule.exports.lua_islightuserdata     = lapi.lua_islightuserdata;\nmodule.exports.lua_isnil               = lapi.lua_isnil;\nmodule.exports.lua_isnone              = lapi.lua_isnone;\nmodule.exports.lua_isnoneornil         = lapi.lua_isnoneornil;\nmodule.exports.lua_isnumber            = lapi.lua_isnumber;\nmodule.exports.lua_isproxy             = lapi.lua_isproxy;\nmodule.exports.lua_isstring            = lapi.lua_isstring;\nmodule.exports.lua_istable             = lapi.lua_istable;\nmodule.exports.lua_isthread            = lapi.lua_isthread;\nmodule.exports.lua_isuserdata          = lapi.lua_isuserdata;\nmodule.exports.lua_isyieldable         = ldo.lua_isyieldable;\nmodule.exports.lua_len                 = lapi.lua_len;\nmodule.exports.lua_load                = lapi.lua_load;\nmodule.exports.lua_newstate            = lstate.lua_newstate;\nmodule.exports.lua_newtable            = lapi.lua_newtable;\nmodule.exports.lua_newthread           = lstate.lua_newthread;\nmodule.exports.lua_newuserdata         = lapi.lua_newuserdata;\nmodule.exports.lua_next                = lapi.lua_next;\nmodule.exports.lua_pcall               = lapi.lua_pcall;\nmodule.exports.lua_pcallk              = lapi.lua_pcallk;\nmodule.exports.lua_pop                 = lapi.lua_pop;\nmodule.exports.lua_pushboolean         = lapi.lua_pushboolean;\nmodule.exports.lua_pushcclosure        = lapi.lua_pushcclosure;\nmodule.exports.lua_pushcfunction       = lapi.lua_pushcfunction;\nmodule.exports.lua_pushfstring         = lapi.lua_pushfstring;\nmodule.exports.lua_pushglobaltable     = lapi.lua_pushglobaltable;\nmodule.exports.lua_pushinteger         = lapi.lua_pushinteger;\nmodule.exports.lua_pushjsclosure       = lapi.lua_pushjsclosure;\nmodule.exports.lua_pushjsfunction      = lapi.lua_pushjsfunction;\nmodule.exports.lua_pushlightuserdata   = lapi.lua_pushlightuserdata;\nmodule.exports.lua_pushliteral         = lapi.lua_pushliteral;\nmodule.exports.lua_pushlstring         = lapi.lua_pushlstring;\nmodule.exports.lua_pushnil             = lapi.lua_pushnil;\nmodule.exports.lua_pushnumber          = lapi.lua_pushnumber;\nmodule.exports.lua_pushstring          = lapi.lua_pushstring;\nmodule.exports.lua_pushthread          = lapi.lua_pushthread;\nmodule.exports.lua_pushvalue           = lapi.lua_pushvalue;\nmodule.exports.lua_pushvfstring        = lapi.lua_pushvfstring;\nmodule.exports.lua_rawequal            = lapi.lua_rawequal;\nmodule.exports.lua_rawget              = lapi.lua_rawget;\nmodule.exports.lua_rawgeti             = lapi.lua_rawgeti;\nmodule.exports.lua_rawgetp             = lapi.lua_rawgetp;\nmodule.exports.lua_rawlen              = lapi.lua_rawlen;\nmodule.exports.lua_rawset              = lapi.lua_rawset;\nmodule.exports.lua_rawseti             = lapi.lua_rawseti;\nmodule.exports.lua_rawsetp             = lapi.lua_rawsetp;\nmodule.exports.lua_register            = lapi.lua_register;\nmodule.exports.lua_remove              = lapi.lua_remove;\nmodule.exports.lua_replace             = lapi.lua_replace;\nmodule.exports.lua_resume              = ldo.lua_resume;\nmodule.exports.lua_rotate              = lapi.lua_rotate;\nmodule.exports.lua_setallof            = ldo.lua_setallof;\nmodule.exports.lua_setfield            = lapi.lua_setfield;\nmodule.exports.lua_setglobal           = lapi.lua_setglobal;\nmodule.exports.lua_sethook             = ldebug.lua_sethook;\nmodule.exports.lua_seti                = lapi.lua_seti;\nmodule.exports.lua_setlocal            = ldebug.lua_setlocal;\nmodule.exports.lua_setmetatable        = lapi.lua_setmetatable;\nmodule.exports.lua_settable            = lapi.lua_settable;\nmodule.exports.lua_settop              = lapi.lua_settop;\nmodule.exports.lua_setupvalue          = lapi.lua_setupvalue;\nmodule.exports.lua_setuservalue        = lapi.lua_setuservalue;\nmodule.exports.lua_status              = lapi.lua_status;\nmodule.exports.lua_stringtonumber      = lapi.lua_stringtonumber;\nmodule.exports.lua_toboolean           = lapi.lua_toboolean;\nmodule.exports.lua_todataview          = lapi.lua_todataview;\nmodule.exports.lua_tointeger           = lapi.lua_tointeger;\nmodule.exports.lua_tointegerx          = lapi.lua_tointegerx;\nmodule.exports.lua_tojsstring          = lapi.lua_tojsstring;\nmodule.exports.lua_tolstring           = lapi.lua_tolstring;\nmodule.exports.lua_tonumber            = lapi.lua_tonumber;\nmodule.exports.lua_tonumberx           = lapi.lua_tonumberx;\nmodule.exports.lua_topointer           = lapi.lua_topointer;\nmodule.exports.lua_toproxy             = lapi.lua_toproxy;\nmodule.exports.lua_tostring            = lapi.lua_tostring;\nmodule.exports.lua_tothread            = lapi.lua_tothread;\nmodule.exports.lua_touserdata          = lapi.lua_touserdata;\nmodule.exports.lua_type                = lapi.lua_type;\nmodule.exports.lua_typename            = lapi.lua_typename;\nmodule.exports.lua_upvalueid           = lapi.lua_upvalueid;\nmodule.exports.lua_upvaluejoin         = lapi.lua_upvaluejoin;\nmodule.exports.lua_version             = lapi.lua_version;\nmodule.exports.lua_xmove               = lapi.lua_xmove;\nmodule.exports.lua_yield               = ldo.lua_yield;\nmodule.exports.lua_yieldk              = ldo.lua_yieldk;\nmodule.exports.lua_tocfunction         = lapi.lua_tocfunction;\n","\"use strict\";\n\nconst conf = (process.env.FENGARICONF ? JSON.parse(process.env.FENGARICONF) : {});\n\nconst {\n    LUA_VERSION_MAJOR,\n    LUA_VERSION_MINOR,\n    to_luastring\n} = require('./defs.js');\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n*/\nconst LUA_PATH_SEP  = \";\";\nmodule.exports.LUA_PATH_SEP = LUA_PATH_SEP;\n\nconst LUA_PATH_MARK = \"?\";\nmodule.exports.LUA_PATH_MARK = LUA_PATH_MARK;\n\nconst LUA_EXEC_DIR  = \"!\";\nmodule.exports.LUA_EXEC_DIR = LUA_EXEC_DIR;\n\n/*\n@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for\n** Lua libraries.\n@@ LUA_JSPATH_DEFAULT is the default path that Lua uses to look for\n** JS libraries.\n** CHANGE them if your machine has a non-conventional directory\n** hierarchy or if you want to install your libraries in\n** non-conventional directories.\n*/\nconst LUA_VDIR = LUA_VERSION_MAJOR + \".\" + LUA_VERSION_MINOR;\nmodule.exports.LUA_VDIR = LUA_VDIR;\n\nif (typeof process === \"undefined\") {\n    const LUA_DIRSEP = \"/\";\n    module.exports.LUA_DIRSEP = LUA_DIRSEP;\n\n    const LUA_LDIR = \"./lua/\" + LUA_VDIR + \"/\";\n    module.exports.LUA_LDIR = LUA_LDIR;\n\n    const LUA_JSDIR = LUA_LDIR;\n    module.exports.LUA_JSDIR = LUA_JSDIR;\n\n    const LUA_PATH_DEFAULT = to_luastring(\n        LUA_LDIR + \"?.lua;\" + LUA_LDIR + \"?/init.lua;\" +\n        /* LUA_JSDIR excluded as it is equal to LUA_LDIR */\n        \"./?.lua;./?/init.lua\"\n    );\n    module.exports.LUA_PATH_DEFAULT = LUA_PATH_DEFAULT;\n\n    const LUA_JSPATH_DEFAULT = to_luastring(\n        LUA_JSDIR + \"?.js;\" + LUA_JSDIR + \"loadall.js;./?.js\"\n    );\n    module.exports.LUA_JSPATH_DEFAULT = LUA_JSPATH_DEFAULT;\n} else if (require('os').platform() === 'win32') {\n    const LUA_DIRSEP = \"\\\\\";\n    module.exports.LUA_DIRSEP = LUA_DIRSEP;\n\n    /*\n    ** In Windows, any exclamation mark ('!') in the path is replaced by the\n    ** path of the directory of the executable file of the current process.\n    */\n    const LUA_LDIR = \"!\\\\lua\\\\\";\n    module.exports.LUA_LDIR = LUA_LDIR;\n\n    const LUA_JSDIR = \"!\\\\\";\n    module.exports.LUA_JSDIR = LUA_JSDIR;\n\n    const LUA_SHRDIR = \"!\\\\..\\\\share\\\\lua\\\\\" + LUA_VDIR + \"\\\\\";\n    module.exports.LUA_SHRDIR = LUA_SHRDIR;\n\n    const LUA_PATH_DEFAULT = to_luastring(\n        LUA_LDIR + \"?.lua;\" + LUA_LDIR + \"?\\\\init.lua;\" +\n        LUA_JSDIR + \"?.lua;\" + LUA_JSDIR + \"?\\\\init.lua;\" +\n        LUA_SHRDIR + \"?.lua;\" + LUA_SHRDIR + \"?\\\\init.lua;\" +\n        \".\\\\?.lua;.\\\\?\\\\init.lua\"\n    );\n    module.exports.LUA_PATH_DEFAULT = LUA_PATH_DEFAULT;\n\n    const LUA_JSPATH_DEFAULT = to_luastring(\n        LUA_JSDIR + \"?.js;\" +\n        LUA_JSDIR + \"..\\\\share\\\\lua\\\\\" + LUA_VDIR + \"\\\\?.js;\" +\n        LUA_JSDIR + \"loadall.js;.\\\\?.js\"\n    );\n    module.exports.LUA_JSPATH_DEFAULT = LUA_JSPATH_DEFAULT;\n} else {\n    const LUA_DIRSEP = \"/\";\n    module.exports.LUA_DIRSEP = LUA_DIRSEP;\n\n    const LUA_ROOT = \"/usr/local/\";\n    module.exports.LUA_ROOT = LUA_ROOT;\n    const LUA_ROOT2 = \"/usr/\";\n\n    const LUA_LDIR = LUA_ROOT + \"share/lua/\" + LUA_VDIR + \"/\";\n    const LUA_LDIR2 = LUA_ROOT2 + \"share/lua/\" + LUA_VDIR + \"/\";\n    module.exports.LUA_LDIR = LUA_LDIR;\n\n    const LUA_JSDIR = LUA_LDIR;\n    module.exports.LUA_JSDIR = LUA_JSDIR;\n    const LUA_JSDIR2 = LUA_LDIR2;\n\n    const LUA_PATH_DEFAULT = to_luastring(\n        LUA_LDIR + \"?.lua;\" + LUA_LDIR + \"?/init.lua;\" +\n        LUA_LDIR2 + \"?.lua;\" + LUA_LDIR2 + \"?/init.lua;\" +\n        /* LUA_JSDIR(2) excluded as it is equal to LUA_LDIR(2) */\n        \"./?.lua;./?/init.lua\"\n    );\n    module.exports.LUA_PATH_DEFAULT = LUA_PATH_DEFAULT;\n\n    const LUA_JSPATH_DEFAULT = to_luastring(\n        LUA_JSDIR + \"?.js;\" + LUA_JSDIR + \"loadall.js;\" +\n        LUA_JSDIR2 + \"?.js;\" + LUA_JSDIR2 + \"loadall.js;\" +\n        \"./?.js\"\n    );\n    module.exports.LUA_JSPATH_DEFAULT = LUA_JSPATH_DEFAULT;\n}\n\n/*\n@@ LUA_COMPAT_FLOATSTRING makes Lua format integral floats without a\n@@ a float mark ('.0').\n** This macro is not on by default even in compatibility mode,\n** because this is not really an incompatibility.\n*/\nconst LUA_COMPAT_FLOATSTRING = conf.LUA_COMPAT_FLOATSTRING || false;\n\nconst LUA_MAXINTEGER = 2147483647;\nconst LUA_MININTEGER = -2147483648;\n\n/*\n@@ LUAI_MAXSTACK limits the size of the Lua stack.\n** CHANGE it if you need a different limit. This limit is arbitrary;\n** its only purpose is to stop Lua from consuming unlimited stack\n** space (and to reserve some numbers for pseudo-indices).\n*/\nconst LUAI_MAXSTACK = conf.LUAI_MAXSTACK || 1000000;\n\n/*\n@@ LUA_IDSIZE gives the maximum size for the description of the source\n@@ of a function in debug information.\n** CHANGE it if you want a different size.\n*/\nconst LUA_IDSIZE = conf.LUA_IDSIZE || (60-1); /* fengari uses 1 less than lua as we don't embed the null byte */\n\nconst lua_integer2str = function(n) {\n    return String(n); /* should match behaviour of LUA_INTEGER_FMT */\n};\n\nconst lua_number2str = function(n) {\n    return String(Number(n.toPrecision(14))); /* should match behaviour of LUA_NUMBER_FMT */\n};\n\nconst lua_numbertointeger = function(n) {\n    return n >= LUA_MININTEGER && n < -LUA_MININTEGER ? n : false;\n};\n\nconst LUA_INTEGER_FRMLEN = \"\";\nconst LUA_NUMBER_FRMLEN = \"\";\n\nconst LUA_INTEGER_FMT = `%${LUA_INTEGER_FRMLEN}d`;\nconst LUA_NUMBER_FMT  = \"%.14g\";\n\nconst lua_getlocaledecpoint = function() {\n    /* we hard-code the decimal point to '.' as a user cannot change the\n       locale in most JS environments, and in that you can, a multi-byte\n       locale is common.\n    */\n    return 46 /* '.'.charCodeAt(0) */;\n};\n\nconst luai_apicheck = function(l, e) {\n    if (!e) throw Error(e);\n};\n\n/*\n@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.\n*/\nconst LUAL_BUFFERSIZE = conf.LUAL_BUFFERSIZE || 8192;\n\n// See: http://croquetweak.blogspot.fr/2014/08/deconstructing-floats-frexp-and-ldexp.html\nconst frexp = function(value) {\n    if (value === 0) return [value, 0];\n    var data = new DataView(new ArrayBuffer(8));\n    data.setFloat64(0, value);\n    var bits = (data.getUint32(0) >>> 20) & 0x7FF;\n    if (bits === 0) { // denormal\n        data.setFloat64(0, value * Math.pow(2, 64));  // exp + 64\n        bits = ((data.getUint32(0) >>> 20) & 0x7FF) - 64;\n    }\n    var exponent = bits - 1022;\n    var mantissa = ldexp(value, -exponent);\n    return [mantissa, exponent];\n};\n\nconst ldexp = function(mantissa, exponent) {\n    var steps = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));\n    var result = mantissa;\n    for (var i = 0; i < steps; i++)\n        result *= Math.pow(2, Math.floor((exponent + i) / steps));\n    return result;\n};\n\nmodule.exports.LUAI_MAXSTACK          = LUAI_MAXSTACK;\nmodule.exports.LUA_COMPAT_FLOATSTRING = LUA_COMPAT_FLOATSTRING;\nmodule.exports.LUA_IDSIZE             = LUA_IDSIZE;\nmodule.exports.LUA_INTEGER_FMT        = LUA_INTEGER_FMT;\nmodule.exports.LUA_INTEGER_FRMLEN     = LUA_INTEGER_FRMLEN;\nmodule.exports.LUA_MAXINTEGER         = LUA_MAXINTEGER;\nmodule.exports.LUA_MININTEGER         = LUA_MININTEGER;\nmodule.exports.LUA_NUMBER_FMT         = LUA_NUMBER_FMT;\nmodule.exports.LUA_NUMBER_FRMLEN      = LUA_NUMBER_FRMLEN;\nmodule.exports.LUAL_BUFFERSIZE        = LUAL_BUFFERSIZE;\nmodule.exports.frexp                  = frexp;\nmodule.exports.ldexp                  = ldexp;\nmodule.exports.lua_getlocaledecpoint  = lua_getlocaledecpoint;\nmodule.exports.lua_integer2str        = lua_integer2str;\nmodule.exports.lua_number2str         = lua_number2str;\nmodule.exports.lua_numbertointeger    = lua_numbertointeger;\nmodule.exports.luai_apicheck          = luai_apicheck;\n","\"use strict\";\n\nconst { luai_apicheck } = require(\"./luaconf.js\");\n\nconst lua_assert = function(c) {\n    if (!c) throw Error(\"assertion failed\");\n};\nmodule.exports.lua_assert = lua_assert;\n\nmodule.exports.luai_apicheck = luai_apicheck || function(l, e) { return lua_assert(e); };\n\nconst api_check = function(l, e, msg) {\n    return luai_apicheck(l, e && msg);\n};\nmodule.exports.api_check = api_check;\n\nconst LUAI_MAXCCALLS = 200;\nmodule.exports.LUAI_MAXCCALLS = LUAI_MAXCCALLS;\n\n/* minimum size for string buffer */\nconst LUA_MINBUFFER = 32;\nmodule.exports.LUA_MINBUFFER = LUA_MINBUFFER;\n\nconst luai_nummod = function(L, a, b) {\n    let m = a % b;\n    if ((m*b) < 0)\n        m += b;\n    return m;\n};\nmodule.exports.luai_nummod = luai_nummod;\n\n// If later integers are more than 32bit, LUA_MAXINTEGER will then be != MAX_INT\nconst MAX_INT = 2147483647;\nmodule.exports.MAX_INT = MAX_INT;\nconst MIN_INT = -2147483648;\nmodule.exports.MIN_INT = MIN_INT;\n","/* Fengari specific functions\n *\n * This file includes fengari-specific data or and functionality for users to\n * manipulate fengari's string type.\n * The fields are exposed to the user on the 'fengari' entry point; however to\n * avoid a dependency on defs.js from lauxlib.js they are defined in this file.\n */\n\nconst defs = require(\"./defs.js\");\n\nconst FENGARI_VERSION_MAJOR   = \"0\";\nconst FENGARI_VERSION_MINOR   = \"1\";\nconst FENGARI_VERSION_NUM     = 1;\nconst FENGARI_VERSION_RELEASE = \"4\";\nconst FENGARI_VERSION         = \"Fengari \" + FENGARI_VERSION_MAJOR + \".\" + FENGARI_VERSION_MINOR;\nconst FENGARI_RELEASE         = FENGARI_VERSION + \".\" + FENGARI_VERSION_RELEASE;\nconst FENGARI_AUTHORS         = \"B. Giannangeli, Daurnimator\";\nconst FENGARI_COPYRIGHT       = FENGARI_RELEASE + \"  Copyright (C) 2017-2018 \" + FENGARI_AUTHORS + \"\\nBased on: \" + defs.LUA_COPYRIGHT;\n\nmodule.exports.FENGARI_AUTHORS         = FENGARI_AUTHORS;\nmodule.exports.FENGARI_COPYRIGHT       = FENGARI_COPYRIGHT;\nmodule.exports.FENGARI_RELEASE         = FENGARI_RELEASE;\nmodule.exports.FENGARI_VERSION         = FENGARI_VERSION;\nmodule.exports.FENGARI_VERSION_MAJOR   = FENGARI_VERSION_MAJOR;\nmodule.exports.FENGARI_VERSION_MINOR   = FENGARI_VERSION_MINOR;\nmodule.exports.FENGARI_VERSION_NUM     = FENGARI_VERSION_NUM;\nmodule.exports.FENGARI_VERSION_RELEASE = FENGARI_VERSION_RELEASE;\nmodule.exports.is_luastring            = defs.is_luastring;\nmodule.exports.luastring_eq            = defs.luastring_eq;\nmodule.exports.luastring_from          = defs.luastring_from;\nmodule.exports.luastring_indexOf       = defs.luastring_indexOf;\nmodule.exports.luastring_of            = defs.luastring_of;\nmodule.exports.to_jsstring             = defs.to_jsstring;\nmodule.exports.to_luastring            = defs.to_luastring;\nmodule.exports.to_uristring            = defs.to_uristring;\nmodule.exports.from_userstring         = defs.from_userstring;\n","\"use strict\";\n\nconst {\n    LUA_OPADD,\n    LUA_OPBAND,\n    LUA_OPBNOT,\n    LUA_OPBOR,\n    LUA_OPBXOR,\n    LUA_OPDIV,\n    LUA_OPIDIV,\n    LUA_OPMOD,\n    LUA_OPMUL,\n    LUA_OPPOW,\n    LUA_OPSHL,\n    LUA_OPSHR,\n    LUA_OPSUB,\n    LUA_OPUNM,\n    constant_types: {\n        LUA_NUMTAGS,\n        LUA_TBOOLEAN,\n        LUA_TCCL,\n        LUA_TFUNCTION,\n        LUA_TLCF,\n        LUA_TLCL,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMBER,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR,\n        LUA_TSTRING,\n        LUA_TTABLE,\n        LUA_TTHREAD,\n        LUA_TUSERDATA\n    },\n    from_userstring,\n    luastring_indexOf,\n    luastring_of,\n    to_jsstring,\n    to_luastring\n} = require('./defs.js');\nconst {\n    lisdigit,\n    lisprint,\n    lisspace,\n    lisxdigit\n} = require('./ljstype.js');\nconst ldebug  = require('./ldebug.js');\nconst ldo     = require('./ldo.js');\nconst lstate  = require('./lstate.js');\nconst {\n    luaS_bless,\n    luaS_new\n} = require('./lstring.js');\nconst ltable  = require('./ltable.js');\nconst {\n    LUA_COMPAT_FLOATSTRING,\n    ldexp,\n    lua_integer2str,\n    lua_number2str\n} = require('./luaconf.js');\nconst lvm     = require('./lvm.js');\nconst {\n    MAX_INT,\n    luai_nummod,\n    lua_assert\n} = require(\"./llimits.js\");\nconst ltm     = require('./ltm.js');\n\nconst LUA_TPROTO = LUA_NUMTAGS;\nconst LUA_TDEADKEY = LUA_NUMTAGS+1;\n\nclass TValue {\n\n    constructor(type, value) {\n        this.type = type;\n        this.value = value;\n    }\n\n    /* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */\n    ttype() {\n        return this.type & 0x3F;\n    }\n\n    /* type tag of a TValue with no variants (bits 0-3) */\n    ttnov() {\n        return this.type & 0x0F;\n    }\n\n    checktag(t) {\n        return this.type === t;\n    }\n\n    checktype(t) {\n        return this.ttnov() === t;\n    }\n\n    ttisnumber() {\n        return this.checktype(LUA_TNUMBER);\n    }\n\n    ttisfloat() {\n        return this.checktag(LUA_TNUMFLT);\n    }\n\n    ttisinteger() {\n        return this.checktag(LUA_TNUMINT);\n    }\n\n    ttisnil() {\n        return this.checktag(LUA_TNIL);\n    }\n\n    ttisboolean() {\n        return this.checktag(LUA_TBOOLEAN);\n    }\n\n    ttislightuserdata() {\n        return this.checktag(LUA_TLIGHTUSERDATA);\n    }\n\n    ttisstring() {\n        return this.checktype(LUA_TSTRING);\n    }\n\n    ttisshrstring() {\n        return this.checktag(LUA_TSHRSTR);\n    }\n\n    ttislngstring() {\n        return this.checktag(LUA_TLNGSTR);\n    }\n\n    ttistable() {\n        return this.checktag(LUA_TTABLE);\n    }\n\n    ttisfunction() {\n        return this.checktype(LUA_TFUNCTION);\n    }\n\n    ttisclosure() {\n        return (this.type & 0x1F) === LUA_TFUNCTION;\n    }\n\n    ttisCclosure() {\n        return this.checktag(LUA_TCCL);\n    }\n\n    ttisLclosure() {\n        return this.checktag(LUA_TLCL);\n    }\n\n    ttislcf() {\n        return this.checktag(LUA_TLCF);\n    }\n\n    ttisfulluserdata() {\n        return this.checktag(LUA_TUSERDATA);\n    }\n\n    ttisthread() {\n        return this.checktag(LUA_TTHREAD);\n    }\n\n    ttisdeadkey() {\n        return this.checktag(LUA_TDEADKEY);\n    }\n\n    l_isfalse() {\n        return this.ttisnil() || (this.ttisboolean() && this.value === false);\n    }\n\n    setfltvalue(x) {\n        this.type = LUA_TNUMFLT;\n        this.value = x;\n    }\n\n    chgfltvalue(x) {\n        lua_assert(this.type == LUA_TNUMFLT);\n        this.value = x;\n    }\n\n    setivalue(x) {\n        this.type = LUA_TNUMINT;\n        this.value = x;\n    }\n\n    chgivalue(x) {\n        lua_assert(this.type == LUA_TNUMINT);\n        this.value = x;\n    }\n\n    setnilvalue() {\n        this.type = LUA_TNIL;\n        this.value = null;\n    }\n\n    setfvalue(x) {\n        this.type = LUA_TLCF;\n        this.value = x;\n    }\n\n    setpvalue(x) {\n        this.type = LUA_TLIGHTUSERDATA;\n        this.value = x;\n    }\n\n    setbvalue(x) {\n        this.type = LUA_TBOOLEAN;\n        this.value = x;\n    }\n\n    setsvalue(x) {\n        this.type = LUA_TLNGSTR; /* LUA_TSHRSTR? */\n        this.value = x;\n    }\n\n    setuvalue(x) {\n        this.type = LUA_TUSERDATA;\n        this.value = x;\n    }\n\n    setthvalue(x) {\n        this.type = LUA_TTHREAD;\n        this.value = x;\n    }\n\n    setclLvalue(x) {\n        this.type = LUA_TLCL;\n        this.value = x;\n    }\n\n    setclCvalue(x) {\n        this.type = LUA_TCCL;\n        this.value = x;\n    }\n\n    sethvalue(x) {\n        this.type = LUA_TTABLE;\n        this.value = x;\n    }\n\n    setdeadvalue() {\n        this.type = LUA_TDEADKEY;\n        this.value = null;\n    }\n\n    setfrom(tv) { /* in lua C source setobj2t is often used for this */\n        this.type = tv.type;\n        this.value = tv.value;\n    }\n\n    tsvalue() {\n        lua_assert(this.ttisstring());\n        return this.value;\n    }\n\n    svalue() {\n        return this.tsvalue().getstr();\n    }\n\n    vslen() {\n        return this.tsvalue().tsslen();\n    }\n\n    jsstring(from, to) {\n        return to_jsstring(this.svalue(), from, to, true);\n    }\n}\n\nconst pushobj2s = function(L, tv) {\n    L.stack[L.top++] = new TValue(tv.type, tv.value);\n};\nconst pushsvalue2s = function(L, ts) {\n    L.stack[L.top++] = new TValue(LUA_TLNGSTR, ts);\n};\n/* from stack to (same) stack */\nconst setobjs2s = function(L, newidx, oldidx) {\n    L.stack[newidx].setfrom(L.stack[oldidx]);\n};\n/* to stack (not from same stack) */\nconst setobj2s = function(L, newidx, oldtv) {\n    L.stack[newidx].setfrom(oldtv);\n};\nconst setsvalue2s = function(L, newidx, ts) {\n    L.stack[newidx].setsvalue(ts);\n};\n\nconst luaO_nilobject = new TValue(LUA_TNIL, null);\nObject.freeze(luaO_nilobject);\nmodule.exports.luaO_nilobject = luaO_nilobject;\n\nclass LClosure {\n\n    constructor(L, n) {\n        this.id = L.l_G.id_counter++;\n\n        this.p = null;\n        this.nupvalues = n;\n        this.upvals = new Array(n); /* list of upvalues. initialised in luaF_initupvals */\n    }\n\n}\n\nclass CClosure {\n\n    constructor(L, f, n) {\n        this.id = L.l_G.id_counter++;\n\n        this.f = f;\n        this.nupvalues = n;\n        this.upvalue = new Array(n); /* list of upvalues as TValues */\n        while (n--) {\n            this.upvalue[n] = new TValue(LUA_TNIL, null);\n        }\n    }\n\n}\n\nclass Udata {\n\n    constructor(L, size) {\n        this.id = L.l_G.id_counter++;\n\n        this.metatable = null;\n        this.uservalue = new TValue(LUA_TNIL, null);\n        this.len = size;\n        this.data = Object.create(null); // ignores size argument\n    }\n\n}\n\n/*\n** Description of a local variable for function prototypes\n** (used for debug information)\n*/\nclass LocVar {\n    constructor() {\n        this.varname = null;\n        this.startpc = NaN;  /* first point where variable is active */\n        this.endpc = NaN;    /* first point where variable is dead */\n    }\n}\n\nconst RETS = to_luastring(\"...\");\nconst PRE  = to_luastring(\"[string \\\"\");\nconst POS  = to_luastring(\"\\\"]\");\n\nconst luaO_chunkid = function(source, bufflen) {\n    let l = source.length;\n    let out;\n    if (source[0] === 61 /* ('=').charCodeAt(0) */) {  /* 'literal' source */\n        if (l < bufflen) {  /* small enough? */\n            out = new Uint8Array(l-1);\n            out.set(source.subarray(1));\n        } else {  /* truncate it */\n            out = new Uint8Array(bufflen);\n            out.set(source.subarray(1, bufflen+1));\n        }\n    } else if (source[0] === 64 /* ('@').charCodeAt(0) */) {  /* file name */\n        if (l <= bufflen) {  /* small enough? */\n            out = new Uint8Array(l-1);\n            out.set(source.subarray(1));\n        } else {  /* add '...' before rest of name */\n            out = new Uint8Array(bufflen);\n            out.set(RETS);\n            bufflen -= RETS.length;\n            out.set(source.subarray(l - bufflen), RETS.length);\n        }\n    } else {  /* string; format as [string \"source\"] */\n        out = new Uint8Array(bufflen);\n        let nli = luastring_indexOf(source, 10 /* ('\\n').charCodeAt(0) */);  /* find first new line (if any) */\n        out.set(PRE);  /* add prefix */\n        let out_i = PRE.length;\n        bufflen -= PRE.length + RETS.length + POS.length;  /* save space for prefix+suffix */\n        if (l < bufflen && nli === -1) {  /* small one-line source? */\n            out.set(source, out_i);  /* keep it */\n            out_i += source.length;\n        } else {\n            if (nli !== -1) l = nli;  /* stop at first newline */\n            if (l > bufflen) l = bufflen;\n            out.set(source.subarray(0, l), out_i);\n            out_i += l;\n            out.set(RETS, out_i);\n            out_i += RETS.length;\n        }\n        out.set(POS, out_i);\n        out_i += POS.length;\n        out = out.subarray(0, out_i);\n    }\n    return out;\n};\n\nconst luaO_hexavalue = function(c) {\n    if (lisdigit(c)) return c - 48;\n    else return (c & 0xdf) - 55;\n};\n\nconst UTF8BUFFSZ = 8;\n\nconst luaO_utf8esc = function(buff, x) {\n    let n = 1;  /* number of bytes put in buffer (backwards) */\n    lua_assert(x <= 0x10FFFF);\n    if (x < 0x80)  /* ascii? */\n        buff[UTF8BUFFSZ - 1] = x;\n    else {  /* need continuation bytes */\n        let mfb = 0x3f;  /* maximum that fits in first byte */\n        do {\n            buff[UTF8BUFFSZ - (n++)] = 0x80 | (x & 0x3f);\n            x >>= 6;  /* remove added bits */\n            mfb >>= 1;  /* now there is one less bit available in first byte */\n        } while (x > mfb);  /* still needs continuation byte? */\n        buff[UTF8BUFFSZ - n] = (~mfb << 1) | x;  /* add first byte */\n    }\n    return n;\n};\n\n/* maximum number of significant digits to read (to avoid overflows\n   even with single floats) */\nconst MAXSIGDIG = 30;\n\n/*\n** convert an hexadecimal numeric string to a number, following\n** C99 specification for 'strtod'\n*/\nconst lua_strx2number = function(s) {\n    let i = 0;\n    let r = 0.0;  /* result (accumulator) */\n    let sigdig = 0;  /* number of significant digits */\n    let nosigdig = 0;  /* number of non-significant digits */\n    let e = 0;  /* exponent correction */\n    let neg;  /* 1 if number is negative */\n    let hasdot = false;  /* true after seen a dot */\n    while (lisspace(s[i])) i++;  /* skip initial spaces */\n    if ((neg = (s[i] === 45 /* ('-').charCodeAt(0) */))) i++;  /* check signal */\n    else if (s[i] === 43 /* ('+').charCodeAt(0) */) i++;\n    if (!(s[i] === 48 /* ('0').charCodeAt(0) */ && (s[i+1] === 120 /* ('x').charCodeAt(0) */ || s[i+1] === 88 /* ('X').charCodeAt(0) */)))  /* check '0x' */\n        return null;  /* invalid format (no '0x') */\n    for (i += 2; ; i++) {  /* skip '0x' and read numeral */\n        if (s[i] === 46 /* ('.').charCodeAt(0) i.e. dot/lua_getlocaledecpoint(); */) {\n            if (hasdot) break;  /* second dot? stop loop */\n            else hasdot = true;\n        } else if (lisxdigit(s[i])) {\n            if (sigdig === 0 && s[i] === 48 /* ('0').charCodeAt(0) */)  /* non-significant digit (zero)? */\n                nosigdig++;\n            else if (++sigdig <= MAXSIGDIG)  /* can read it without overflow? */\n                r = (r * 16) + luaO_hexavalue(s[i]);\n            else e++; /* too many digits; ignore, but still count for exponent */\n            if (hasdot) e--;  /* decimal digit? correct exponent */\n        } else break;  /* neither a dot nor a digit */\n    }\n\n    if (nosigdig + sigdig === 0)  /* no digits? */\n        return null;  /* invalid format */\n    e *= 4;  /* each digit multiplies/divides value by 2^4 */\n    if (s[i] === 112 /* ('p').charCodeAt(0) */ || s[i] === 80 /* ('P').charCodeAt(0) */) {  /* exponent part? */\n        let exp1 = 0;  /* exponent value */\n        let neg1;  /* exponent signal */\n        i++;  /* skip 'p' */\n        if ((neg1 = (s[i] === 45 /* ('-').charCodeAt(0) */))) i++;  /* signal */\n        else if (s[i] === 43 /* ('+').charCodeAt(0) */) i++;\n        if (!lisdigit(s[i]))\n            return null;  /* invalid; must have at least one digit */\n        while (lisdigit(s[i]))  /* read exponent */\n            exp1 = exp1 * 10 + s[i++] - 48 /* ('0').charCodeAt(0) */;\n        if (neg1) exp1 = -exp1;\n        e += exp1;\n    }\n    if (neg) r = -r;\n    return {\n        n: ldexp(r, e),\n        i: i\n    };\n};\n\nconst lua_str2number = function(s) {\n    try {\n        s = to_jsstring(s);\n    } catch (e) {\n        return null;\n    }\n    /* use a regex to validate number and also to get length\n       parseFloat ignores trailing junk */\n    let r = /^[\\t\\v\\f \\n\\r]*[+-]?(?:[0-9]+\\.?[0-9]*|\\.[0-9]*)(?:[eE][+-]?[0-9]+)?/.exec(s);\n    if (!r)\n        return null;\n    let flt = parseFloat(r[0]);\n    return !isNaN(flt) ? { n: flt, i: r[0].length } : null;\n};\n\nconst l_str2dloc = function(s, mode) {\n    let result = mode === 'x' ? lua_strx2number(s) : lua_str2number(s); /* try to convert */\n    if (result === null) return null;\n    while (lisspace(s[result.i])) result.i++;  /* skip trailing spaces */\n    return (result.i === s.length || s[result.i] === 0) ? result : null;  /* OK if no trailing characters */\n};\n\nconst SIGILS = [\n    46  /* (\".\").charCodeAt(0) */,\n    120 /* (\"x\").charCodeAt(0) */,\n    88  /* (\"X\").charCodeAt(0) */,\n    110 /* (\"n\").charCodeAt(0) */,\n    78  /* (\"N\").charCodeAt(0) */\n];\nconst modes = {\n    [ 46]: \".\",\n    [120]: \"x\",\n    [ 88]: \"x\",\n    [110]: \"n\",\n    [ 78]: \"n\"\n};\nconst l_str2d = function(s) {\n    let l = s.length;\n    let pmode = 0;\n    for (let i=0; i<l; i++) {\n        let v = s[i];\n        if (SIGILS.indexOf(v) !== -1) {\n            pmode = v;\n            break;\n        }\n    }\n    let mode = modes[pmode];\n    if (mode === 'n')  /* reject 'inf' and 'nan' */\n        return null;\n    let end = l_str2dloc(s, mode);  /* try to convert */\n    // if (end === null) {   /* failed? may be a different locale */\n    //     throw new Error(\"Locale not available to handle number\"); // TODO\n    // }\n    return end;\n};\n\nconst MAXBY10  = Math.floor(MAX_INT / 10);\nconst MAXLASTD = MAX_INT % 10;\n\nconst l_str2int = function(s) {\n    let i = 0;\n    let a = 0;\n    let empty = true;\n    let neg;\n\n    while (lisspace(s[i])) i++;  /* skip initial spaces */\n    if ((neg = (s[i] === 45 /* ('-').charCodeAt(0) */))) i++;\n    else if (s[i] === 43 /* ('+').charCodeAt(0) */) i++;\n    if (s[i] === 48 /* ('0').charCodeAt(0) */ && (s[i+1] === 120 /* ('x').charCodeAt(0) */ || s[i+1] === 88 /* ('X').charCodeAt(0) */)) {  /* hex? */\n        i += 2;  /* skip '0x' */\n        for (; i < s.length && lisxdigit(s[i]); i++) {\n            a = (a * 16 + luaO_hexavalue(s[i]))|0;\n            empty = false;\n        }\n    } else {  /* decimal */\n        for (; i < s.length && lisdigit(s[i]); i++) {\n            let d = s[i] - 48 /* ('0').charCodeAt(0) */;\n            if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  /* overflow? */\n                return null;  /* do not accept it (as integer) */\n            a = (a * 10 + d)|0;\n            empty = false;\n        }\n    }\n    while (i < s.length && lisspace(s[i])) i++;  /* skip trailing spaces */\n    if (empty || (i !== s.length && s[i] !== 0)) return null;  /* something wrong in the numeral */\n    else {\n        return {\n            n: (neg ? -a : a)|0,\n            i: i\n        };\n    }\n};\n\nconst luaO_str2num = function(s, o) {\n    let s2i = l_str2int(s);\n    if (s2i !== null) {   /* try as an integer */\n        o.setivalue(s2i.n);\n        return s2i.i+1;\n    } else {   /* else try as a float */\n        s2i = l_str2d(s);\n        if (s2i !== null) {\n            o.setfltvalue(s2i.n);\n            return s2i.i+1;\n        } else\n            return 0;  /* conversion failed */\n    }\n};\n\nconst luaO_tostring = function(L, obj) {\n    let buff;\n    if (obj.ttisinteger())\n        buff = to_luastring(lua_integer2str(obj.value));\n    else {\n        let str = lua_number2str(obj.value);\n        if (!LUA_COMPAT_FLOATSTRING && /^[-0123456789]+$/.test(str)) {  /* looks like an int? */\n            str += '.0'; /* adds '.0' to result: lua_getlocaledecpoint removed as optimisation */\n        }\n        buff = to_luastring(str);\n    }\n    obj.setsvalue(luaS_bless(L, buff));\n};\n\nconst pushstr = function(L, str) {\n    ldo.luaD_inctop(L);\n    setsvalue2s(L, L.top-1, luaS_new(L, str));\n};\n\nconst luaO_pushvfstring = function(L, fmt, argp) {\n    let n = 0;\n    let i = 0;\n    let a = 0;\n    let e;\n    for (;;) {\n        e = luastring_indexOf(fmt, 37 /* ('%').charCodeAt(0) */, i);\n        if (e == -1) break;\n        pushstr(L, fmt.subarray(i, e));\n        switch(fmt[e+1]) {\n            case 115 /* ('s').charCodeAt(0) */: {\n                let s = argp[a++];\n                if (s === null) s = to_luastring(\"(null)\", true);\n                else {\n                    s = from_userstring(s);\n                    /* respect null terminator */\n                    let i = luastring_indexOf(s, 0);\n                    if (i !== -1)\n                        s = s.subarray(0, i);\n                }\n                pushstr(L, s);\n                break;\n            }\n            case 99 /* ('c').charCodeAt(0) */: {\n                let buff = argp[a++];\n                if (lisprint(buff))\n                    pushstr(L, luastring_of(buff));\n                else\n                    luaO_pushfstring(L, to_luastring(\"<\\\\%d>\", true), buff);\n                break;\n            }\n            case 100 /* ('d').charCodeAt(0) */:\n            case 73 /* ('I').charCodeAt(0) */:\n                ldo.luaD_inctop(L);\n                L.stack[L.top-1].setivalue(argp[a++]);\n                luaO_tostring(L, L.stack[L.top-1]);\n                break;\n            case 102 /* ('f').charCodeAt(0) */:\n                ldo.luaD_inctop(L);\n                L.stack[L.top-1].setfltvalue(argp[a++]);\n                luaO_tostring(L, L.stack[L.top-1]);\n                break;\n            case 112 /* ('p').charCodeAt(0) */: {\n                let v = argp[a++];\n                if (v instanceof lstate.lua_State ||\n                    v instanceof ltable.Table ||\n                    v instanceof Udata ||\n                    v instanceof LClosure ||\n                    v instanceof CClosure) {\n                    pushstr(L, to_luastring(\"0x\"+v.id.toString(16)));\n                } else {\n                    switch(typeof v) {\n                        case \"undefined\":\n                            pushstr(L, to_luastring(\"undefined\"));\n                            break;\n                        case \"number\":  /* before check object as null is an object */\n                            pushstr(L, to_luastring(\"Number(\"+v+\")\"));\n                            break;\n                        case \"string\":  /* before check object as null is an object */\n                            pushstr(L, to_luastring(\"String(\"+JSON.stringify(v)+\")\"));\n                            break;\n                        case \"boolean\":  /* before check object as null is an object */\n                            pushstr(L, to_luastring(v?\"Boolean(true)\":\"Boolean(false)\"));\n                            break;\n                        case \"object\":\n                            if (v === null) { /* null is special */\n                                pushstr(L, to_luastring(\"null\"));\n                                break;\n                            }\n                            /* fall through */\n                        case \"function\": {\n                            let id = L.l_G.ids.get(v);\n                            if (!id) {\n                                id = L.l_G.id_counter++;\n                                L.l_G.ids.set(v, id);\n                            }\n                            pushstr(L, to_luastring(\"0x\"+id.toString(16)));\n                            break;\n                        }\n                        default:\n                            /* user provided object. no id available */\n                            pushstr(L, to_luastring(\"<id NYI>\"));\n                    }\n                }\n                break;\n            }\n            case 85 /* ('U').charCodeAt(0) */: {\n                let buff = new Uint8Array(UTF8BUFFSZ);\n                let l = luaO_utf8esc(buff, argp[a++]);\n                pushstr(L, buff.subarray(UTF8BUFFSZ - l));\n                break;\n            }\n            case 37 /* ('%').charCodeAt(0) */:\n                pushstr(L, to_luastring(\"%\", true));\n                break;\n            default:\n                ldebug.luaG_runerror(L, to_luastring(\"invalid option '%%%c' to 'lua_pushfstring'\"), fmt[e + 1]);\n        }\n        n += 2;\n        i = e + 2;\n    }\n    ldo.luaD_checkstack(L, 1);\n    pushstr(L, fmt.subarray(i));\n    if (n > 0) lvm.luaV_concat(L, n+1);\n    return L.stack[L.top-1].svalue();\n};\n\nconst luaO_pushfstring = function(L, fmt, ...argp) {\n    return luaO_pushvfstring(L, fmt, argp);\n};\n\n\n/*\n** converts an integer to a \"floating point byte\", represented as\n** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if\n** eeeee !== 0 and (xxx) otherwise.\n*/\nconst luaO_int2fb = function(x) {\n    let e = 0;  /* exponent */\n    if (x < 8) return x;\n    while (x >= (8 << 4)) {  /* coarse steps */\n        x = (x + 0xf) >> 4;  /* x = ceil(x / 16) */\n        e += 4;\n    }\n    while (x >= (8 << 1)) {  /* fine steps */\n        x = (x + 1) >> 1;  /* x = ceil(x / 2) */\n        e++;\n    }\n    return ((e+1) << 3) | (x - 8);\n};\n\nconst intarith = function(L, op, v1, v2) {\n    switch (op) {\n        case LUA_OPADD:  return (v1 + v2)|0;\n        case LUA_OPSUB:  return (v1 - v2)|0;\n        case LUA_OPMUL:  return lvm.luaV_imul(v1, v2);\n        case LUA_OPMOD:  return lvm.luaV_mod(L, v1, v2);\n        case LUA_OPIDIV: return lvm.luaV_div(L, v1, v2);\n        case LUA_OPBAND: return (v1 & v2);\n        case LUA_OPBOR:  return (v1 | v2);\n        case LUA_OPBXOR: return (v1 ^ v2);\n        case LUA_OPSHL:  return lvm.luaV_shiftl(v1, v2);\n        case LUA_OPSHR:  return lvm.luaV_shiftl(v1, -v2);\n        case LUA_OPUNM:  return (0 - v1)|0;\n        case LUA_OPBNOT: return (~0 ^ v1);\n        default: lua_assert(0);\n    }\n};\n\n\nconst numarith = function(L, op, v1, v2) {\n    switch (op) {\n        case LUA_OPADD:  return v1 + v2;\n        case LUA_OPSUB:  return v1 - v2;\n        case LUA_OPMUL:  return v1 * v2;\n        case LUA_OPDIV:  return v1 / v2;\n        case LUA_OPPOW:  return Math.pow(v1, v2);\n        case LUA_OPIDIV: return Math.floor(v1 / v2);\n        case LUA_OPUNM:  return -v1;\n        case LUA_OPMOD:  return luai_nummod(L, v1, v2);\n        default: lua_assert(0);\n    }\n};\n\nconst luaO_arith = function(L, op, p1, p2, p3) {\n    let res = (typeof p3 === \"number\") ? L.stack[p3] : p3;  /* FIXME */\n\n    switch (op) {\n        case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:\n        case LUA_OPSHL: case LUA_OPSHR:\n        case LUA_OPBNOT: {  /* operate only on integers */\n            let i1, i2;\n            if ((i1 = lvm.tointeger(p1)) !== false && (i2 = lvm.tointeger(p2)) !== false) {\n                res.setivalue(intarith(L, op, i1, i2));\n                return;\n            }\n            else break;  /* go to the end */\n        }\n        case LUA_OPDIV: case LUA_OPPOW: {  /* operate only on floats */\n            let n1, n2;\n            if ((n1 = lvm.tonumber(p1)) !== false && (n2 = lvm.tonumber(p2)) !== false) {\n                res.setfltvalue(numarith(L, op, n1, n2));\n                return;\n            }\n            else break;  /* go to the end */\n        }\n        default: {  /* other operations */\n            let n1, n2;\n            if (p1.ttisinteger() && p2.ttisinteger()) {\n                res.setivalue(intarith(L, op, p1.value, p2.value));\n                return;\n            }\n            else if ((n1 = lvm.tonumber(p1)) !== false && (n2 = lvm.tonumber(p2)) !== false) {\n                res.setfltvalue(numarith(L, op, n1, n2));\n                return;\n            }\n            else break;  /* go to the end */\n        }\n    }\n    /* could not perform raw operation; try metamethod */\n    lua_assert(L !== null);  /* should not fail when folding (compile time) */\n    ltm.luaT_trybinTM(L, p1, p2, p3, (op - LUA_OPADD) + ltm.TMS.TM_ADD);\n};\n\n\nmodule.exports.CClosure          = CClosure;\nmodule.exports.LClosure          = LClosure;\nmodule.exports.LUA_TDEADKEY      = LUA_TDEADKEY;\nmodule.exports.LUA_TPROTO        = LUA_TPROTO;\nmodule.exports.LocVar            = LocVar;\nmodule.exports.TValue            = TValue;\nmodule.exports.Udata             = Udata;\nmodule.exports.UTF8BUFFSZ        = UTF8BUFFSZ;\nmodule.exports.luaO_arith        = luaO_arith;\nmodule.exports.luaO_chunkid      = luaO_chunkid;\nmodule.exports.luaO_hexavalue    = luaO_hexavalue;\nmodule.exports.luaO_int2fb       = luaO_int2fb;\nmodule.exports.luaO_pushfstring  = luaO_pushfstring;\nmodule.exports.luaO_pushvfstring = luaO_pushvfstring;\nmodule.exports.luaO_str2num      = luaO_str2num;\nmodule.exports.luaO_tostring     = luaO_tostring;\nmodule.exports.luaO_utf8esc      = luaO_utf8esc;\nmodule.exports.numarith          = numarith;\nmodule.exports.pushobj2s         = pushobj2s;\nmodule.exports.pushsvalue2s      = pushsvalue2s;\nmodule.exports.setobjs2s         = setobjs2s;\nmodule.exports.setobj2s          = setobj2s;\nmodule.exports.setsvalue2s       = setsvalue2s;\n","\"use strict\";\n\nconst {\n    LUAL_BUFFERSIZE\n} = require('./luaconf.js');\nconst {\n    LUA_ERRERR,\n    LUA_MULTRET,\n    LUA_REGISTRYINDEX,\n    LUA_SIGNATURE,\n    LUA_TBOOLEAN,\n    LUA_TLIGHTUSERDATA,\n    LUA_TNIL,\n    LUA_TNONE,\n    LUA_TNUMBER,\n    LUA_TSTRING,\n    LUA_TTABLE,\n    LUA_VERSION_NUM,\n    lua_Debug,\n    lua_absindex,\n    lua_atpanic,\n    lua_call,\n    lua_checkstack,\n    lua_concat,\n    lua_copy,\n    lua_createtable,\n    lua_error,\n    lua_getfield,\n    lua_getinfo,\n    lua_getmetatable,\n    lua_getstack,\n    lua_gettop,\n    lua_insert,\n    lua_isinteger,\n    lua_isnil,\n    lua_isnumber,\n    lua_isstring,\n    lua_istable,\n    lua_len,\n    lua_load,\n    lua_newstate,\n    lua_newtable,\n    lua_next,\n    lua_pcall,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushcclosure,\n    lua_pushcfunction,\n    lua_pushfstring,\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_pushlstring,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_pushvfstring,\n    lua_rawequal,\n    lua_rawget,\n    lua_rawgeti,\n    lua_rawlen,\n    lua_rawseti,\n    lua_remove,\n    lua_setfield,\n    lua_setglobal,\n    lua_setmetatable,\n    lua_settop,\n    lua_toboolean,\n    lua_tointeger,\n    lua_tointegerx,\n    lua_tojsstring,\n    lua_tolstring,\n    lua_tonumber,\n    lua_tonumberx,\n    lua_topointer,\n    lua_tostring,\n    lua_touserdata,\n    lua_type,\n    lua_typename,\n    lua_version\n} = require('./lua.js');\nconst {\n    from_userstring,\n    luastring_eq,\n    to_luastring,\n    to_uristring\n} = require(\"./fengaricore.js\");\n\n/* extra error code for 'luaL_loadfilex' */\nconst LUA_ERRFILE = LUA_ERRERR+1;\n\n/* key, in the registry, for table of loaded modules */\nconst LUA_LOADED_TABLE = to_luastring(\"_LOADED\");\n\n/* key, in the registry, for table of preloaded loaders */\nconst LUA_PRELOAD_TABLE = to_luastring(\"_PRELOAD\");\n\nconst LUA_FILEHANDLE = to_luastring(\"FILE*\");\n\nconst LUAL_NUMSIZES  = 4*16 + 8;\n\nconst __name = to_luastring(\"__name\");\nconst __tostring = to_luastring(\"__tostring\");\n\nconst empty = new Uint8Array(0);\n\nclass luaL_Buffer {\n    constructor() {\n        this.L = null;\n        this.b = empty;\n        this.n = 0;\n    }\n}\n\nconst LEVELS1 = 10;  /* size of the first part of the stack */\nconst LEVELS2 = 11;  /* size of the second part of the stack */\n\n/*\n** search for 'objidx' in table at index -1.\n** return 1 + string at top if find a good name.\n*/\nconst findfield = function(L, objidx, level) {\n    if (level === 0 || !lua_istable(L, -1))\n        return 0;  /* not found */\n\n    lua_pushnil(L);  /* start 'next' loop */\n\n    while (lua_next(L, -2)) {  /* for each pair in table */\n        if (lua_type(L, -2) === LUA_TSTRING) {  /* ignore non-string keys */\n            if (lua_rawequal(L, objidx, -1)) {  /* found object? */\n                lua_pop(L, 1);  /* remove value (but keep name) */\n                return 1;\n            } else if (findfield(L, objidx, level - 1)) {  /* try recursively */\n                lua_remove(L, -2);  /* remove table (but keep name) */\n                lua_pushliteral(L, \".\");\n                lua_insert(L, -2);  /* place '.' between the two names */\n                lua_concat(L, 3);\n                return 1;\n            }\n        }\n        lua_pop(L, 1);  /* remove value */\n    }\n\n    return 0;  /* not found */\n};\n\n/*\n** Search for a name for a function in all loaded modules\n*/\nconst pushglobalfuncname = function(L, ar) {\n    let top = lua_gettop(L);\n    lua_getinfo(L, to_luastring(\"f\"), ar);  /* push function */\n    lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n    if (findfield(L, top + 1, 2)) {\n        let name = lua_tostring(L, -1);\n        if (name[0] === 95 /* '_'.charCodeAt(0) */ &&\n            name[1] === 71 /* 'G'.charCodeAt(0) */ &&\n            name[2] === 46 /* '.'.charCodeAt(0) */\n        ) {  /* name start with '_G.'? */\n            lua_pushstring(L, name.subarray(3));  /* push name without prefix */\n            lua_remove(L, -2);  /* remove original name */\n        }\n        lua_copy(L, -1, top + 1);  /* move name to proper place */\n        lua_pop(L, 2);  /* remove pushed values */\n        return 1;\n    } else {\n        lua_settop(L, top);  /* remove function and global table */\n        return 0;\n    }\n};\n\nconst pushfuncname = function(L, ar) {\n    if (pushglobalfuncname(L, ar)) {  /* try first a global name */\n        lua_pushfstring(L, to_luastring(\"function '%s'\"), lua_tostring(L, -1));\n        lua_remove(L, -2);  /* remove name */\n    }\n    else if (ar.namewhat.length !== 0)  /* is there a name from code? */\n        lua_pushfstring(L, to_luastring(\"%s '%s'\"), ar.namewhat, ar.name);  /* use it */\n    else if (ar.what && ar.what[0] === 109 /* 'm'.charCodeAt(0) */)  /* main? */\n        lua_pushliteral(L, \"main chunk\");\n    else if (ar.what && ar.what[0] === 76 /* 'L'.charCodeAt(0) */)  /* for Lua functions, use <file:line> */\n        lua_pushfstring(L, to_luastring(\"function <%s:%d>\"), ar.short_src, ar.linedefined);\n    else  /* nothing left... */\n        lua_pushliteral(L, \"?\");\n};\n\nconst lastlevel = function(L) {\n    let ar = new lua_Debug();\n    let li = 1;\n    let le = 1;\n    /* find an upper bound */\n    while (lua_getstack(L, le, ar)) { li = le; le *= 2; }\n    /* do a binary search */\n    while (li < le) {\n        let m = Math.floor((li + le)/2);\n        if (lua_getstack(L, m, ar)) li = m + 1;\n        else le = m;\n    }\n    return le - 1;\n};\n\nconst luaL_traceback = function(L, L1, msg, level) {\n    let ar = new lua_Debug();\n    let top = lua_gettop(L);\n    let last = lastlevel(L1);\n    let n1 = last - level > LEVELS1 + LEVELS2 ? LEVELS1 : -1;\n    if (msg)\n        lua_pushfstring(L, to_luastring(\"%s\\n\"), msg);\n    luaL_checkstack(L, 10, null);\n    lua_pushliteral(L, \"stack traceback:\");\n    while (lua_getstack(L1, level++, ar)) {\n        if (n1-- === 0) {  /* too many levels? */\n            lua_pushliteral(L, \"\\n\\t...\");  /* add a '...' */\n            level = last - LEVELS2 + 1;  /* and skip to last ones */\n        } else {\n            lua_getinfo(L1, to_luastring(\"Slnt\", true), ar);\n            lua_pushfstring(L, to_luastring(\"\\n\\t%s:\"), ar.short_src);\n            if (ar.currentline > 0)\n                lua_pushliteral(L, `${ar.currentline}:`);\n            lua_pushliteral(L, \" in \");\n            pushfuncname(L, ar);\n            if (ar.istailcall)\n                lua_pushliteral(L, \"\\n\\t(...tail calls..)\");\n            lua_concat(L, lua_gettop(L) - top);\n        }\n    }\n    lua_concat(L, lua_gettop(L) - top);\n};\n\nconst panic = function(L) {\n    let msg = \"PANIC: unprotected error in call to Lua API (\" + lua_tojsstring(L, -1) + \")\";\n    throw new Error(msg);\n};\n\nconst luaL_argerror = function(L, arg, extramsg) {\n    let ar = new lua_Debug();\n\n    if (!lua_getstack(L, 0, ar))  /* no stack frame? */\n        return luaL_error(L, to_luastring(\"bad argument #%d (%s)\"), arg, extramsg);\n\n    lua_getinfo(L, to_luastring(\"n\"), ar);\n\n    if (luastring_eq(ar.namewhat, to_luastring(\"method\"))) {\n        arg--;  /* do not count 'self' */\n        if (arg === 0)  /* error is in the self argument itself? */\n            return luaL_error(L, to_luastring(\"calling '%s' on bad self (%s)\"), ar.name, extramsg);\n    }\n\n    if (ar.name === null)\n        ar.name = pushglobalfuncname(L, ar) ? lua_tostring(L, -1) : to_luastring(\"?\");\n\n    return luaL_error(L, to_luastring(\"bad argument #%d to '%s' (%s)\"), arg, ar.name, extramsg);\n};\n\nconst typeerror = function(L, arg, tname) {\n    let typearg;\n    if (luaL_getmetafield(L, arg, __name) === LUA_TSTRING)\n        typearg = lua_tostring(L, -1);\n    else if (lua_type(L, arg) === LUA_TLIGHTUSERDATA)\n        typearg = to_luastring(\"light userdata\", true);\n    else\n        typearg = luaL_typename(L, arg);\n\n    let msg = lua_pushfstring(L, to_luastring(\"%s expected, got %s\"), tname, typearg);\n    return luaL_argerror(L, arg, msg);\n};\n\nconst luaL_where = function(L, level) {\n    let ar = new lua_Debug();\n    if (lua_getstack(L, level, ar)) {\n        lua_getinfo(L, to_luastring(\"Sl\", true), ar);\n        if (ar.currentline > 0) {\n            lua_pushfstring(L, to_luastring(\"%s:%d: \"), ar.short_src, ar.currentline);\n            return;\n        }\n    }\n    lua_pushstring(L, to_luastring(\"\"));\n};\n\nconst luaL_error = function(L, fmt, ...argp) {\n    luaL_where(L, 1);\n    lua_pushvfstring(L, fmt, argp);\n    lua_concat(L, 2);\n    return lua_error(L);\n};\n\n/* Unlike normal lua, we pass in an error object */\nconst luaL_fileresult = function(L, stat, fname, e) {\n    if (stat) {\n        lua_pushboolean(L, 1);\n        return 1;\n    } else {\n        lua_pushnil(L);\n        let message, errno;\n        if (e) {\n            message = e.message;\n            errno = -e.errno;\n        } else {\n            message = \"Success\"; /* what strerror(0) returns */\n            errno = 0;\n        }\n        if (fname)\n            lua_pushfstring(L, to_luastring(\"%s: %s\"), fname, to_luastring(message));\n        else\n            lua_pushstring(L, to_luastring(message));\n        lua_pushinteger(L, errno);\n        return 3;\n    }\n};\n\n/* Unlike normal lua, we pass in an error object */\nconst luaL_execresult = function(L, e) {\n    let what, stat;\n    if (e === null) {\n        lua_pushboolean(L, 1);\n        lua_pushliteral(L, \"exit\");\n        lua_pushinteger(L, 0);\n        return 3;\n    } else if (e.status) {\n        what = \"exit\";\n        stat = e.status;\n    } else if (e.signal) {\n        what = \"signal\";\n        stat = e.signal;\n    } else {\n        /* XXX: node seems to have e.errno as a string instead of a number */\n        return luaL_fileresult(L, 0, null, e);\n    }\n    lua_pushnil(L);\n    lua_pushliteral(L, what);\n    lua_pushinteger(L, stat);\n    return 3;\n};\n\nconst luaL_getmetatable = function(L, n) {\n    return lua_getfield(L, LUA_REGISTRYINDEX, n);\n};\n\nconst luaL_newmetatable = function(L, tname) {\n    if (luaL_getmetatable(L, tname) !== LUA_TNIL)  /* name already in use? */\n        return 0;  /* leave previous value on top, but return 0 */\n    lua_pop(L, 1);\n    lua_createtable(L, 0, 2);  /* create metatable */\n    lua_pushstring(L, tname);\n    lua_setfield(L, -2, __name);  /* metatable.__name = tname */\n    lua_pushvalue(L, -1);\n    lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */\n    return 1;\n\n};\n\nconst luaL_setmetatable = function(L, tname) {\n    luaL_getmetatable(L, tname);\n    lua_setmetatable(L, -2);\n};\n\nconst luaL_testudata = function(L, ud, tname) {\n    let p = lua_touserdata(L, ud);\n    if (p !== null) {  /* value is a userdata? */\n        if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */\n            luaL_getmetatable(L, tname);  /* get correct metatable */\n            if (!lua_rawequal(L, -1, -2))  /* not the same? */\n                p = null;  /* value is a userdata with wrong metatable */\n            lua_pop(L, 2);  /* remove both metatables */\n            return p;\n        }\n    }\n    return null;  /* value is not a userdata with a metatable */\n};\n\nconst luaL_checkudata = function(L, ud, tname) {\n    let p = luaL_testudata(L, ud, tname);\n    if (p === null) typeerror(L, ud, tname);\n    return p;\n};\n\nconst luaL_checkoption = function(L, arg, def, lst) {\n    let name = def !== null ? luaL_optstring(L, arg, def) : luaL_checkstring(L, arg);\n    for (let i = 0; lst[i]; i++)\n        if (luastring_eq(lst[i], name))\n            return i;\n    return luaL_argerror(L, arg, lua_pushfstring(L, to_luastring(\"invalid option '%s'\"), name));\n};\n\nconst tag_error = function(L, arg, tag) {\n    typeerror(L, arg, lua_typename(L, tag));\n};\n\nconst luaL_newstate = function() {\n    let L = lua_newstate();\n    if (L) lua_atpanic(L, panic);\n    return L;\n};\n\n\nconst luaL_typename = function(L, i) {\n    return lua_typename(L, lua_type(L, i));\n};\n\nconst luaL_argcheck = function(L, cond, arg, extramsg) {\n    if (!cond) luaL_argerror(L, arg, extramsg);\n};\n\nconst luaL_checkany = function(L, arg) {\n    if (lua_type(L, arg) === LUA_TNONE)\n        luaL_argerror(L, arg, to_luastring(\"value expected\", true));\n};\n\nconst luaL_checktype = function(L, arg, t) {\n    if (lua_type(L, arg) !== t)\n        tag_error(L, arg, t);\n};\n\nconst luaL_checklstring = function(L, arg) {\n    let s = lua_tolstring(L, arg);\n    if (s === null || s === undefined) tag_error(L, arg, LUA_TSTRING);\n    return s;\n};\n\nconst luaL_checkstring = luaL_checklstring;\n\nconst luaL_optlstring = function(L, arg, def) {\n    if (lua_type(L, arg) <= 0) {\n        return def === null ? null : from_userstring(def);\n    } else return luaL_checklstring(L, arg);\n};\n\nconst luaL_optstring = luaL_optlstring;\n\nconst interror = function(L, arg) {\n    if (lua_isnumber(L, arg))\n        luaL_argerror(L, arg, to_luastring(\"number has no integer representation\", true));\n    else\n        tag_error(L, arg, LUA_TNUMBER);\n};\n\nconst luaL_checknumber = function(L, arg) {\n    let d = lua_tonumberx(L, arg);\n    if (d === false)\n        tag_error(L, arg, LUA_TNUMBER);\n    return d;\n};\n\nconst luaL_optnumber = function(L, arg, def) {\n    return luaL_opt(L, luaL_checknumber, arg, def);\n};\n\nconst luaL_checkinteger = function(L, arg) {\n    let d = lua_tointegerx(L, arg);\n    if (d === false)\n        interror(L, arg);\n    return d;\n};\n\nconst luaL_optinteger = function(L, arg, def) {\n    return luaL_opt(L, luaL_checkinteger, arg, def);\n};\n\nconst luaL_prepbuffsize = function(B, sz) {\n    let newend = B.n + sz;\n    if (B.b.length < newend) {\n        let newsize = Math.max(B.b.length * 2, newend);  /* double buffer size */\n        let newbuff = new Uint8Array(newsize);  /* create larger buffer */\n        newbuff.set(B.b);  /* copy original content */\n        B.b = newbuff;\n    }\n    return B.b.subarray(B.n, newend);\n};\n\nconst luaL_buffinit = function(L, B) {\n    B.L = L;\n    B.b = empty;\n};\n\nconst luaL_buffinitsize = function(L, B, sz) {\n    luaL_buffinit(L, B);\n    return luaL_prepbuffsize(B, sz);\n};\n\nconst luaL_prepbuffer = function(B) {\n    return luaL_prepbuffsize(B, LUAL_BUFFERSIZE);\n};\n\nconst luaL_addlstring = function(B, s, l) {\n    if (l > 0) {\n        s = from_userstring(s);\n        let b = luaL_prepbuffsize(B, l);\n        b.set(s.subarray(0, l));\n        luaL_addsize(B, l);\n    }\n};\n\nconst luaL_addstring = function(B, s) {\n    s = from_userstring(s);\n    luaL_addlstring(B, s, s.length);\n};\n\nconst luaL_pushresult = function(B) {\n    lua_pushlstring(B.L, B.b, B.n);\n    /* delete old buffer */\n    B.n = 0;\n    B.b = empty;\n};\n\nconst luaL_addchar = function(B, c) {\n    luaL_prepbuffsize(B, 1);\n    B.b[B.n++] = c;\n};\n\nconst luaL_addsize = function(B, s) {\n    B.n += s;\n};\n\nconst luaL_pushresultsize = function(B, sz) {\n    luaL_addsize(B, sz);\n    luaL_pushresult(B);\n};\n\nconst luaL_addvalue = function(B) {\n    let L = B.L;\n    let s = lua_tostring(L, -1);\n    luaL_addlstring(B, s, s.length);\n    lua_pop(L, 1);  /* remove value */\n};\n\nconst luaL_opt = function(L, f, n, d) {\n    return lua_type(L, n) <= 0 ? d : f(L, n);\n};\n\nconst getS = function(L, ud) {\n    let s = ud.string;\n    ud.string = null;\n    return s;\n};\n\nconst luaL_loadbufferx = function(L, buff, size, name, mode) {\n    return lua_load(L, getS, {string: buff}, name, mode);\n};\n\nconst luaL_loadbuffer = function(L, s, sz, n) {\n    return luaL_loadbufferx(L, s, sz, n, null);\n};\n\nconst luaL_loadstring = function(L, s) {\n    return luaL_loadbuffer(L, s, s.length, s);\n};\n\nconst luaL_dostring = function(L, s) {\n    return (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0));\n};\n\nconst luaL_getmetafield = function(L, obj, event) {\n    if (!lua_getmetatable(L, obj))  /* no metatable? */\n        return LUA_TNIL;\n    else {\n        lua_pushstring(L, event);\n        let tt = lua_rawget(L, -2);\n        if (tt === LUA_TNIL)  /* is metafield nil? */\n            lua_pop(L, 2);  /* remove metatable and metafield */\n        else\n            lua_remove(L, -2);  /* remove only metatable */\n        return tt;  /* return metafield type */\n    }\n};\n\nconst luaL_callmeta = function(L, obj, event) {\n    obj = lua_absindex(L, obj);\n    if (luaL_getmetafield(L, obj, event) === LUA_TNIL)\n        return false;\n\n    lua_pushvalue(L, obj);\n    lua_call(L, 1, 1);\n\n    return true;\n};\n\nconst luaL_len = function(L, idx) {\n    lua_len(L, idx);\n    let l = lua_tointegerx(L, -1);\n    if (l === false)\n        luaL_error(L, to_luastring(\"object length is not an integer\", true));\n    lua_pop(L, 1);  /* remove object */\n    return l;\n};\n\nconst p_I = to_luastring(\"%I\");\nconst p_f = to_luastring(\"%f\");\nconst luaL_tolstring = function(L, idx) {\n    if (luaL_callmeta(L, idx, __tostring)) {\n        if (!lua_isstring(L, -1))\n            luaL_error(L, to_luastring(\"'__tostring' must return a string\"));\n    } else {\n        let t = lua_type(L, idx);\n        switch(t) {\n            case LUA_TNUMBER: {\n                if (lua_isinteger(L, idx))\n                    lua_pushfstring(L, p_I, lua_tointeger(L, idx));\n                else\n                    lua_pushfstring(L, p_f, lua_tonumber(L, idx));\n                break;\n            }\n            case LUA_TSTRING:\n                lua_pushvalue(L, idx);\n                break;\n            case LUA_TBOOLEAN:\n                lua_pushliteral(L, (lua_toboolean(L, idx) ? \"true\" : \"false\"));\n                break;\n            case LUA_TNIL:\n                lua_pushliteral(L, \"nil\");\n                break;\n            default: {\n                let tt = luaL_getmetafield(L, idx, __name);\n                let kind = tt === LUA_TSTRING ? lua_tostring(L, -1) : luaL_typename(L, idx);\n                lua_pushfstring(L, to_luastring(\"%s: %p\"), kind, lua_topointer(L, idx));\n                if (tt !== LUA_TNIL)\n                    lua_remove(L, -2);\n                break;\n            }\n        }\n    }\n\n    return lua_tolstring(L, -1);\n};\n\n/*\n** Stripped-down 'require': After checking \"loaded\" table, calls 'openf'\n** to open a module, registers the result in 'package.loaded' table and,\n** if 'glb' is true, also registers the result in the global table.\n** Leaves resulting module on the top.\n*/\nconst luaL_requiref = function(L, modname, openf, glb) {\n    luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n    lua_getfield(L, -1, modname); /* LOADED[modname] */\n    if (!lua_toboolean(L, -1)) {  /* package not already loaded? */\n        lua_pop(L, 1);  /* remove field */\n        lua_pushcfunction(L, openf);\n        lua_pushstring(L, modname);  /* argument to open function */\n        lua_call(L, 1, 1);  /* call 'openf' to open module */\n        lua_pushvalue(L, -1);  /* make copy of module (call result) */\n        lua_setfield(L, -3, modname);  /* LOADED[modname] = module */\n    }\n    lua_remove(L, -2);  /* remove LOADED table */\n    if (glb) {\n        lua_pushvalue(L, -1);  /* copy of module */\n        lua_setglobal(L, modname);  /* _G[modname] = module */\n    }\n};\n\nconst find_subarray = function(arr, subarr, from_index) {\n    var i = from_index >>> 0,\n        sl = subarr.length,\n        l = arr.length + 1 - sl;\n\n    loop: for (; i < l; i++) {\n        for (let j = 0; j < sl; j++)\n            if (arr[i+j] !== subarr[j])\n                continue loop;\n        return i;\n    }\n    return -1;\n};\n\nconst luaL_gsub = function(L, s, p, r) {\n    let wild;\n    let b = new luaL_Buffer();\n    luaL_buffinit(L, b);\n    while ((wild = find_subarray(s, p)) >= 0) {\n        luaL_addlstring(b, s, wild);  /* push prefix */\n        luaL_addstring(b, r);  /* push replacement in place of pattern */\n        s = s.subarray(wild + p.length);  /* continue after 'p' */\n    }\n    luaL_addstring(b, s);  /* push last suffix */\n    luaL_pushresult(b);\n    return lua_tostring(L, -1);\n};\n\n/*\n** ensure that stack[idx][fname] has a table and push that table\n** into the stack\n*/\nconst luaL_getsubtable = function(L, idx, fname) {\n    if (lua_getfield(L, idx, fname) === LUA_TTABLE)\n        return true;  /* table already there */\n    else {\n        lua_pop(L, 1);  /* remove previous result */\n        idx = lua_absindex(L, idx);\n        lua_newtable(L);\n        lua_pushvalue(L, -1);  /* copy to be left at top */\n        lua_setfield(L, idx, fname);  /* assign new table to field */\n        return false;  /* false, because did not find table there */\n    }\n};\n\n/*\n** set functions from list 'l' into table at top - 'nup'; each\n** function gets the 'nup' elements at the top as upvalues.\n** Returns with only the table at the stack.\n*/\nconst luaL_setfuncs = function(L, l, nup) {\n    luaL_checkstack(L, nup, to_luastring(\"too many upvalues\", true));\n    for (let lib in l) {  /* fill the table with given functions */\n        for (let i = 0; i < nup; i++)  /* copy upvalues to the top */\n            lua_pushvalue(L, -nup);\n        lua_pushcclosure(L, l[lib], nup);  /* closure with those upvalues */\n        lua_setfield(L, -(nup + 2), to_luastring(lib));\n    }\n    lua_pop(L, nup);  /* remove upvalues */\n};\n\n/*\n** Ensures the stack has at least 'space' extra slots, raising an error\n** if it cannot fulfill the request. (The error handling needs a few\n** extra slots to format the error message. In case of an error without\n** this extra space, Lua will generate the same 'stack overflow' error,\n** but without 'msg'.)\n*/\nconst luaL_checkstack = function(L, space, msg) {\n    if (!lua_checkstack(L, space)) {\n        if (msg)\n            luaL_error(L, to_luastring(\"stack overflow (%s)\"), msg);\n        else\n            luaL_error(L, to_luastring('stack overflow', true));\n    }\n};\n\nconst luaL_newlibtable = function(L) {\n    lua_createtable(L);\n};\n\nconst luaL_newlib = function(L, l) {\n    lua_createtable(L);\n    luaL_setfuncs(L, l, 0);\n};\n\n/* predefined references */\nconst LUA_NOREF  = -2;\nconst LUA_REFNIL = -1;\n\nconst luaL_ref = function(L, t) {\n    let ref;\n    if (lua_isnil(L, -1)) {\n        lua_pop(L, 1);  /* remove from stack */\n        return LUA_REFNIL;  /* 'nil' has a unique fixed reference */\n    }\n    t = lua_absindex(L, t);\n    lua_rawgeti(L, t, 0);  /* get first free element */\n    ref = lua_tointeger(L, -1);  /* ref = t[freelist] */\n    lua_pop(L, 1);  /* remove it from stack */\n    if (ref !== 0) {  /* any free element? */\n        lua_rawgeti(L, t, ref);  /* remove it from list */\n        lua_rawseti(L, t, 0);  /* (t[freelist] = t[ref]) */\n    }\n    else  /* no free elements */\n        ref = lua_rawlen(L, t) + 1;  /* get a new reference */\n    lua_rawseti(L, t, ref);\n    return ref;\n};\n\n\nconst luaL_unref = function(L, t, ref) {\n    if (ref >= 0) {\n        t = lua_absindex(L, t);\n        lua_rawgeti(L, t, 0);\n        lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */\n        lua_pushinteger(L, ref);\n        lua_rawseti(L, t, 0);  /* t[freelist] = ref */\n    }\n};\n\n\nconst errfile = function(L, what, fnameindex, error) {\n    let serr = error.message;\n    let filename = lua_tostring(L, fnameindex).subarray(1);\n    lua_pushfstring(L, to_luastring(\"cannot %s %s: %s\"), to_luastring(what), filename, to_luastring(serr));\n    lua_remove(L, fnameindex);\n    return LUA_ERRFILE;\n};\n\nlet getc;\n\nconst utf8_bom = [0XEF, 0XBB, 0XBF];  /* UTF-8 BOM mark */\nconst skipBOM = function(lf) {\n    lf.n = 0;\n    let c;\n    let p = 0;\n    do {\n        c = getc(lf);\n        if (c === null || c !== utf8_bom[p]) return c;\n        p++;\n        lf.buff[lf.n++] = c;  /* to be read by the parser */\n    } while (p < utf8_bom.length);\n    lf.n = 0;  /* prefix matched; discard it */\n    return getc(lf);  /* return next character */\n};\n\n/*\n** reads the first character of file 'f' and skips an optional BOM mark\n** in its beginning plus its first line if it starts with '#'. Returns\n** true if it skipped the first line.  In any case, '*cp' has the\n** first \"valid\" character of the file (after the optional BOM and\n** a first-line comment).\n*/\nconst skipcomment = function(lf) {\n    let c = skipBOM(lf);\n    if (c === 35 /* '#'.charCodeAt(0) */) {  /* first line is a comment (Unix exec. file)? */\n        do {  /* skip first line */\n            c = getc(lf);\n        } while (c && c !== 10 /* '\\n'.charCodeAt(0) */);\n\n        return {\n            skipped: true,\n            c: getc(lf)  /* skip end-of-line, if present */\n        };\n    } else {\n        return {\n            skipped: false,\n            c: c\n        };\n    }\n};\n\nlet luaL_loadfilex;\n\nif (typeof process === \"undefined\") {\n    class LoadF {\n        constructor() {\n            this.n = NaN;  /* number of pre-read characters */\n            this.f = null;  /* file being read */\n            this.buff = new Uint8Array(1024);  /* area for reading file */\n            this.pos = 0;  /* current position in file */\n            this.err = void 0;\n        }\n    }\n\n    const getF = function(L, ud) {\n        let lf = ud;\n\n        if (lf.f !== null && lf.n > 0) {  /* are there pre-read characters to be read? */\n            let bytes = lf.n; /* return them (chars already in buffer) */\n            lf.n = 0;  /* no more pre-read characters */\n            lf.f = lf.f.subarray(lf.pos);  /* we won't use lf.buff anymore */\n            return lf.buff.subarray(0, bytes);\n        }\n\n        let f = lf.f;\n        lf.f = null;\n        return f;\n    };\n\n    getc = function(lf) {\n        return lf.pos < lf.f.length ? lf.f[lf.pos++] : null;\n    };\n\n    luaL_loadfilex = function(L, filename, mode) {\n        let lf = new LoadF();\n        let fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */\n        if (filename === null) {\n            throw new Error(\"Can't read stdin in the browser\");\n        } else {\n            lua_pushfstring(L, to_luastring(\"@%s\"), filename);\n            let path = to_uristring(filename);\n            let xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", path, false);\n            /*\n            Synchronous xhr in main thread always returns a js string.\n            Some browsers make console noise if you even attempt to set responseType\n            */\n            if (typeof window === \"undefined\") {\n                xhr.responseType = \"arraybuffer\";\n            }\n            xhr.send();\n            if (xhr.status >= 200 && xhr.status <= 299) {\n                if (typeof xhr.response === \"string\") {\n                    lf.f = to_luastring(xhr.response);\n                } else {\n                    lf.f = new Uint8Array(xhr.response);\n                }\n            } else {\n                lf.err = xhr.status;\n                return errfile(L, \"open\", fnameindex, { message: `${xhr.status}: ${xhr.statusText}` });\n            }\n        }\n        let com = skipcomment(lf);\n        /* check for signature first, as we don't want to add line number corrections in binary case */\n        if (com.c === LUA_SIGNATURE[0] && filename) {  /* binary file? */\n            /* no need to re-open */\n        } else if (com.skipped) { /* read initial portion */\n            lf.buff[lf.n++] = 10 /* '\\n'.charCodeAt(0) */;  /* add line to correct line numbers */\n        }\n        if (com.c !== null)\n            lf.buff[lf.n++] = com.c; /* 'c' is the first character of the stream */\n        let status = lua_load(L, getF, lf, lua_tostring(L, -1), mode);\n        let readstatus = lf.err;\n        if (readstatus) {\n            lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */\n            return errfile(L, \"read\", fnameindex, readstatus);\n        }\n        lua_remove(L, fnameindex);\n        return status;\n    };\n} else {\n    const fs = require('fs');\n\n    class LoadF {\n        constructor() {\n            this.n = NaN;  /* number of pre-read characters */\n            this.f = null;  /* file being read */\n            this.buff = Buffer.alloc(1024);  /* area for reading file */\n            this.pos = 0;  /* current position in file */\n            this.err = void 0;\n        }\n    }\n\n    const getF = function(L, ud) {\n        let lf = ud;\n        let bytes = 0;\n        if (lf.n > 0) {  /* are there pre-read characters to be read? */\n            bytes = lf.n; /* return them (chars already in buffer) */\n            lf.n = 0;  /* no more pre-read characters */\n        } else {  /* read a block from file */\n            try {\n                bytes = fs.readSync(lf.f, lf.buff, 0, lf.buff.length, lf.pos); /* read block */\n            } catch(e) {\n                lf.err = e;\n                bytes = 0;\n            }\n            lf.pos += bytes;\n        }\n        if (bytes > 0)\n            return lf.buff.subarray(0, bytes);\n        else return null;\n    };\n\n    getc = function(lf) {\n        let b = Buffer.alloc(1);\n        let bytes;\n        try {\n            bytes = fs.readSync(lf.f, b, 0, 1, lf.pos);\n        } catch(e) {\n            lf.err = e;\n            return null;\n        }\n        lf.pos += bytes;\n        return bytes > 0 ? b.readUInt8() : null;\n    };\n\n    luaL_loadfilex = function(L, filename, mode) {\n        let lf = new LoadF();\n        let fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */\n        if (filename === null) {\n            lua_pushliteral(L, \"=stdin\");\n            lf.f = process.stdin.fd;\n        } else {\n            lua_pushfstring(L, to_luastring(\"@%s\"), filename);\n            try {\n                lf.f = fs.openSync(filename, \"r\");\n            } catch (e) {\n                return errfile(L, \"open\", fnameindex, e);\n            }\n        }\n        let com = skipcomment(lf);\n        /* check for signature first, as we don't want to add line number corrections in binary case */\n        if (com.c === LUA_SIGNATURE[0] && filename) {  /* binary file? */\n            /* no need to re-open */\n        } else if (com.skipped) { /* read initial portion */\n            lf.buff[lf.n++] = 10 /* '\\n'.charCodeAt(0) */;  /* add line to correct line numbers */\n        }\n        if (com.c !== null)\n            lf.buff[lf.n++] = com.c; /* 'c' is the first character of the stream */\n        let status = lua_load(L, getF, lf, lua_tostring(L, -1), mode);\n        let readstatus = lf.err;\n        if (filename) try { fs.closeSync(lf.f); } catch(e) {}  /* close file (even in case of errors) */\n        if (readstatus) {\n            lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */\n            return errfile(L, \"read\", fnameindex, readstatus);\n        }\n        lua_remove(L, fnameindex);\n        return status;\n    };\n}\n\nconst luaL_loadfile = function(L, filename) {\n    return luaL_loadfilex(L, filename, null);\n};\n\nconst luaL_dofile = function(L, filename) {\n    return (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0));\n};\n\nconst lua_writestringerror = function() {\n    for (let i=0; i<arguments.length; i++) {\n        let a = arguments[i];\n        if (typeof process === \"undefined\") {\n            /* split along new lines for separate console.error invocations */\n            do {\n                /* regexp uses [\\d\\D] to work around matching new lines\n                   the 's' flag is non-standard */\n                let r = /([^\\n]*)\\n?([\\d\\D]*)/.exec(a);\n                console.error(r[1]);\n                a = r[2];\n            } while (a !== \"\");\n        } else {\n            process.stderr.write(a);\n        }\n    }\n};\n\nconst luaL_checkversion_ = function(L, ver, sz) {\n    let v = lua_version(L);\n    if (sz != LUAL_NUMSIZES)  /* check numeric types */\n        luaL_error(L, to_luastring(\"core and library have incompatible numeric types\"));\n    if (v != lua_version(null))\n        luaL_error(L, to_luastring(\"multiple Lua VMs detected\"));\n    else if (v !== ver)\n        luaL_error(L, to_luastring(\"version mismatch: app. needs %f, Lua core provides %f\"), ver, v);\n};\n\n/* There is no point in providing this function... */\nconst luaL_checkversion = function(L) {\n    luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES);\n};\n\nmodule.exports.LUA_ERRFILE          = LUA_ERRFILE;\nmodule.exports.LUA_FILEHANDLE       = LUA_FILEHANDLE;\nmodule.exports.LUA_LOADED_TABLE     = LUA_LOADED_TABLE;\nmodule.exports.LUA_NOREF            = LUA_NOREF;\nmodule.exports.LUA_PRELOAD_TABLE    = LUA_PRELOAD_TABLE;\nmodule.exports.LUA_REFNIL           = LUA_REFNIL;\nmodule.exports.luaL_Buffer          = luaL_Buffer;\nmodule.exports.luaL_addchar         = luaL_addchar;\nmodule.exports.luaL_addlstring      = luaL_addlstring;\nmodule.exports.luaL_addsize         = luaL_addsize;\nmodule.exports.luaL_addstring       = luaL_addstring;\nmodule.exports.luaL_addvalue        = luaL_addvalue;\nmodule.exports.luaL_argcheck        = luaL_argcheck;\nmodule.exports.luaL_argerror        = luaL_argerror;\nmodule.exports.luaL_buffinit        = luaL_buffinit;\nmodule.exports.luaL_buffinitsize    = luaL_buffinitsize;\nmodule.exports.luaL_callmeta        = luaL_callmeta;\nmodule.exports.luaL_checkany        = luaL_checkany;\nmodule.exports.luaL_checkinteger    = luaL_checkinteger;\nmodule.exports.luaL_checklstring    = luaL_checklstring;\nmodule.exports.luaL_checknumber     = luaL_checknumber;\nmodule.exports.luaL_checkoption     = luaL_checkoption;\nmodule.exports.luaL_checkstack      = luaL_checkstack;\nmodule.exports.luaL_checkstring     = luaL_checkstring;\nmodule.exports.luaL_checktype       = luaL_checktype;\nmodule.exports.luaL_checkudata      = luaL_checkudata;\nmodule.exports.luaL_checkversion    = luaL_checkversion;\nmodule.exports.luaL_checkversion_   = luaL_checkversion_;\nmodule.exports.luaL_dofile          = luaL_dofile;\nmodule.exports.luaL_dostring        = luaL_dostring;\nmodule.exports.luaL_error           = luaL_error;\nmodule.exports.luaL_execresult      = luaL_execresult;\nmodule.exports.luaL_fileresult      = luaL_fileresult;\nmodule.exports.luaL_getmetafield    = luaL_getmetafield;\nmodule.exports.luaL_getmetatable    = luaL_getmetatable;\nmodule.exports.luaL_getsubtable     = luaL_getsubtable;\nmodule.exports.luaL_gsub            = luaL_gsub;\nmodule.exports.luaL_len             = luaL_len;\nmodule.exports.luaL_loadbuffer      = luaL_loadbuffer;\nmodule.exports.luaL_loadbufferx     = luaL_loadbufferx;\nmodule.exports.luaL_loadfile        = luaL_loadfile;\nmodule.exports.luaL_loadfilex       = luaL_loadfilex;\nmodule.exports.luaL_loadstring      = luaL_loadstring;\nmodule.exports.luaL_newlib          = luaL_newlib;\nmodule.exports.luaL_newlibtable     = luaL_newlibtable;\nmodule.exports.luaL_newmetatable    = luaL_newmetatable;\nmodule.exports.luaL_newstate        = luaL_newstate;\nmodule.exports.luaL_opt             = luaL_opt;\nmodule.exports.luaL_optinteger      = luaL_optinteger;\nmodule.exports.luaL_optlstring      = luaL_optlstring;\nmodule.exports.luaL_optnumber       = luaL_optnumber;\nmodule.exports.luaL_optstring       = luaL_optstring;\nmodule.exports.luaL_prepbuffer      = luaL_prepbuffer;\nmodule.exports.luaL_prepbuffsize    = luaL_prepbuffsize;\nmodule.exports.luaL_pushresult      = luaL_pushresult;\nmodule.exports.luaL_pushresultsize  = luaL_pushresultsize;\nmodule.exports.luaL_ref             = luaL_ref;\nmodule.exports.luaL_requiref        = luaL_requiref;\nmodule.exports.luaL_setfuncs        = luaL_setfuncs;\nmodule.exports.luaL_setmetatable    = luaL_setmetatable;\nmodule.exports.luaL_testudata       = luaL_testudata;\nmodule.exports.luaL_tolstring       = luaL_tolstring;\nmodule.exports.luaL_traceback       = luaL_traceback;\nmodule.exports.luaL_typename        = luaL_typename;\nmodule.exports.luaL_unref           = luaL_unref;\nmodule.exports.luaL_where           = luaL_where;\nmodule.exports.lua_writestringerror = lua_writestringerror;\n","\"use strict\";\n\nconst {\n    LUA_HOOKCALL,\n    LUA_HOOKRET,\n    LUA_HOOKTAILCALL,\n    LUA_MASKCALL,\n    LUA_MASKLINE,\n    LUA_MASKRET,\n    LUA_MINSTACK,\n    LUA_MULTRET,\n    LUA_SIGNATURE,\n    constant_types: {\n        LUA_TCCL,\n        LUA_TLCF,\n        LUA_TLCL,\n        LUA_TNIL\n    },\n    thread_status: {\n        LUA_ERRMEM,\n        LUA_ERRERR,\n        LUA_ERRRUN,\n        LUA_ERRSYNTAX,\n        LUA_OK,\n        LUA_YIELD\n    },\n    lua_Debug,\n    luastring_indexOf,\n    to_luastring\n} = require('./defs.js');\nconst lapi     = require('./lapi.js');\nconst ldebug   = require('./ldebug.js');\nconst lfunc    = require('./lfunc.js');\nconst {\n    api_check,\n    lua_assert,\n    LUAI_MAXCCALLS\n} = require('./llimits.js');\nconst lobject  = require('./lobject.js');\nconst lopcodes = require('./lopcodes.js');\nconst lparser  = require('./lparser.js');\nconst lstate   = require('./lstate.js');\nconst { luaS_newliteral } = require('./lstring.js');\nconst ltm      = require('./ltm.js');\nconst { LUAI_MAXSTACK } = require('./luaconf.js');\nconst lundump  = require('./lundump.js');\nconst lvm      = require('./lvm.js');\nconst { MBuffer } = require('./lzio.js');\n\nconst adjust_top = function(L, newtop) {\n    if (L.top < newtop) {\n        while (L.top < newtop)\n            L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);\n    } else {\n        while (L.top > newtop)\n            delete L.stack[--L.top];\n    }\n};\n\nconst seterrorobj = function(L, errcode, oldtop) {\n    let current_top = L.top;\n\n    /* extend stack so that L.stack[oldtop] is sure to exist */\n    while (L.top < oldtop + 1)\n        L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);\n\n    switch (errcode) {\n        case LUA_ERRMEM: {\n            lobject.setsvalue2s(L, oldtop, luaS_newliteral(L, \"not enough memory\"));\n            break;\n        }\n        case LUA_ERRERR: {\n            lobject.setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n            break;\n        }\n        default: {\n            lobject.setobjs2s(L, oldtop, current_top - 1);\n        }\n    }\n\n    while (L.top > oldtop + 1)\n        delete L.stack[--L.top];\n};\n\nconst ERRORSTACKSIZE = LUAI_MAXSTACK + 200;\n\nconst luaD_reallocstack = function(L, newsize) {\n    lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);\n    lua_assert(L.stack_last == L.stack.length - lstate.EXTRA_STACK);\n    L.stack.length = newsize;\n    L.stack_last = newsize - lstate.EXTRA_STACK;\n};\n\nconst luaD_growstack = function(L, n) {\n    let size = L.stack.length;\n    if (size > LUAI_MAXSTACK)\n        luaD_throw(L, LUA_ERRERR);\n    else {\n        let needed = L.top + n + lstate.EXTRA_STACK;\n        let newsize = 2 * size;\n        if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;\n        if (newsize < needed) newsize = needed;\n        if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */\n            luaD_reallocstack(L, ERRORSTACKSIZE);\n            ldebug.luaG_runerror(L, to_luastring(\"stack overflow\", true));\n        }\n        else\n            luaD_reallocstack(L, newsize);\n    }\n};\n\nconst luaD_checkstack = function(L, n) {\n    if (L.stack_last - L.top <= n)\n        luaD_growstack(L, n);\n};\n\nconst stackinuse = function(L) {\n    let lim = L.top;\n    for (let ci = L.ci; ci !== null; ci = ci.previous) {\n        if (lim < ci.top) lim = ci.top;\n    }\n    lua_assert(lim <= L.stack_last);\n    return lim + 1; /* part of stack in use */\n};\n\nconst luaD_shrinkstack = function(L) {\n    let inuse = stackinuse(L);\n    let goodsize = inuse + Math.floor(inuse / 8) + 2*lstate.EXTRA_STACK;\n    if (goodsize > LUAI_MAXSTACK)\n        goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n    if (L.stack.length > LUAI_MAXSTACK)  /* had been handling stack overflow? */\n        lstate.luaE_freeCI(L);  /* free all CIs (list grew because of an error) */\n    /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n    if (inuse <= (LUAI_MAXSTACK - lstate.EXTRA_STACK) && goodsize < L.stack.length)\n        luaD_reallocstack(L, goodsize);\n};\n\nconst luaD_inctop = function(L) {\n    luaD_checkstack(L, 1);\n    L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);\n};\n\n/*\n** Prepares a function call: checks the stack, creates a new CallInfo\n** entry, fills in the relevant information, calls hook if needed.\n** If function is a JS function, does the call, too. (Otherwise, leave\n** the execution ('luaV_execute') to the caller, to allow stackless\n** calls.) Returns true iff function has been executed (JS function).\n*/\nconst luaD_precall = function(L, off, nresults) {\n    let func = L.stack[off];\n\n    switch(func.type) {\n        case LUA_TCCL:\n        case LUA_TLCF: {\n            let f = func.type === LUA_TCCL ? func.value.f : func.value;\n\n            luaD_checkstack(L, LUA_MINSTACK);\n            let ci = lstate.luaE_extendCI(L);\n            ci.funcOff = off;\n            ci.nresults = nresults;\n            ci.func = func;\n            ci.top = L.top + LUA_MINSTACK;\n            lua_assert(ci.top <= L.stack_last);\n            ci.callstatus = 0;\n            if (L.hookmask & LUA_MASKCALL)\n                luaD_hook(L, LUA_HOOKCALL, -1);\n            let n = f(L); /* do the actual call */\n            if (typeof n !== \"number\" || n < 0 || (n|0) !== n)\n                throw Error(\"invalid return value from JS function (expected integer)\");\n            lapi.api_checknelems(L, n);\n\n            luaD_poscall(L, ci, L.top - n, n);\n\n            return true;\n        }\n        case LUA_TLCL: {\n            let base;\n            let p = func.value.p;\n            let n = L.top - off - 1;\n            let fsize = p.maxstacksize;\n            luaD_checkstack(L, fsize);\n            if (p.is_vararg) {\n                base = adjust_varargs(L, p, n);\n            } else {\n                for (; n < p.numparams; n++)\n                    L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null); // complete missing arguments\n                base = off + 1;\n            }\n\n            let ci = lstate.luaE_extendCI(L);\n            ci.funcOff = off;\n            ci.nresults = nresults;\n            ci.func = func;\n            ci.l_base = base;\n            ci.top = base + fsize;\n            adjust_top(L, ci.top);\n            ci.l_code = p.code;\n            ci.l_savedpc = 0;\n            ci.callstatus = lstate.CIST_LUA;\n            if (L.hookmask & LUA_MASKCALL)\n                callhook(L, ci);\n            return false;\n        }\n        default:\n            luaD_checkstack(L, 1);\n            tryfuncTM(L, off, func);\n            return luaD_precall(L, off, nresults);\n    }\n};\n\nconst luaD_poscall = function(L, ci, firstResult, nres) {\n    let wanted = ci.nresults;\n\n    if (L.hookmask & (LUA_MASKRET | LUA_MASKLINE)) {\n        if (L.hookmask & LUA_MASKRET)\n            luaD_hook(L, LUA_HOOKRET, -1);\n        L.oldpc = ci.previous.l_savedpc;  /* 'oldpc' for caller function */\n    }\n\n    let res = ci.funcOff;\n    L.ci = ci.previous;\n    L.ci.next = null;\n    return moveresults(L, firstResult, res, nres, wanted);\n};\n\nconst moveresults = function(L, firstResult, res, nres, wanted) {\n    switch (wanted) {\n        case 0:\n            break;\n        case 1: {\n            if (nres === 0)\n                L.stack[res].setnilvalue();\n            else {\n                lobject.setobjs2s(L, res, firstResult); /* move it to proper place */\n            }\n            break;\n        }\n        case LUA_MULTRET: {\n            for (let i = 0; i < nres; i++)\n                lobject.setobjs2s(L, res + i, firstResult + i);\n            for (let i=L.top; i>=(res + nres); i--)\n                delete L.stack[i];\n            L.top = res + nres;\n            return false;\n        }\n        default: {\n            let i;\n            if (wanted <= nres) {\n                for (i = 0; i < wanted; i++)\n                    lobject.setobjs2s(L, res + i, firstResult + i);\n            } else {\n                for (i = 0; i < nres; i++)\n                    lobject.setobjs2s(L, res + i, firstResult + i);\n                for (; i < wanted; i++) {\n                    if (res+i >= L.top)\n                        L.stack[res + i] = new lobject.TValue(LUA_TNIL, null);\n                    else\n                        L.stack[res + i].setnilvalue();\n                }\n            }\n            break;\n        }\n    }\n    let newtop = res + wanted; /* top points after the last result */\n    for (let i=L.top; i>=newtop; i--)\n        delete L.stack[i];\n    L.top = newtop;\n    return true;\n};\n\n/*\n** Call a hook for the given event. Make sure there is a hook to be\n** called. (Both 'L->hook' and 'L->hookmask', which triggers this\n** function, can be changed asynchronously by signals.)\n*/\nconst luaD_hook = function(L, event, line) {\n    let hook = L.hook;\n    if (hook && L.allowhook) {  /* make sure there is a hook */\n        let ci = L.ci;\n        let top = L.top;\n        let ci_top = ci.top;\n        let ar = new lua_Debug();\n        ar.event = event;\n        ar.currentline = line;\n        ar.i_ci = ci;\n        luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n        ci.top = L.top + LUA_MINSTACK;\n        lua_assert(ci.top <= L.stack_last);\n        L.allowhook = 0;  /* cannot call hooks inside a hook */\n        ci.callstatus |= lstate.CIST_HOOKED;\n        hook(L, ar);\n        lua_assert(!L.allowhook);\n        L.allowhook = 1;\n        ci.top = ci_top;\n        adjust_top(L, top);\n        ci.callstatus &= ~lstate.CIST_HOOKED;\n    }\n};\n\nconst callhook = function(L, ci) {\n    let hook = LUA_HOOKCALL;\n    ci.l_savedpc++;  /* hooks assume 'pc' is already incremented */\n    if ((ci.previous.callstatus & lstate.CIST_LUA) &&\n      ci.previous.l_code[ci.previous.l_savedpc - 1].opcode == lopcodes.OpCodesI.OP_TAILCALL) {\n        ci.callstatus |= lstate.CIST_TAIL;\n        hook = LUA_HOOKTAILCALL;\n    }\n    luaD_hook(L, hook, -1);\n    ci.l_savedpc--;  /* correct 'pc' */\n};\n\nconst adjust_varargs = function(L, p, actual) {\n    let nfixargs = p.numparams;\n    /* move fixed parameters to final position */\n    let fixed = L.top - actual; /* first fixed argument */\n    let base = L.top; /* final position of first argument */\n\n    let i;\n    for (i = 0; i < nfixargs && i < actual; i++) {\n        lobject.pushobj2s(L, L.stack[fixed + i]);\n        L.stack[fixed + i].setnilvalue();\n    }\n\n    for (; i < nfixargs; i++)\n        L.stack[L.top++] = new lobject.TValue(LUA_TNIL, null);\n\n    return base;\n};\n\nconst tryfuncTM = function(L, off, func) {\n    let tm = ltm.luaT_gettmbyobj(L, func, ltm.TMS.TM_CALL);\n    if (!tm.ttisfunction(tm))\n        ldebug.luaG_typeerror(L, func, to_luastring(\"call\", true));\n    /* Open a hole inside the stack at 'func' */\n    lobject.pushobj2s(L, L.stack[L.top-1]); /* push top of stack again */\n    for (let p = L.top-2; p > off; p--)\n        lobject.setobjs2s(L, p, p-1); /* move other items up one */\n    lobject.setobj2s(L, off, tm); /* tag method is the new function to be called */\n};\n\n/*\n** Check appropriate error for stack overflow (\"regular\" overflow or\n** overflow while handling stack overflow). If 'nCalls' is larger than\n** LUAI_MAXCCALLS (which means it is handling a \"regular\" overflow) but\n** smaller than 9/8 of LUAI_MAXCCALLS, does not report an error (to\n** allow overflow handling to work)\n*/\nconst stackerror = function(L) {\n    if (L.nCcalls === LUAI_MAXCCALLS)\n        ldebug.luaG_runerror(L, to_luastring(\"JS stack overflow\", true));\n    else if (L.nCcalls >= LUAI_MAXCCALLS + (LUAI_MAXCCALLS >> 3))\n        luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */\n};\n\n/*\n** Call a function (JS or Lua). The function to be called is at func.\n** The arguments are on the stack, right after the function.\n** When returns, all the results are on the stack, starting at the original\n** function position.\n*/\nconst luaD_call = function(L, off, nResults) {\n    if (++L.nCcalls >= LUAI_MAXCCALLS)\n        stackerror(L);\n    if (!luaD_precall(L, off, nResults))\n        lvm.luaV_execute(L);\n    L.nCcalls--;\n};\n\nconst luaD_throw = function(L, errcode) {\n    if (L.errorJmp) {  /* thread has an error handler? */\n        L.errorJmp.status = errcode;  /* set status */\n        throw L.errorJmp;\n    } else {  /* thread has no error handler */\n        let g = L.l_G;\n        L.status = errcode;  /* mark it as dead */\n        if (g.mainthread.errorJmp) {  /* main thread has a handler? */\n            g.mainthread.stack[g.mainthread.top++] = L.stack[L.top - 1];  /* copy error obj. */\n            luaD_throw(g.mainthread, errcode);  /* re-throw in main thread */\n        } else {  /* no handler at all; abort */\n            let panic = g.panic;\n            if (panic) {  /* panic function? */\n                seterrorobj(L, errcode, L.top);  /* assume EXTRA_STACK */\n                if (L.ci.top < L.top)\n                    L.ci.top = L.top;  /* pushing msg. can break this invariant */\n                panic(L);  /* call panic function (last chance to jump out) */\n            }\n            throw new Error(`Aborted ${errcode}`);\n        }\n    }\n};\n\nconst luaD_rawrunprotected = function(L, f, ud) {\n    let oldnCcalls = L.nCcalls;\n    let lj = {\n        status: LUA_OK,\n        previous: L.errorJmp /* chain new error handler */\n    };\n    L.errorJmp = lj;\n\n    try {\n        f(L, ud);\n    } catch (e) {\n        if (lj.status === LUA_OK) {\n            /* error was not thrown via luaD_throw, i.e. it is a JS error */\n            /* run user error handler (if it exists) */\n            let atnativeerror = L.l_G.atnativeerror;\n            if (atnativeerror) {\n                try {\n                    lj.status = LUA_OK;\n\n                    lapi.lua_pushcfunction(L, atnativeerror);\n                    lapi.lua_pushlightuserdata(L, e);\n                    luaD_callnoyield(L, L.top - 2, 1);\n\n                    /* Now run the message handler (if it exists) */\n                    /* copy of luaG_errormsg without the throw */\n                    if (L.errfunc !== 0) {  /* is there an error handling function? */\n                        let errfunc = L.errfunc;\n                        lobject.pushobj2s(L, L.stack[L.top - 1]); /* move argument */\n                        lobject.setobjs2s(L, L.top - 2, errfunc); /* push function */\n                        luaD_callnoyield(L, L.top - 2, 1);\n                    }\n\n                    lj.status = LUA_ERRRUN;\n                } catch(e2) {\n                    if (lj.status === LUA_OK) {\n                        /* also failed */\n                        lj.status = -1;\n                    }\n                }\n            } else {\n                lj.status = -1;\n            }\n        }\n    }\n\n    L.errorJmp = lj.previous;\n    L.nCcalls = oldnCcalls;\n\n    return lj.status;\n\n};\n\n/*\n** Completes the execution of an interrupted C function, calling its\n** continuation function.\n*/\nconst finishCcall = function(L, status) {\n    let ci = L.ci;\n\n    /* must have a continuation and must be able to call it */\n    lua_assert(ci.c_k !== null && L.nny === 0);\n    /* error status can only happen in a protected call */\n    lua_assert(ci.callstatus & lstate.CIST_YPCALL || status === LUA_YIELD);\n\n    if (ci.callstatus & lstate.CIST_YPCALL) {  /* was inside a pcall? */\n        ci.callstatus &= ~lstate.CIST_YPCALL;  /* continuation is also inside it */\n        L.errfunc = ci.c_old_errfunc;  /* with the same error function */\n    }\n\n    /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already\n       handled */\n    if (ci.nresults === LUA_MULTRET && L.ci.top < L.top) L.ci.top = L.top;\n    let c_k = ci.c_k; /* don't want to call as method */\n    let n = c_k(L, status, ci.c_ctx);  /* call continuation function */\n    lapi.api_checknelems(L, n);\n    luaD_poscall(L, ci, L.top - n, n);  /* finish 'luaD_precall' */\n};\n\n/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop). If the coroutine is\n** recovering from an error, 'ud' points to the error status, which must\n** be passed to the first continuation function (otherwise the default\n** status is LUA_YIELD).\n*/\nconst unroll = function(L, ud) {\n    if (ud !== null)  /* error status? */\n        finishCcall(L, ud);  /* finish 'lua_pcallk' callee */\n\n    while (L.ci !== L.base_ci) {  /* something in the stack */\n        if (!(L.ci.callstatus & lstate.CIST_LUA))  /* C function? */\n            finishCcall(L, LUA_YIELD);  /* complete its execution */\n        else {  /* Lua function */\n            lvm.luaV_finishOp(L);  /* finish interrupted instruction */\n            lvm.luaV_execute(L);  /* execute down to higher C 'boundary' */\n        }\n    }\n};\n\n/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\nconst findpcall = function(L) {\n    for (let ci = L.ci; ci !== null; ci = ci.previous) {  /* search for a pcall */\n        if (ci.callstatus & lstate.CIST_YPCALL)\n            return ci;\n    }\n\n    return null;  /* no pending pcall */\n};\n\n/*\n** Recovers from an error in a coroutine. Finds a recover point (if\n** there is one) and completes the execution of the interrupted\n** 'luaD_pcall'. If there is no recover point, returns zero.\n*/\nconst recover = function(L, status) {\n    let ci = findpcall(L);\n    if (ci === null) return 0;  /* no recovery point */\n    /* \"finish\" luaD_pcall */\n    let oldtop = ci.extra;\n    lfunc.luaF_close(L, oldtop);\n    seterrorobj(L, status, oldtop);\n    L.ci = ci;\n    L.allowhook = ci.callstatus & lstate.CIST_OAH;  /* restore original 'allowhook' */\n    L.nny = 0;  /* should be zero to be yieldable */\n    luaD_shrinkstack(L);\n    L.errfunc = ci.c_old_errfunc;\n    return 1;  /* continue running the coroutine */\n};\n\n/*\n** Signal an error in the call to 'lua_resume', not in the execution\n** of the coroutine itself. (Such errors should not be handled by any\n** coroutine error handler and should not kill the coroutine.)\n*/\nconst resume_error = function(L, msg, narg) {\n    let ts = luaS_newliteral(L, msg);\n    if (narg === 0) {\n        lobject.pushsvalue2s(L, ts);\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    } else {\n        /* remove args from the stack */\n        for (let i=1; i<narg; i++)\n            delete L.stack[--L.top];\n        lobject.setsvalue2s(L, L.top-1, ts);  /* push error message */\n    }\n    return LUA_ERRRUN;\n};\n\n/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\nconst resume = function(L, n) {\n    let firstArg = L.top - n;  /* first argument */\n    let ci = L.ci;\n    if (L.status === LUA_OK) {  /* starting a coroutine? */\n        if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */\n            lvm.luaV_execute(L);  /* call it */\n    } else {  /* resuming from previous yield */\n        lua_assert(L.status === LUA_YIELD);\n        L.status = LUA_OK;  /* mark that it is running (again) */\n        ci.funcOff = ci.extra;\n        ci.func = L.stack[ci.funcOff];\n\n        if (ci.callstatus & lstate.CIST_LUA)  /* yielded inside a hook? */\n            lvm.luaV_execute(L);  /* just continue running Lua code */\n        else {  /* 'common' yield */\n            if (ci.c_k !== null) {  /* does it have a continuation function? */\n                n = ci.c_k(L, LUA_YIELD, ci.c_ctx); /* call continuation */\n                lapi.api_checknelems(L, n);\n                firstArg = L.top - n;  /* yield results come from continuation */\n            }\n\n            luaD_poscall(L, ci, firstArg, n);  /* finish 'luaD_precall' */\n        }\n\n        unroll(L, null);  /* run continuation */\n    }\n};\n\nconst lua_resume = function(L, from, nargs) {\n    let oldnny = L.nny;  /* save \"number of non-yieldable\" calls */\n\n    if (L.status === LUA_OK) {  /* may be starting a coroutine */\n        if (L.ci !== L.base_ci)  /* not in base level? */\n            return resume_error(L, \"cannot resume non-suspended coroutine\", nargs);\n    } else if (L.status !== LUA_YIELD)\n        return resume_error(L, \"cannot resume dead coroutine\", nargs);\n\n    L.nCcalls = from ? from.nCcalls + 1 : 1;\n    if (L.nCcalls >= LUAI_MAXCCALLS)\n        return resume_error(L, \"JS stack overflow\", nargs);\n\n    L.nny = 0;  /* allow yields */\n\n    lapi.api_checknelems(L, L.status === LUA_OK ? nargs + 1: nargs);\n\n    let status = luaD_rawrunprotected(L, resume, nargs);\n    if (status === -1)  /* error calling 'lua_resume'? */\n        status = LUA_ERRRUN;\n    else {  /* continue running after recoverable errors */\n        while (status > LUA_YIELD && recover(L, status)) {\n            /* unroll continuation */\n            status = luaD_rawrunprotected(L, unroll, status);\n        }\n\n        if (status > LUA_YIELD) {  /* unrecoverable error? */\n            L.status = status;  /* mark thread as 'dead' */\n            seterrorobj(L, status, L.top);  /* push error message */\n            L.ci.top = L.top;\n        } else\n            lua_assert(status === L.status);  /* normal end or yield */\n    }\n\n    L.nny = oldnny;  /* restore 'nny' */\n    L.nCcalls--;\n    lua_assert(L.nCcalls === (from ? from.nCcalls : 0));\n    return status;\n};\n\nconst lua_isyieldable = function(L) {\n    return L.nny === 0;\n};\n\nconst lua_yieldk = function(L, nresults, ctx, k) {\n    let ci = L.ci;\n    lapi.api_checknelems(L, nresults);\n\n    if (L.nny > 0) {\n        if (L !== L.l_G.mainthread)\n            ldebug.luaG_runerror(L, to_luastring(\"attempt to yield across a JS-call boundary\", true));\n        else\n            ldebug.luaG_runerror(L, to_luastring(\"attempt to yield from outside a coroutine\", true));\n    }\n\n    L.status = LUA_YIELD;\n    ci.extra = ci.funcOff;  /* save current 'func' */\n    if (ci.callstatus & lstate.CIST_LUA)  /* inside a hook? */\n        api_check(L, k === null, \"hooks cannot continue after yielding\");\n    else {\n        ci.c_k = k;\n        if (k !== null)  /* is there a continuation? */\n            ci.c_ctx = ctx;  /* save context */\n        ci.funcOff = L.top - nresults - 1;  /* protect stack below results */\n        ci.func = L.stack[ci.funcOff];\n        luaD_throw(L, LUA_YIELD);\n    }\n\n    lua_assert(ci.callstatus & lstate.CIST_HOOKED);  /* must be inside a hook */\n    return 0;  /* return to 'luaD_hook' */\n};\n\nconst lua_yield = function(L, n) {\n    lua_yieldk(L, n, 0, null);\n};\n\nconst luaD_pcall = function(L, func, u, old_top, ef) {\n    let old_ci = L.ci;\n    let old_allowhooks = L.allowhook;\n    let old_nny = L.nny;\n    let old_errfunc = L.errfunc;\n    L.errfunc = ef;\n\n    let status = luaD_rawrunprotected(L, func, u);\n\n    if (status !== LUA_OK) {\n        lfunc.luaF_close(L, old_top);\n        seterrorobj(L, status, old_top);\n        L.ci = old_ci;\n        L.allowhook = old_allowhooks;\n        L.nny = old_nny;\n        luaD_shrinkstack(L);\n    }\n\n    L.errfunc = old_errfunc;\n\n    return status;\n};\n\n/*\n** Similar to 'luaD_call', but does not allow yields during the call\n*/\nconst luaD_callnoyield = function(L, off, nResults) {\n    L.nny++;\n    luaD_call(L, off, nResults);\n    L.nny--;\n};\n\n/*\n** Execute a protected parser.\n*/\nclass SParser {\n    constructor(z, name, mode) {  /* data to 'f_parser' */\n        this.z = z;\n        this.buff = new MBuffer();  /* dynamic structure used by the scanner */\n        this.dyd = new lparser.Dyndata();  /* dynamic structures used by the parser */\n        this.mode = mode;\n        this.name = name;\n    }\n}\n\nconst checkmode = function(L, mode, x) {\n    if (mode && luastring_indexOf(mode, x[0]) === -1) {\n        lobject.luaO_pushfstring(L,\n            to_luastring(\"attempt to load a %s chunk (mode is '%s')\"), x, mode);\n        luaD_throw(L, LUA_ERRSYNTAX);\n    }\n};\n\nconst f_parser = function(L, p) {\n    let cl;\n    let c = p.z.zgetc();  /* read first character */\n    if (c === LUA_SIGNATURE[0]) {\n        checkmode(L, p.mode, to_luastring(\"binary\", true));\n        cl = lundump.luaU_undump(L, p.z, p.name);\n    } else {\n        checkmode(L, p.mode, to_luastring(\"text\", true));\n        cl = lparser.luaY_parser(L, p.z, p.buff, p.dyd, p.name, c);\n    }\n\n    lua_assert(cl.nupvalues === cl.p.upvalues.length);\n    lfunc.luaF_initupvals(L, cl);\n};\n\nconst luaD_protectedparser = function(L, z, name, mode) {\n    let p = new SParser(z, name, mode);\n    L.nny++;  /* cannot yield during parsing */\n    let status = luaD_pcall(L, f_parser, p, L.top, L.errfunc);\n    L.nny--;\n    return status;\n};\n\nmodule.exports.adjust_top           = adjust_top;\nmodule.exports.luaD_call            = luaD_call;\nmodule.exports.luaD_callnoyield     = luaD_callnoyield;\nmodule.exports.luaD_checkstack      = luaD_checkstack;\nmodule.exports.luaD_growstack       = luaD_growstack;\nmodule.exports.luaD_hook            = luaD_hook;\nmodule.exports.luaD_inctop          = luaD_inctop;\nmodule.exports.luaD_pcall           = luaD_pcall;\nmodule.exports.luaD_poscall         = luaD_poscall;\nmodule.exports.luaD_precall         = luaD_precall;\nmodule.exports.luaD_protectedparser = luaD_protectedparser;\nmodule.exports.luaD_rawrunprotected = luaD_rawrunprotected;\nmodule.exports.luaD_reallocstack    = luaD_reallocstack;\nmodule.exports.luaD_throw           = luaD_throw;\nmodule.exports.lua_isyieldable      = lua_isyieldable;\nmodule.exports.lua_resume           = lua_resume;\nmodule.exports.lua_yield            = lua_yield;\nmodule.exports.lua_yieldk           = lua_yieldk;\n","\"use strict\";\n\nconst {\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TCCL,\n        LUA_TLCF,\n        LUA_TLCL,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR,\n        LUA_TTABLE,\n        LUA_TTHREAD,\n        LUA_TUSERDATA\n    },\n    to_luastring\n} = require('./defs.js');\nconst { lua_assert } = require('./llimits.js');\nconst ldebug  = require('./ldebug.js');\nconst lobject = require('./lobject.js');\nconst {\n    luaS_hashlongstr,\n    TString\n} = require('./lstring.js');\nconst lstate  = require('./lstate.js');\n\n/* used to prevent conflicts with lightuserdata keys */\nlet lightuserdata_hashes = new WeakMap();\nconst get_lightuserdata_hash = function(v) {\n    let hash = lightuserdata_hashes.get(v);\n    if (!hash) {\n        /* Hash should be something unique that is a valid WeakMap key\n           so that it ends up in dead_weak when removed from a table */\n        hash = {};\n        lightuserdata_hashes.set(v, hash);\n    }\n    return hash;\n};\n\nconst table_hash = function(L, key) {\n    switch(key.type) {\n        case LUA_TNIL:\n            return ldebug.luaG_runerror(L, to_luastring(\"table index is nil\", true));\n        case LUA_TNUMFLT:\n            if (isNaN(key.value))\n                return ldebug.luaG_runerror(L, to_luastring(\"table index is NaN\", true));\n            /* fall through */\n        case LUA_TNUMINT: /* takes advantage of floats and integers being same in JS */\n        case LUA_TBOOLEAN:\n        case LUA_TTABLE:\n        case LUA_TLCL:\n        case LUA_TLCF:\n        case LUA_TCCL:\n        case LUA_TUSERDATA:\n        case LUA_TTHREAD:\n            return key.value;\n        case LUA_TSHRSTR:\n        case LUA_TLNGSTR:\n            return luaS_hashlongstr(key.tsvalue());\n        case LUA_TLIGHTUSERDATA: {\n            let v = key.value;\n            switch(typeof v) {\n                case \"string\":\n                    /* possible conflict with LUA_TSTRING.\n                       prefix this string with \"*\" so they don't clash */\n                    return \"*\" + v;\n                case \"number\":\n                    /* possible conflict with LUA_TNUMBER.\n                       turn into string and prefix with \"#\" to avoid clash with other strings */\n                    return \"#\" + v;\n                case \"boolean\":\n                    /* possible conflict with LUA_TBOOLEAN. use strings ?true and ?false instead */\n                    return v?\"?true\":\"?false\";\n                case \"function\":\n                    /* possible conflict with LUA_TLCF.\n                       indirect via a weakmap */\n                    return get_lightuserdata_hash(v);\n                case \"object\":\n                    /* v could be a lua_State, CClosure, LClosure, Table or Userdata from this state as returned by lua_topointer */\n                    if ((v instanceof lstate.lua_State && v.l_G === L.l_G) ||\n                        v instanceof Table ||\n                        v instanceof lobject.Udata ||\n                        v instanceof lobject.LClosure ||\n                        v instanceof lobject.CClosure) {\n                        /* indirect via a weakmap */\n                        return get_lightuserdata_hash(v);\n                    }\n                    /* fall through */\n                default:\n                    return v;\n            }\n        }\n        default:\n            throw new Error(\"unknown key type: \" + key.type);\n    }\n};\n\nclass Table {\n    constructor(L) {\n        this.id = L.l_G.id_counter++;\n        this.strong = new Map();\n        this.dead_strong = new Map();\n        this.dead_weak = void 0; /* initialised when needed */\n        this.f = void 0; /* first entry */\n        this.l = void 0; /* last entry */\n        this.metatable = null;\n        this.flags = ~0;\n    }\n}\n\nconst invalidateTMcache = function(t) {\n    t.flags = 0;\n};\n\nconst add = function(t, hash, key, value) {\n    t.dead_strong.clear();\n    t.dead_weak = void 0;\n    let prev = null;\n    let entry = {\n        key: key,\n        value: value,\n        p: prev = t.l,\n        n: void 0\n    };\n    if (!t.f) t.f = entry;\n    if (prev) prev.n = entry;\n    t.strong.set(hash, entry);\n    t.l = entry;\n};\n\nconst is_valid_weakmap_key = function(k) {\n    return typeof k === 'object' ? k !== null : typeof k === 'function';\n};\n\n/* Move out of 'strong' part and into 'dead' part. */\nconst mark_dead = function(t, hash) {\n    let e = t.strong.get(hash);\n    if (e) {\n        e.key.setdeadvalue();\n        e.value = void 0;\n        let next = e.n;\n        let prev = e.p;\n        e.p = void 0; /* no need to know previous item any more */\n        if(prev) prev.n = next;\n        if(next) next.p = prev;\n        if(t.f === e) t.f = next;\n        if(t.l === e) t.l = prev;\n        t.strong.delete(hash);\n        if (is_valid_weakmap_key(hash)) {\n            if (!t.dead_weak) t.dead_weak = new WeakMap();\n            t.dead_weak.set(hash, e);\n        } else {\n            /* can't be used as key in weakmap */\n            t.dead_strong.set(hash, e);\n        }\n    }\n};\n\nconst luaH_new = function(L) {\n    return new Table(L);\n};\n\nconst getgeneric = function(t, hash) {\n    let v = t.strong.get(hash);\n    return v ? v.value : lobject.luaO_nilobject;\n};\n\nconst luaH_getint = function(t, key) {\n    lua_assert(typeof key == \"number\" && (key|0) === key);\n    return getgeneric(t, key);\n};\n\nconst luaH_getstr = function(t, key) {\n    lua_assert(key instanceof TString);\n    return getgeneric(t, luaS_hashlongstr(key));\n};\n\nconst luaH_get = function(L, t, key) {\n    lua_assert(key instanceof lobject.TValue);\n    if (key.ttisnil() || (key.ttisfloat() && isNaN(key.value)))\n        return lobject.luaO_nilobject;\n    return getgeneric(t, table_hash(L, key));\n};\n\nconst luaH_setint = function(t, key, value) {\n    lua_assert(typeof key == \"number\" && (key|0) === key && value instanceof lobject.TValue);\n    let hash = key; /* table_hash known result */\n    if (value.ttisnil()) {\n        mark_dead(t, hash);\n        return;\n    }\n    let e = t.strong.get(hash);\n    if (e) {\n        let tv = e.value;\n        tv.setfrom(value);\n    } else {\n        let k = new lobject.TValue(LUA_TNUMINT, key);\n        let v = new lobject.TValue(value.type, value.value);\n        add(t, hash, k, v);\n    }\n};\n\nconst luaH_setfrom = function(L, t, key, value) {\n    lua_assert(key instanceof lobject.TValue);\n    let hash = table_hash(L, key);\n    if (value.ttisnil()) { /* delete */\n        mark_dead(t, hash);\n        return;\n    }\n\n    let e = t.strong.get(hash);\n    if (e) {\n        e.value.setfrom(value);\n    } else {\n        let k;\n        let kv = key.value;\n        if ((key.ttisfloat() && (kv|0) === kv)) { /* does index fit in an integer? */\n            /* insert it as an integer */\n            k = new lobject.TValue(LUA_TNUMINT, kv);\n        } else {\n            k = new lobject.TValue(key.type, kv);\n        }\n        let v = new lobject.TValue(value.type, value.value);\n        add(t, hash, k, v);\n    }\n};\n\n/*\n** Try to find a boundary in table 't'. A 'boundary' is an integer index\n** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).\n*/\nconst luaH_getn = function(t) {\n    let i = 0;\n    let j = t.strong.size + 1; /* use known size of Map to bound search */\n    /* now do a binary search between them */\n    while (j - i > 1) {\n        let m = Math.floor((i+j)/2);\n        if (luaH_getint(t, m).ttisnil()) j = m;\n        else i = m;\n    }\n    return i;\n};\n\nconst luaH_next = function(L, table, keyI) {\n    let keyO = L.stack[keyI];\n\n    let entry;\n    if (keyO.type === LUA_TNIL) {\n        entry = table.f;\n        if (!entry)\n            return false;\n    } else {\n        /* First find current key */\n        let hash = table_hash(L, keyO);\n        /* Look in main part of table */\n        entry = table.strong.get(hash);\n        if (entry) {\n            entry = entry.n;\n            if (!entry)\n                return false;\n        } else {\n            /* Try dead keys */\n            entry = (table.dead_weak && table.dead_weak.get(hash)) || table.dead_strong.get(hash);\n            if (!entry)\n                /* item not in table */\n                return ldebug.luaG_runerror(L, to_luastring(\"invalid key to 'next'\"));\n            /* Iterate until either out of keys, or until finding a non-dead key */\n            do {\n                entry = entry.n;\n                if (!entry)\n                    return false;\n            } while (entry.key.ttisdeadkey());\n        }\n    }\n    lobject.setobj2s(L, keyI, entry.key);\n    lobject.setobj2s(L, keyI+1, entry.value);\n    return true;\n};\n\nmodule.exports.invalidateTMcache = invalidateTMcache;\nmodule.exports.luaH_get     = luaH_get;\nmodule.exports.luaH_getint  = luaH_getint;\nmodule.exports.luaH_getn    = luaH_getn;\nmodule.exports.luaH_getstr  = luaH_getstr;\nmodule.exports.luaH_setfrom = luaH_setfrom;\nmodule.exports.luaH_setint  = luaH_setint;\nmodule.exports.luaH_new     = luaH_new;\nmodule.exports.luaH_next    = luaH_next;\nmodule.exports.Table        = Table;\n","\"use strict\";\n\nconst {\n    is_luastring,\n    luastring_eq,\n    luastring_from,\n    to_luastring\n} = require('./defs.js');\nconst { lua_assert } = require(\"./llimits.js\");\n\nclass TString {\n\n    constructor(L, str) {\n        this.hash = null;\n        this.realstring = str;\n    }\n\n    getstr() {\n        return this.realstring;\n    }\n\n    tsslen() {\n        return this.realstring.length;\n    }\n\n}\n\nconst luaS_eqlngstr = function(a, b) {\n    lua_assert(a instanceof TString);\n    lua_assert(b instanceof TString);\n    return a == b || luastring_eq(a.realstring, b.realstring);\n};\n\n/* converts strings (arrays) to a consistent map key\n   make sure this doesn't conflict with any of the anti-collision strategies in ltable */\nconst luaS_hash = function(str) {\n    lua_assert(is_luastring(str));\n    let len = str.length;\n    let s = \"|\";\n    for (let i=0; i<len; i++)\n        s += str[i].toString(16);\n    return s;\n};\n\nconst luaS_hashlongstr = function(ts) {\n    lua_assert(ts instanceof TString);\n    if(ts.hash === null) {\n        ts.hash = luaS_hash(ts.getstr());\n    }\n    return ts.hash;\n};\n\n/* variant that takes ownership of array */\nconst luaS_bless = function(L, str) {\n    lua_assert(str instanceof Uint8Array);\n    return new TString(L, str);\n};\n\n/* makes a copy */\nconst luaS_new = function(L, str) {\n    return luaS_bless(L, luastring_from(str));\n};\n\n/* takes a js string */\nconst luaS_newliteral = function(L, str) {\n    return luaS_bless(L, to_luastring(str));\n};\n\nmodule.exports.luaS_eqlngstr    = luaS_eqlngstr;\nmodule.exports.luaS_hash        = luaS_hash;\nmodule.exports.luaS_hashlongstr = luaS_hashlongstr;\nmodule.exports.luaS_bless       = luaS_bless;\nmodule.exports.luaS_new         = luaS_new;\nmodule.exports.luaS_newliteral  = luaS_newliteral;\nmodule.exports.TString          = TString;\n","\"use strict\";\n\nconst {\n    LUA_HOOKCOUNT,\n    LUA_HOOKLINE,\n    LUA_MASKCOUNT,\n    LUA_MASKLINE,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TNIL,\n        LUA_TTABLE\n    },\n    thread_status: {\n        LUA_ERRRUN,\n        LUA_YIELD\n    },\n    from_userstring,\n    luastring_eq,\n    luastring_indexOf,\n    to_luastring\n} = require('./defs.js');\nconst {\n    api_check,\n    lua_assert\n} = require('./llimits.js');\nconst { LUA_IDSIZE } = require('./luaconf.js');\nconst lapi     = require('./lapi.js');\nconst ldo      = require('./ldo.js');\nconst lfunc    = require('./lfunc.js');\nconst llex     = require('./llex.js');\nconst lobject  = require('./lobject.js');\nconst lopcodes = require('./lopcodes.js');\nconst lstate   = require('./lstate.js');\nconst ltable   = require('./ltable.js');\nconst ltm      = require('./ltm.js');\nconst lvm      = require('./lvm.js');\n\nconst currentpc = function(ci) {\n    lua_assert(ci.callstatus & lstate.CIST_LUA);\n    return ci.l_savedpc - 1;\n};\n\nconst currentline = function(ci) {\n    return ci.func.value.p.lineinfo.length !== 0 ? ci.func.value.p.lineinfo[currentpc(ci)] : -1;\n};\n\n/*\n** If function yielded, its 'func' can be in the 'extra' field. The\n** next function restores 'func' to its correct value for debugging\n** purposes. (It exchanges 'func' and 'extra'; so, when called again,\n** after debugging, it also \"re-restores\" ** 'func' to its altered value.\n*/\nconst swapextra = function(L) {\n    if (L.status === LUA_YIELD) {\n        let ci = L.ci;  /* get function that yielded */\n        let temp = ci.funcOff;  /* exchange its 'func' and 'extra' values */\n        ci.func = L.stack[ci.extra];\n        ci.funcOff = ci.extra;\n        ci.extra = temp;\n    }\n};\n\nconst lua_sethook = function(L, func, mask, count) {\n    if (func === null || mask === 0) {  /* turn off hooks? */\n        mask = 0;\n        func = null;\n    }\n    if (L.ci.callstatus & lstate.CIST_LUA)\n        L.oldpc = L.ci.l_savedpc;\n    L.hook = func;\n    L.basehookcount = count;\n    L.hookcount = L.basehookcount;\n    L.hookmask = mask;\n};\n\nconst lua_gethook = function(L) {\n    return L.hook;\n};\n\n\nconst lua_gethookmask = function(L) {\n    return L.hookmask;\n};\n\n\nconst lua_gethookcount = function(L) {\n    return L.basehookcount;\n};\n\nconst lua_getstack = function(L, level, ar) {\n    let ci;\n    let status;\n    if (level < 0) return 0;  /* invalid (negative) level */\n    for (ci = L.ci; level > 0 && ci !== L.base_ci; ci = ci.previous)\n        level--;\n    if (level === 0 && ci !== L.base_ci) {  /* level found? */\n        status = 1;\n        ar.i_ci = ci;\n    } else\n        status = 0;  /* no such level */\n    return status;\n};\n\nconst upvalname = function(p, uv) {\n    lua_assert(uv < p.upvalues.length);\n    let s = p.upvalues[uv].name;\n    if (s === null) return to_luastring(\"?\", true);\n    return s.getstr();\n};\n\nconst findvararg = function(ci, n) {\n    let nparams = ci.func.value.p.numparams;\n    if (n >= ci.l_base - ci.funcOff - nparams)\n        return null;  /* no such vararg */\n    else {\n        return {\n            pos: ci.funcOff + nparams + n,\n            name: to_luastring(\"(*vararg)\", true)  /* generic name for any vararg */\n        };\n    }\n};\n\nconst findlocal = function(L, ci, n) {\n    let base, name = null;\n\n    if (ci.callstatus & lstate.CIST_LUA) {\n        if (n < 0)  /* access to vararg values? */\n            return findvararg(ci, -n);\n        else {\n            base = ci.l_base;\n            name = lfunc.luaF_getlocalname(ci.func.value.p, n, currentpc(ci));\n        }\n    } else\n        base = ci.funcOff + 1;\n\n    if (name === null) {  /* no 'standard' name? */\n        let limit = ci === L.ci ? L.top : ci.next.funcOff;\n        if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */\n            name = to_luastring(\"(*temporary)\", true);  /* generic name for any valid slot */\n        else\n            return null;  /* no name */\n    }\n    return {\n        pos: base + (n - 1),\n        name: name\n    };\n};\n\nconst lua_getlocal = function(L, ar, n) {\n    let name;\n    swapextra(L);\n    if (ar === null) {  /* information about non-active function? */\n        if (!L.stack[L.top - 1].ttisLclosure())  /* not a Lua function? */\n            name = null;\n        else  /* consider live variables at function start (parameters) */\n            name = lfunc.luaF_getlocalname(L.stack[L.top - 1].value.p, n, 0);\n    } else {  /* active function; get information through 'ar' */\n        let local = findlocal(L, ar.i_ci, n);\n        if (local) {\n            name = local.name;\n            lobject.pushobj2s(L, L.stack[local.pos]);\n            api_check(L, L.top <= L.ci.top, \"stack overflow\");\n        } else {\n            name = null;\n        }\n    }\n    swapextra(L);\n    return name;\n};\n\nconst lua_setlocal = function(L, ar, n) {\n    let name;\n    swapextra(L);\n    let local = findlocal(L, ar.i_ci, n);\n    if (local) {\n        name = local.name;\n        lobject.setobjs2s(L, local.pos, L.top - 1);\n        delete L.stack[--L.top];  /* pop value */\n    } else {\n        name = null;\n    }\n    swapextra(L);\n    return name;\n};\n\nconst funcinfo = function(ar, cl) {\n    if (cl === null || cl instanceof lobject.CClosure) {\n        ar.source = to_luastring(\"=[JS]\", true);\n        ar.linedefined = -1;\n        ar.lastlinedefined = -1;\n        ar.what = to_luastring(\"J\", true);\n    } else {\n        let p = cl.p;\n        ar.source = p.source ? p.source.getstr() : to_luastring(\"=?\", true);\n        ar.linedefined = p.linedefined;\n        ar.lastlinedefined = p.lastlinedefined;\n        ar.what = ar.linedefined === 0 ? to_luastring(\"main\", true) : to_luastring(\"Lua\", true);\n    }\n\n    ar.short_src = lobject.luaO_chunkid(ar.source, LUA_IDSIZE);\n};\n\nconst collectvalidlines = function(L, f) {\n    if (f === null || f instanceof lobject.CClosure) {\n        L.stack[L.top] = new lobject.TValue(LUA_TNIL, null);\n        lapi.api_incr_top(L);\n    } else {\n        let lineinfo = f.p.lineinfo;\n        let t = ltable.luaH_new(L);\n        L.stack[L.top] = new lobject.TValue(LUA_TTABLE, t);\n        lapi.api_incr_top(L);\n        let v = new lobject.TValue(LUA_TBOOLEAN, true);\n        for (let i = 0; i < lineinfo.length; i++)\n            ltable.luaH_setint(t, lineinfo[i], v);\n    }\n};\n\nconst getfuncname = function(L, ci) {\n    let r = {\n        name: null,\n        funcname: null\n    };\n    if (ci === null)\n        return null;\n    else if (ci.callstatus & lstate.CIST_FIN) {  /* is this a finalizer? */\n        r.name = to_luastring(\"__gc\", true);\n        r.funcname = to_luastring(\"metamethod\", true);  /* report it as such */\n        return r;\n    }\n    /* calling function is a known Lua function? */\n    else if (!(ci.callstatus & lstate.CIST_TAIL) && ci.previous.callstatus & lstate.CIST_LUA)\n        return funcnamefromcode(L, ci.previous);\n    else return null;  /* no way to find a name */\n};\n\nconst auxgetinfo = function(L, what, ar, f, ci) {\n    let status = 1;\n    for (; what.length > 0; what = what.subarray(1)) {\n        switch (what[0]) {\n            case 83 /* ('S').charCodeAt(0) */: {\n                funcinfo(ar, f);\n                break;\n            }\n            case 108 /* ('l').charCodeAt(0) */: {\n                ar.currentline = ci && ci.callstatus & lstate.CIST_LUA ? currentline(ci) : -1;\n                break;\n            }\n            case 117 /* ('u').charCodeAt(0) */: {\n                ar.nups = f === null ? 0 : f.nupvalues;\n                if (f === null || f instanceof lobject.CClosure) {\n                    ar.isvararg = true;\n                    ar.nparams = 0;\n                } else {\n                    ar.isvararg = f.p.is_vararg;\n                    ar.nparams = f.p.numparams;\n                }\n                break;\n            }\n            case 116 /* ('t').charCodeAt(0) */: {\n                ar.istailcall = ci ? ci.callstatus & lstate.CIST_TAIL : 0;\n                break;\n            }\n            case 110 /* ('n').charCodeAt(0) */: {\n                let r = getfuncname(L, ci);\n                if (r === null) {\n                    ar.namewhat = to_luastring(\"\", true);\n                    ar.name = null;\n                } else {\n                    ar.namewhat = r.funcname;\n                    ar.name = r.name;\n                }\n                break;\n            }\n            case 76 /* ('L').charCodeAt(0) */:\n            case 102 /* ('f').charCodeAt(0) */:  /* handled by lua_getinfo */\n                break;\n            default: status = 0;  /* invalid option */\n        }\n    }\n\n    return status;\n};\n\nconst lua_getinfo = function(L, what, ar) {\n    what = from_userstring(what);\n    let status, cl, ci, func;\n    swapextra(L);\n    if (what[0] === 62 /* ('>').charCodeAt(0) */) {\n        ci = null;\n        func = L.stack[L.top - 1];\n        api_check(L, func.ttisfunction(), \"function expected\");\n        what = what.subarray(1);  /* skip the '>' */\n        L.top--;  /* pop function */\n    } else {\n        ci = ar.i_ci;\n        func = ci.func;\n        lua_assert(ci.func.ttisfunction());\n    }\n\n    cl = func.ttisclosure() ? func.value : null;\n    status = auxgetinfo(L, what, ar, cl, ci);\n    if (luastring_indexOf(what, 102 /* ('f').charCodeAt(0) */) >= 0) {\n        lobject.pushobj2s(L, func);\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    }\n\n    swapextra(L);\n    if (luastring_indexOf(what, 76 /* ('L').charCodeAt(0) */) >= 0)\n        collectvalidlines(L, cl);\n\n    return status;\n};\n\nconst kname = function(p, pc, c) {\n    let r = {\n        name: null,\n        funcname: null\n    };\n\n    if (lopcodes.ISK(c)) {  /* is 'c' a constant? */\n        let kvalue = p.k[lopcodes.INDEXK(c)];\n        if (kvalue.ttisstring()) {  /* literal constant? */\n            r.name = kvalue.svalue();  /* it is its own name */\n            return r;\n        }\n        /* else no reasonable name found */\n    } else {  /* 'c' is a register */\n        let what = getobjname(p, pc, c); /* search for 'c' */\n        if (what && what.funcname[0] === 99 /* ('c').charCodeAt(0) */) {  /* found a constant name? */\n            return what;  /* 'name' already filled */\n        }\n        /* else no reasonable name found */\n    }\n    r.name = to_luastring(\"?\", true);\n    return r;  /* no reasonable name found */\n};\n\nconst filterpc = function(pc, jmptarget) {\n    if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n        return -1;  /* cannot know who sets that register */\n    else return pc;  /* current position sets that register */\n};\n\n/*\n** try to find last instruction before 'lastpc' that modified register 'reg'\n*/\nconst findsetreg = function(p, lastpc, reg) {\n    let setreg = -1;  /* keep last instruction that changed 'reg' */\n    let jmptarget = 0;  /* any code before this address is conditional */\n    let OCi = lopcodes.OpCodesI;\n    for (let pc = 0; pc < lastpc; pc++) {\n        let i = p.code[pc];\n        let a = i.A;\n        switch (i.opcode) {\n            case OCi.OP_LOADNIL: {\n                let b = i.B;\n                if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */\n                    setreg = filterpc(pc, jmptarget);\n                break;\n            }\n            case OCi.OP_TFORCALL: {\n                if (reg >= a + 2)  /* affect all regs above its base */\n                    setreg = filterpc(pc, jmptarget);\n                break;\n            }\n            case OCi.OP_CALL:\n            case OCi.OP_TAILCALL: {\n                if (reg >= a)  /* affect all registers above base */\n                    setreg = filterpc(pc, jmptarget);\n                break;\n            }\n            case OCi.OP_JMP: {\n                let b = i.sBx;\n                let dest = pc + 1 + b;\n                /* jump is forward and do not skip 'lastpc'? */\n                if (pc < dest && dest <= lastpc) {\n                    if (dest > jmptarget)\n                        jmptarget = dest;  /* update 'jmptarget' */\n                }\n                break;\n            }\n            default:\n                if (lopcodes.testAMode(i.opcode) && reg === a)\n                    setreg = filterpc(pc, jmptarget);\n                break;\n        }\n    }\n\n    return setreg;\n};\n\n\nconst getobjname = function(p, lastpc, reg) {\n    let r = {\n        name: lfunc.luaF_getlocalname(p, reg + 1, lastpc),\n        funcname: null\n    };\n\n    if (r.name) {  /* is a local? */\n        r.funcname = to_luastring(\"local\", true);\n        return r;\n    }\n\n    /* else try symbolic execution */\n    let pc = findsetreg(p, lastpc, reg);\n    let OCi = lopcodes.OpCodesI;\n    if (pc !== -1) {  /* could find instruction? */\n        let i = p.code[pc];\n        switch (i.opcode) {\n            case OCi.OP_MOVE: {\n                let b = i.B;  /* move from 'b' to 'a' */\n                if (b < i.A)\n                    return getobjname(p, pc, b);  /* get name for 'b' */\n                break;\n            }\n            case OCi.OP_GETTABUP:\n            case OCi.OP_GETTABLE: {\n                let k = i.C;  /* key index */\n                let t = i.B;  /* table index */\n                let vn = i.opcode === OCi.OP_GETTABLE ? lfunc.luaF_getlocalname(p, t + 1, pc) : upvalname(p, t);\n                r.name = kname(p, pc, k).name;\n                r.funcname = (vn && luastring_eq(vn, llex.LUA_ENV)) ? to_luastring(\"global\", true) : to_luastring(\"field\", true);\n                return r;\n            }\n            case OCi.OP_GETUPVAL: {\n                r.name = upvalname(p, i.B);\n                r.funcname = to_luastring(\"upvalue\", true);\n                return r;\n            }\n            case OCi.OP_LOADK:\n            case OCi.OP_LOADKX: {\n                let b = i.opcode === OCi.OP_LOADK ? i.Bx : p.code[pc + 1].Ax;\n                if (p.k[b].ttisstring()) {\n                    r.name = p.k[b].svalue();\n                    r.funcname = to_luastring(\"constant\", true);\n                    return r;\n                }\n                break;\n            }\n            case OCi.OP_SELF: {\n                let k = i.C;\n                r.name = kname(p, pc, k).name;\n                r.funcname = to_luastring(\"method\", true);\n                return r;\n            }\n            default: break;\n        }\n    }\n\n    return null;\n};\n\n/*\n** Try to find a name for a function based on the code that called it.\n** (Only works when function was called by a Lua function.)\n** Returns what the name is (e.g., \"for iterator\", \"method\",\n** \"metamethod\") and sets '*name' to point to the name.\n*/\nconst funcnamefromcode = function(L, ci) {\n    let r = {\n        name: null,\n        funcname: null\n    };\n\n    let tm = 0;  /* (initial value avoids warnings) */\n    let p = ci.func.value.p;  /* calling function */\n    let pc = currentpc(ci);  /* calling instruction index */\n    let i = p.code[pc];  /* calling instruction */\n    let OCi = lopcodes.OpCodesI;\n\n    if (ci.callstatus & lstate.CIST_HOOKED) {\n        r.name = to_luastring(\"?\", true);\n        r.funcname = to_luastring(\"hook\", true);\n        return r;\n    }\n\n    switch (i.opcode) {\n        case OCi.OP_CALL:\n        case OCi.OP_TAILCALL:\n            return getobjname(p, pc, i.A);  /* get function name */\n        case OCi.OP_TFORCALL:\n            r.name = to_luastring(\"for iterator\", true);\n            r.funcname = to_luastring(\"for iterator\", true);\n            return r;\n        /* other instructions can do calls through metamethods */\n        case OCi.OP_SELF:\n        case OCi.OP_GETTABUP:\n        case OCi.OP_GETTABLE:\n            tm = ltm.TMS.TM_INDEX;\n            break;\n        case OCi.OP_SETTABUP:\n        case OCi.OP_SETTABLE:\n            tm = ltm.TMS.TM_NEWINDEX;\n            break;\n        case OCi.OP_ADD:    tm = ltm.TMS.TM_ADD;    break;\n        case OCi.OP_SUB:    tm = ltm.TMS.TM_SUB;    break;\n        case OCi.OP_MUL:    tm = ltm.TMS.TM_MUL;    break;\n        case OCi.OP_MOD:    tm = ltm.TMS.TM_MOD;    break;\n        case OCi.OP_POW:    tm = ltm.TMS.TM_POW;    break;\n        case OCi.OP_DIV:    tm = ltm.TMS.TM_DIV;    break;\n        case OCi.OP_IDIV:   tm = ltm.TMS.TM_IDIV;   break;\n        case OCi.OP_BAND:   tm = ltm.TMS.TM_BAND;   break;\n        case OCi.OP_BOR:    tm = ltm.TMS.TM_BOR;    break;\n        case OCi.OP_BXOR:   tm = ltm.TMS.TM_BXOR;   break;\n        case OCi.OP_SHL:    tm = ltm.TMS.TM_SHL;    break;\n        case OCi.OP_SHR:    tm = ltm.TMS.TM_SHR;    break;\n        case OCi.OP_UNM:    tm = ltm.TMS.TM_UNM;    break;\n        case OCi.OP_BNOT:   tm = ltm.TMS.TM_BNOT;   break;\n        case OCi.OP_LEN:    tm = ltm.TMS.TM_LEN;    break;\n        case OCi.OP_CONCAT: tm = ltm.TMS.TM_CONCAT; break;\n        case OCi.OP_EQ:     tm = ltm.TMS.TM_EQ;     break;\n        case OCi.OP_LT:     tm = ltm.TMS.TM_LT;     break;\n        case OCi.OP_LE:     tm = ltm.TMS.TM_LE;     break;\n        default:\n            return null;  /* cannot find a reasonable name */\n    }\n\n    r.name = L.l_G.tmname[tm].getstr();\n    r.funcname = to_luastring(\"metamethod\", true);\n    return r;\n};\n\nconst isinstack = function(L, ci, o) {\n    for (let i = ci.l_base; i < ci.top; i++) {\n        if (L.stack[i] === o)\n            return i;\n    }\n\n    return false;\n};\n\n/*\n** Checks whether value 'o' came from an upvalue. (That can only happen\n** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on\n** upvalues.)\n*/\nconst getupvalname = function(L, ci, o) {\n    let c = ci.func.value;\n    for (let i = 0; i < c.nupvalues; i++) {\n        if (c.upvals[i] === o) {\n            return {\n                name: upvalname(c.p, i),\n                funcname: to_luastring('upvalue', true)\n            };\n        }\n    }\n\n    return null;\n};\n\nconst varinfo = function(L, o) {\n    let ci = L.ci;\n    let kind = null;\n    if (ci.callstatus & lstate.CIST_LUA) {\n        kind = getupvalname(L, ci, o);  /* check whether 'o' is an upvalue */\n        let stkid = isinstack(L, ci, o);\n        if (!kind && stkid)  /* no? try a register */\n            kind = getobjname(ci.func.value.p, currentpc(ci), stkid - ci.l_base);\n    }\n\n    return kind ? lobject.luaO_pushfstring(L, to_luastring(\" (%s '%s')\", true), kind.funcname, kind.name) : to_luastring(\"\", true);\n};\n\nconst luaG_typeerror = function(L, o, op) {\n    let t = ltm.luaT_objtypename(L, o);\n    luaG_runerror(L, to_luastring(\"attempt to %s a %s value%s\", true), op, t, varinfo(L, o));\n};\n\nconst luaG_concaterror = function(L, p1, p2) {\n    if (p1.ttisstring() || lvm.cvt2str(p1)) p1 = p2;\n    luaG_typeerror(L, p1, to_luastring('concatenate', true));\n};\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nconst luaG_opinterror = function(L, p1, p2, msg) {\n    if (lvm.tonumber(p1) === false)\n        p2 = p1;\n    luaG_typeerror(L, p2, msg);\n};\n\nconst luaG_ordererror = function(L, p1, p2) {\n    let t1 = ltm.luaT_objtypename(L, p1);\n    let t2 = ltm.luaT_objtypename(L, p2);\n    if (luastring_eq(t1, t2))\n        luaG_runerror(L, to_luastring(\"attempt to compare two %s values\", true), t1);\n    else\n        luaG_runerror(L, to_luastring(\"attempt to compare %s with %s\", true), t1, t2);\n};\n\n/* add src:line information to 'msg' */\nconst luaG_addinfo = function(L, msg, src, line) {\n    let buff;\n    if (src)\n        buff = lobject.luaO_chunkid(src.getstr(), LUA_IDSIZE);\n    else\n        buff = to_luastring(\"?\", true);\n\n    return lobject.luaO_pushfstring(L, to_luastring(\"%s:%d: %s\", true), buff, line, msg);\n};\n\nconst luaG_runerror = function(L, fmt, ...argp) {\n    let ci = L.ci;\n    let msg = lobject.luaO_pushvfstring(L, fmt, argp);\n    if (ci.callstatus & lstate.CIST_LUA)  /* if Lua function, add source:line information */\n        luaG_addinfo(L, msg, ci.func.value.p.source, currentline(ci));\n    luaG_errormsg(L);\n};\n\nconst luaG_errormsg = function(L) {\n    if (L.errfunc !== 0) {  /* is there an error handling function? */\n        let errfunc = L.errfunc;\n        lobject.pushobj2s(L, L.stack[L.top - 1]); /* move argument */\n        lobject.setobjs2s(L, L.top - 2, errfunc); /* push function */\n        ldo.luaD_callnoyield(L, L.top - 2, 1);\n    }\n\n    ldo.luaD_throw(L, LUA_ERRRUN);\n};\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nconst luaG_tointerror = function(L, p1, p2) {\n    let temp = lvm.tointeger(p1);\n    if (temp === false)\n        p2 = p1;\n    luaG_runerror(L, to_luastring(\"number%s has no integer representation\", true), varinfo(L, p2));\n};\n\nconst luaG_traceexec = function(L) {\n    let ci = L.ci;\n    let mask = L.hookmask;\n    let counthook = (--L.hookcount === 0 && (mask & LUA_MASKCOUNT));\n    if (counthook)\n        L.hookcount = L.basehookcount;  /* reset count */\n    else if (!(mask & LUA_MASKLINE))\n        return;  /* no line hook and count != 0; nothing to be done */\n    if (ci.callstatus & lstate.CIST_HOOKYIELD) {  /* called hook last time? */\n        ci.callstatus &= ~lstate.CIST_HOOKYIELD;  /* erase mark */\n        return;  /* do not call hook again (VM yielded, so it did not move) */\n    }\n    if (counthook)\n        ldo.luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */\n    if (mask & LUA_MASKLINE) {\n        let p = ci.func.value.p;\n        let npc = ci.l_savedpc - 1; // pcRel(ci.u.l.savedpc, p);\n        let newline = p.lineinfo.length !== 0 ? p.lineinfo[npc] : -1;\n        if (npc === 0 ||  /* call linehook when enter a new function, */\n            ci.l_savedpc <= L.oldpc ||  /* when jump back (loop), or when */\n            newline !== (p.lineinfo.length !== 0 ? p.lineinfo[L.oldpc - 1] : -1))  /* enter a new line */\n            ldo.luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */\n    }\n    L.oldpc = ci.l_savedpc;\n    if (L.status === LUA_YIELD) {  /* did hook yield? */\n        if (counthook)\n            L.hookcount = 1;  /* undo decrement to zero */\n        ci.l_savedpc--;  /* undo increment (resume will increment it again) */\n        ci.callstatus |= lstate.CIST_HOOKYIELD;  /* mark that it yielded */\n        ci.funcOff = L.top - 1;  /* protect stack below results */\n        ci.func = L.stack[ci.funcOff];\n        ldo.luaD_throw(L, LUA_YIELD);\n    }\n};\n\nmodule.exports.luaG_addinfo     = luaG_addinfo;\nmodule.exports.luaG_concaterror = luaG_concaterror;\nmodule.exports.luaG_errormsg    = luaG_errormsg;\nmodule.exports.luaG_opinterror  = luaG_opinterror;\nmodule.exports.luaG_ordererror  = luaG_ordererror;\nmodule.exports.luaG_runerror    = luaG_runerror;\nmodule.exports.luaG_tointerror  = luaG_tointerror;\nmodule.exports.luaG_traceexec   = luaG_traceexec;\nmodule.exports.luaG_typeerror   = luaG_typeerror;\nmodule.exports.lua_gethook      = lua_gethook;\nmodule.exports.lua_gethookcount = lua_gethookcount;\nmodule.exports.lua_gethookmask  = lua_gethookmask;\nmodule.exports.lua_getinfo      = lua_getinfo;\nmodule.exports.lua_getlocal     = lua_getlocal;\nmodule.exports.lua_getstack     = lua_getstack;\nmodule.exports.lua_sethook      = lua_sethook;\nmodule.exports.lua_setlocal     = lua_setlocal;\n","\"use strict\";\n\nconst {\n    LUA_MINSTACK,\n    LUA_RIDX_GLOBALS,\n    LUA_RIDX_MAINTHREAD,\n    constant_types: {\n        LUA_NUMTAGS,\n        LUA_TNIL,\n        LUA_TTABLE,\n        LUA_TTHREAD\n    },\n    thread_status: {\n        LUA_OK\n    }\n} = require('./defs.js');\nconst lobject              = require('./lobject.js');\nconst ldo                  = require('./ldo.js');\nconst lapi                 = require('./lapi.js');\nconst ltable               = require('./ltable.js');\nconst ltm                  = require('./ltm.js');\n\nconst EXTRA_STACK = 5;\n\nconst BASIC_STACK_SIZE = 2 * LUA_MINSTACK;\n\nclass CallInfo {\n\n    constructor() {\n        this.func = null;\n        this.funcOff = NaN;\n        this.top = NaN;\n        this.previous = null;\n        this.next = null;\n\n        /* only for Lua functions */\n        this.l_base = NaN; /* base for this function */\n        this.l_code = null; /* reference to this.func.p.code */\n        this.l_savedpc = NaN; /* offset into l_code */\n        /* only for JS functions */\n        this.c_k = null;  /* continuation in case of yields */\n        this.c_old_errfunc = null;\n        this.c_ctx = null;  /* context info. in case of yields */\n\n        this.nresults = NaN;\n        this.callstatus = NaN;\n    }\n\n}\n\nclass lua_State {\n\n    constructor(g) {\n        this.id = g.id_counter++;\n\n        this.base_ci = new CallInfo(); /* CallInfo for first level (C calling Lua) */\n        this.top = NaN; /* first free slot in the stack */\n        this.stack_last = NaN; /* last free slot in the stack */\n        this.oldpc = NaN; /* last pc traced */\n\n        /* preinit_thread */\n        this.l_G = g;\n        this.stack = null;\n        this.ci = null;\n        this.errorJmp = null;\n        this.nCcalls = 0;\n        this.hook = null;\n        this.hookmask = 0;\n        this.basehookcount = 0;\n        this.allowhook = 1;\n        this.hookcount = this.basehookcount;\n        this.nny = 1;\n        this.status = LUA_OK;\n        this.errfunc = 0;\n    }\n\n}\n\nclass global_State {\n\n    constructor() {\n        this.id_counter = 1; /* used to give objects unique ids */\n        this.ids = new WeakMap();\n\n        this.mainthread = null;\n        this.l_registry = new lobject.TValue(LUA_TNIL, null);\n        this.panic = null;\n        this.atnativeerror = null;\n        this.version = null;\n        this.tmname = new Array(ltm.TMS.TM_N);\n        this.mt = new Array(LUA_NUMTAGS);\n    }\n\n}\n\nconst luaE_extendCI = function(L) {\n    let ci = new CallInfo();\n    L.ci.next = ci;\n    ci.previous = L.ci;\n    ci.next = null;\n    L.ci = ci;\n    return ci;\n};\n\nconst luaE_freeCI = function(L) {\n    let ci = L.ci;\n    ci.next = null;\n};\n\nconst stack_init = function(L1, L) {\n    L1.stack = new Array(BASIC_STACK_SIZE);\n    L1.top = 0;\n    L1.stack_last = BASIC_STACK_SIZE - EXTRA_STACK;\n    /* initialize first ci */\n    let ci = L1.base_ci;\n    ci.next = ci.previous = null;\n    ci.callstatus = 0;\n    ci.funcOff = L1.top;\n    ci.func = L1.stack[L1.top];\n    L1.stack[L1.top++] = new lobject.TValue(LUA_TNIL, null);\n    ci.top = L1.top + LUA_MINSTACK;\n    L1.ci = ci;\n};\n\nconst freestack = function(L) {\n    L.ci = L.base_ci;\n    luaE_freeCI(L);\n    L.stack = null;\n};\n\n/*\n** Create registry table and its predefined values\n*/\nconst init_registry = function(L, g) {\n    let registry = ltable.luaH_new(L);\n    g.l_registry.sethvalue(registry);\n    ltable.luaH_setint(registry, LUA_RIDX_MAINTHREAD, new lobject.TValue(LUA_TTHREAD, L));\n    ltable.luaH_setint(registry, LUA_RIDX_GLOBALS, new lobject.TValue(LUA_TTABLE, ltable.luaH_new(L)));\n};\n\n/*\n** open parts of the state that may cause memory-allocation errors.\n** ('g->version' !== NULL flags that the state was completely build)\n*/\nconst f_luaopen = function(L) {\n    let g = L.l_G;\n    stack_init(L, L);\n    init_registry(L, g);\n    ltm.luaT_init(L);\n    g.version = lapi.lua_version(null);\n};\n\nconst lua_newthread = function(L) {\n    let g = L.l_G;\n    let L1 = new lua_State(g);\n    L.stack[L.top] = new lobject.TValue(LUA_TTHREAD, L1);\n    lapi.api_incr_top(L);\n    L1.hookmask = L.hookmask;\n    L1.basehookcount = L.basehookcount;\n    L1.hook = L.hook;\n    L1.hookcount = L1.basehookcount;\n    stack_init(L1, L);\n    return L1;\n};\n\nconst luaE_freethread = function(L, L1) {\n    freestack(L1);\n};\n\nconst lua_newstate = function() {\n    let g = new global_State();\n    let L = new lua_State(g);\n    g.mainthread = L;\n\n    if (ldo.luaD_rawrunprotected(L, f_luaopen, null) !== LUA_OK) {\n        L = null;\n    }\n\n    return L;\n};\n\nconst close_state = function(L) {\n    freestack(L);\n};\n\nconst lua_close = function(L) {\n    L = L.l_G.mainthread;  /* only the main thread can be closed */\n    close_state(L);\n};\n\nmodule.exports.lua_State       = lua_State;\nmodule.exports.CallInfo        = CallInfo;\nmodule.exports.CIST_OAH        = (1<<0);  /* original value of 'allowhook' */\nmodule.exports.CIST_LUA        = (1<<1);  /* call is running a Lua function */\nmodule.exports.CIST_HOOKED     = (1<<2);  /* call is running a debug hook */\nmodule.exports.CIST_FRESH      = (1<<3);  /* call is running on a fresh invocation of luaV_execute */\nmodule.exports.CIST_YPCALL     = (1<<4);  /* call is a yieldable protected call */\nmodule.exports.CIST_TAIL       = (1<<5);  /* call was tail called */\nmodule.exports.CIST_HOOKYIELD  = (1<<6);  /* last hook called yielded */\nmodule.exports.CIST_LEQ        = (1<<7);  /* using __lt for __le */\nmodule.exports.CIST_FIN        = (1<<8);   /* call is running a finalizer */\nmodule.exports.EXTRA_STACK     = EXTRA_STACK;\nmodule.exports.lua_close       = lua_close;\nmodule.exports.lua_newstate    = lua_newstate;\nmodule.exports.lua_newthread   = lua_newthread;\nmodule.exports.luaE_extendCI   = luaE_extendCI;\nmodule.exports.luaE_freeCI     = luaE_freeCI;\nmodule.exports.luaE_freethread = luaE_freethread;\n","\"use strict\";\n\nconst { constant_types: { LUA_TNIL } } = require('./defs.js');\nconst lobject = require('./lobject.js');\n\nclass Proto {\n    constructor(L) {\n        this.id = L.l_G.id_counter++;\n        this.k = [];              // constants used by the function\n        this.p = [];              // functions defined inside the function\n        this.code = [];           // opcodes\n        this.cache = null;        // last-created closure with this prototype\n        this.lineinfo = [];       // map from opcodes to source lines (debug information)\n        this.upvalues = [];       // upvalue information\n        this.numparams = 0;       // number of fixed parameters\n        this.is_vararg = false;\n        this.maxstacksize = 0;    // number of registers needed by this function\n        this.locvars = [];        // information about local variables (debug information)\n        this.linedefined = 0;     // debug information\n        this.lastlinedefined = 0; // debug information\n        this.source = null;       // used for debug information\n    }\n}\n\nconst luaF_newLclosure = function(L, n) {\n    return new lobject.LClosure(L, n);\n};\n\n\nconst luaF_findupval = function(L, level) {\n    return L.stack[level];\n};\n\nconst luaF_close = function(L, level) {\n    /* Create new TValues on stack;\n     * any closures will keep referencing old TValues */\n    for (let i=level; i<L.top; i++) {\n        let old = L.stack[i];\n        L.stack[i] = new lobject.TValue(old.type, old.value);\n    }\n};\n\n/*\n** fill a closure with new upvalues\n*/\nconst luaF_initupvals = function(L, cl) {\n    for (let i = 0; i < cl.nupvalues; i++)\n        cl.upvals[i] = new lobject.TValue(LUA_TNIL, null);\n};\n\n/*\n** Look for n-th local variable at line 'line' in function 'func'.\n** Returns null if not found.\n*/\nconst luaF_getlocalname = function(f, local_number, pc) {\n    for (let i = 0; i < f.locvars.length && f.locvars[i].startpc <= pc; i++) {\n        if (pc < f.locvars[i].endpc) {  /* is variable active? */\n            local_number--;\n            if (local_number === 0)\n                return f.locvars[i].varname.getstr();\n        }\n    }\n    return null;  /* not found */\n};\n\nmodule.exports.MAXUPVAL          = 255;\nmodule.exports.Proto             = Proto;\nmodule.exports.luaF_findupval    = luaF_findupval;\nmodule.exports.luaF_close        = luaF_close;\nmodule.exports.luaF_getlocalname = luaF_getlocalname;\nmodule.exports.luaF_initupvals   = luaF_initupvals;\nmodule.exports.luaF_newLclosure  = luaF_newLclosure;\n","\"use strict\";\n\nconst {\n    constant_types: {\n        LUA_TTABLE,\n        LUA_TUSERDATA\n    },\n    to_luastring\n} = require('./defs.js');\nconst { lua_assert } = require('./llimits.js');\nconst lobject = require('./lobject.js');\nconst ldo     = require('./ldo.js');\nconst lstate  = require('./lstate.js');\nconst {\n    luaS_bless,\n    luaS_new\n} = require('./lstring.js');\nconst ltable  = require('./ltable.js');\nconst ldebug  = require('./ldebug.js');\nconst lvm     = require('./lvm.js');\n\nconst luaT_typenames_ = [\n    \"no value\",\n    \"nil\",\n    \"boolean\",\n    \"userdata\",\n    \"number\",\n    \"string\",\n    \"table\",\n    \"function\",\n    \"userdata\",\n    \"thread\",\n    \"proto\" /* this last case is used for tests only */\n].map(e => to_luastring(e));\n\nconst ttypename = function(t) {\n    return luaT_typenames_[t + 1];\n};\n\n\n/*\n* WARNING: if you change the order of this enumeration,\n* grep \"ORDER TM\" and \"ORDER OP\"\n*/\nconst TMS = {\n    TM_INDEX:    0,\n    TM_NEWINDEX: 1,\n    TM_GC:       2,\n    TM_MODE:     3,\n    TM_LEN:      4,\n    TM_EQ:       5,  /* last tag method with fast access */\n    TM_ADD:      6,\n    TM_SUB:      7,\n    TM_MUL:      8,\n    TM_MOD:      9,\n    TM_POW:     10,\n    TM_DIV:     11,\n    TM_IDIV:    12,\n    TM_BAND:    13 ,\n    TM_BOR:     14,\n    TM_BXOR:    15,\n    TM_SHL:     16,\n    TM_SHR:     17,\n    TM_UNM:     18,\n    TM_BNOT:    19,\n    TM_LT:      20,\n    TM_LE:      21,\n    TM_CONCAT:  22,\n    TM_CALL:    23,\n    TM_N:       24  /* number of elements in the enum */\n};\n\nconst luaT_init = function(L) {\n    L.l_G.tmname[TMS.TM_INDEX]    = new luaS_new(L, to_luastring(\"__index\", true));\n    L.l_G.tmname[TMS.TM_NEWINDEX] = new luaS_new(L, to_luastring(\"__newindex\", true));\n    L.l_G.tmname[TMS.TM_GC]       = new luaS_new(L, to_luastring(\"__gc\", true));\n    L.l_G.tmname[TMS.TM_MODE]     = new luaS_new(L, to_luastring(\"__mode\", true));\n    L.l_G.tmname[TMS.TM_LEN]      = new luaS_new(L, to_luastring(\"__len\", true));\n    L.l_G.tmname[TMS.TM_EQ]       = new luaS_new(L, to_luastring(\"__eq\", true));\n    L.l_G.tmname[TMS.TM_ADD]      = new luaS_new(L, to_luastring(\"__add\", true));\n    L.l_G.tmname[TMS.TM_SUB]      = new luaS_new(L, to_luastring(\"__sub\", true));\n    L.l_G.tmname[TMS.TM_MUL]      = new luaS_new(L, to_luastring(\"__mul\", true));\n    L.l_G.tmname[TMS.TM_MOD]      = new luaS_new(L, to_luastring(\"__mod\", true));\n    L.l_G.tmname[TMS.TM_POW]      = new luaS_new(L, to_luastring(\"__pow\", true));\n    L.l_G.tmname[TMS.TM_DIV]      = new luaS_new(L, to_luastring(\"__div\", true));\n    L.l_G.tmname[TMS.TM_IDIV]     = new luaS_new(L, to_luastring(\"__idiv\", true));\n    L.l_G.tmname[TMS.TM_BAND]     = new luaS_new(L, to_luastring(\"__band\", true));\n    L.l_G.tmname[TMS.TM_BOR]      = new luaS_new(L, to_luastring(\"__bor\", true));\n    L.l_G.tmname[TMS.TM_BXOR]     = new luaS_new(L, to_luastring(\"__bxor\", true));\n    L.l_G.tmname[TMS.TM_SHL]      = new luaS_new(L, to_luastring(\"__shl\", true));\n    L.l_G.tmname[TMS.TM_SHR]      = new luaS_new(L, to_luastring(\"__shr\", true));\n    L.l_G.tmname[TMS.TM_UNM]      = new luaS_new(L, to_luastring(\"__unm\", true));\n    L.l_G.tmname[TMS.TM_BNOT]     = new luaS_new(L, to_luastring(\"__bnot\", true));\n    L.l_G.tmname[TMS.TM_LT]       = new luaS_new(L, to_luastring(\"__lt\", true));\n    L.l_G.tmname[TMS.TM_LE]       = new luaS_new(L, to_luastring(\"__le\", true));\n    L.l_G.tmname[TMS.TM_CONCAT]   = new luaS_new(L, to_luastring(\"__concat\", true));\n    L.l_G.tmname[TMS.TM_CALL]     = new luaS_new(L, to_luastring(\"__call\", true));\n};\n\n/*\n** Return the name of the type of an object. For tables and userdata\n** with metatable, use their '__name' metafield, if present.\n*/\nconst __name = to_luastring('__name', true);\nconst luaT_objtypename = function(L, o) {\n    let mt;\n    if ((o.ttistable() && (mt = o.value.metatable) !== null) ||\n        (o.ttisfulluserdata() && (mt = o.value.metatable) !== null)) {\n        let name = ltable.luaH_getstr(mt, luaS_bless(L, __name));\n        if (name.ttisstring())\n            return name.svalue();\n    }\n    return ttypename(o.ttnov());\n};\n\nconst luaT_callTM = function(L, f, p1, p2, p3, hasres) {\n    let func = L.top;\n\n    lobject.pushobj2s(L, f); /* push function (assume EXTRA_STACK) */\n    lobject.pushobj2s(L, p1); /* 1st argument */\n    lobject.pushobj2s(L, p2); /* 2nd argument */\n\n    if (!hasres)  /* no result? 'p3' is third argument */\n        lobject.pushobj2s(L, p3); /* 3rd argument */\n\n    if (L.ci.callstatus & lstate.CIST_LUA)\n        ldo.luaD_call(L, func, hasres);\n    else\n        ldo.luaD_callnoyield(L, func, hasres);\n\n    if (hasres) {  /* if has result, move it to its place */\n        let tv = L.stack[L.top-1];\n        delete L.stack[--L.top];\n        p3.setfrom(tv);\n    }\n};\n\nconst luaT_callbinTM = function(L, p1, p2, res, event) {\n    let tm = luaT_gettmbyobj(L, p1, event);\n    if (tm.ttisnil())\n        tm = luaT_gettmbyobj(L, p2, event);\n    if (tm.ttisnil()) return false;\n    luaT_callTM(L, tm, p1, p2, res, 1);\n    return true;\n};\n\nconst luaT_trybinTM = function(L, p1, p2, res, event) {\n    if (!luaT_callbinTM(L, p1, p2, res, event)) {\n        switch (event) {\n            case TMS.TM_CONCAT:\n                return ldebug.luaG_concaterror(L, p1, p2);\n            case TMS.TM_BAND: case TMS.TM_BOR: case TMS.TM_BXOR:\n            case TMS.TM_SHL: case TMS.TM_SHR: case TMS.TM_BNOT: {\n                let n1 = lvm.tonumber(p1);\n                let n2 = lvm.tonumber(p2);\n                if (n1 !== false && n2 !== false)\n                    return ldebug.luaG_tointerror(L, p1, p2);\n                else\n                    return ldebug.luaG_opinterror(L, p1, p2, to_luastring(\"perform bitwise operation on\", true));\n            }\n            default:\n                return ldebug.luaG_opinterror(L, p1, p2, to_luastring(\"perform arithmetic on\", true));\n        }\n    }\n};\n\nconst luaT_callorderTM = function(L, p1, p2, event) {\n    let res = new lobject.TValue();\n    if (!luaT_callbinTM(L, p1, p2, res, event))\n        return null;\n    else\n        return !res.l_isfalse();\n};\n\nconst fasttm = function(l, et, e) {\n    return et === null ? null :\n        (et.flags & (1 << e)) ? null : luaT_gettm(et, e, l.l_G.tmname[e]);\n};\n\nconst luaT_gettm = function(events, event, ename) {\n    const tm = ltable.luaH_getstr(events, ename);\n    lua_assert(event <= TMS.TM_EQ);\n    if (tm.ttisnil()) {  /* no tag method? */\n        events.flags |= 1<<event;  /* cache this fact */\n        return null;\n    }\n    else return tm;\n};\n\nconst luaT_gettmbyobj = function(L, o, event) {\n    let mt;\n    switch(o.ttnov()) {\n        case LUA_TTABLE:\n        case LUA_TUSERDATA:\n            mt = o.value.metatable;\n            break;\n        default:\n            mt = L.l_G.mt[o.ttnov()];\n    }\n\n    return mt ? ltable.luaH_getstr(mt, L.l_G.tmname[event]) : lobject.luaO_nilobject;\n};\n\nmodule.exports.fasttm           = fasttm;\nmodule.exports.TMS              = TMS;\nmodule.exports.luaT_callTM      = luaT_callTM;\nmodule.exports.luaT_callbinTM   = luaT_callbinTM;\nmodule.exports.luaT_trybinTM    = luaT_trybinTM;\nmodule.exports.luaT_callorderTM = luaT_callorderTM;\nmodule.exports.luaT_gettm       = luaT_gettm;\nmodule.exports.luaT_gettmbyobj  = luaT_gettmbyobj;\nmodule.exports.luaT_init        = luaT_init;\nmodule.exports.luaT_objtypename = luaT_objtypename;\nmodule.exports.ttypename        = ttypename;\n","\"use strict\";\n\nconst {\n    LUA_MASKLINE,\n    LUA_MASKCOUNT,\n    LUA_MULTRET,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TLCF,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMBER,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR,\n        LUA_TTABLE,\n        LUA_TUSERDATA\n    },\n    to_luastring\n} = require('./defs.js');\nconst {\n    INDEXK,\n    ISK,\n    LFIELDS_PER_FLUSH,\n    OpCodesI: {\n        OP_ADD,\n        OP_BAND,\n        OP_BNOT,\n        OP_BOR,\n        OP_BXOR,\n        OP_CALL,\n        OP_CLOSURE,\n        OP_CONCAT,\n        OP_DIV,\n        OP_EQ,\n        OP_EXTRAARG,\n        OP_FORLOOP,\n        OP_FORPREP,\n        OP_GETTABLE,\n        OP_GETTABUP,\n        OP_GETUPVAL,\n        OP_IDIV,\n        OP_JMP,\n        OP_LE,\n        OP_LEN,\n        OP_LOADBOOL,\n        OP_LOADK,\n        OP_LOADKX,\n        OP_LOADNIL,\n        OP_LT,\n        OP_MOD,\n        OP_MOVE,\n        OP_MUL,\n        OP_NEWTABLE,\n        OP_NOT,\n        OP_POW,\n        OP_RETURN,\n        OP_SELF,\n        OP_SETLIST,\n        OP_SETTABLE,\n        OP_SETTABUP,\n        OP_SETUPVAL,\n        OP_SHL,\n        OP_SHR,\n        OP_SUB,\n        OP_TAILCALL,\n        OP_TEST,\n        OP_TESTSET,\n        OP_TFORCALL,\n        OP_TFORLOOP,\n        OP_UNM,\n        OP_VARARG\n    }\n} = require('./lopcodes.js');\nconst {\n    LUA_MAXINTEGER,\n    LUA_MININTEGER,\n    lua_numbertointeger\n} = require('./luaconf.js');\nconst {\n    lua_assert,\n    luai_nummod\n} = require('./llimits.js');\nconst lobject = require('./lobject.js');\nconst lfunc   = require('./lfunc.js');\nconst lstate  = require('./lstate.js');\nconst {\n    luaS_bless,\n    luaS_eqlngstr,\n    luaS_hashlongstr\n} = require('./lstring.js');\nconst ldo     = require('./ldo.js');\nconst ltm     = require('./ltm.js');\nconst ltable  = require('./ltable.js');\nconst ldebug  = require('./ldebug.js');\n\n/*\n** finish execution of an opcode interrupted by an yield\n*/\nconst luaV_finishOp = function(L) {\n    let ci = L.ci;\n    let base = ci.l_base;\n    let inst = ci.l_code[ci.l_savedpc - 1];  /* interrupted instruction */\n    let op = inst.opcode;\n\n    switch (op) {  /* finish its execution */\n        case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV: case OP_IDIV:\n        case OP_BAND: case OP_BOR: case OP_BXOR: case OP_SHL: case OP_SHR:\n        case OP_MOD: case OP_POW:\n        case OP_UNM: case OP_BNOT: case OP_LEN:\n        case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {\n            lobject.setobjs2s(L, base + inst.A, L.top-1);\n            delete L.stack[--L.top];\n            break;\n        }\n        case OP_LE: case OP_LT: case OP_EQ: {\n            let res = !L.stack[L.top - 1].l_isfalse();\n            delete L.stack[--L.top];\n            if (ci.callstatus & lstate.CIST_LEQ) {  /* \"<=\" using \"<\" instead? */\n                lua_assert(op === OP_LE);\n                ci.callstatus ^= lstate.CIST_LEQ;  /* clear mark */\n                res = !res;  /* negate result */\n            }\n            lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_JMP);\n            if (res !== (inst.A ? true : false))  /* condition failed? */\n                ci.l_savedpc++;  /* skip jump instruction */\n            break;\n        }\n        case OP_CONCAT: {\n            let top = L.top - 1;  /* top when 'luaT_trybinTM' was called */\n            let b = inst.B;  /* first element to concatenate */\n            let total = top - 1 - (base + b);  /* yet to concatenate */\n            lobject.setobjs2s(L, top - 2, top);  /* put TM result in proper position */\n            if (total > 1) {  /* are there elements to concat? */\n                L.top = top - 1;  /* top is one after last element (at top-2) */\n                luaV_concat(L, total);  /* concat them (may yield again) */\n            }\n            /* move final result to final position */\n            lobject.setobjs2s(L, ci.l_base + inst.A, L.top - 1);\n            ldo.adjust_top(L, ci.top);  /* restore top */\n            break;\n        }\n        case OP_TFORCALL: {\n            lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_TFORLOOP);\n            ldo.adjust_top(L, ci.top);  /* correct top */\n            break;\n        }\n        case OP_CALL: {\n            if (inst.C - 1 >= 0)  /* nresults >= 0? */\n                ldo.adjust_top(L, ci.top);  /* adjust results */\n            break;\n        }\n    }\n};\n\nconst RA = function(L, base, i) {\n    return base + i.A;\n};\n\nconst RB = function(L, base, i) {\n    return base + i.B;\n};\n\n// const RC = function(L, base, i) {\n//     return base + i.C;\n// };\n\nconst RKB = function(L, base, k, i) {\n    return ISK(i.B) ? k[INDEXK(i.B)] : L.stack[base + i.B];\n};\n\nconst RKC = function(L, base, k, i) {\n    return ISK(i.C) ? k[INDEXK(i.C)] : L.stack[base + i.C];\n};\n\nconst luaV_execute = function(L) {\n    let ci = L.ci;\n\n    ci.callstatus |= lstate.CIST_FRESH;\n    newframe:\n    for (;;) {\n        lua_assert(ci === L.ci);\n        let cl = ci.func.value;\n        let k = cl.p.k;\n        let base = ci.l_base;\n\n        let i = ci.l_code[ci.l_savedpc++];\n\n        if (L.hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) {\n            ldebug.luaG_traceexec(L);\n        }\n\n        let ra = RA(L, base, i);\n        let opcode = i.opcode;\n\n        switch (opcode) {\n            case OP_MOVE: {\n                lobject.setobjs2s(L, ra, RB(L, base, i));\n                break;\n            }\n            case OP_LOADK: {\n                let konst = k[i.Bx];\n                lobject.setobj2s(L, ra, konst);\n                break;\n            }\n            case OP_LOADKX: {\n                lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_EXTRAARG);\n                let konst = k[ci.l_code[ci.l_savedpc++].Ax];\n                lobject.setobj2s(L, ra, konst);\n                break;\n            }\n            case OP_LOADBOOL: {\n                L.stack[ra].setbvalue(i.B !== 0);\n\n                if (i.C !== 0)\n                    ci.l_savedpc++; /* skip next instruction (if C) */\n\n                break;\n            }\n            case OP_LOADNIL: {\n                for (let j = 0; j <= i.B; j++)\n                    L.stack[ra + j].setnilvalue();\n                break;\n            }\n            case OP_GETUPVAL: {\n                let b = i.B;\n                lobject.setobj2s(L, ra, cl.upvals[b]);\n                break;\n            }\n            case OP_GETTABUP: {\n                let upval = cl.upvals[i.B];\n                let rc = RKC(L, base, k, i);\n                luaV_gettable(L, upval, rc, ra);\n                break;\n            }\n            case OP_GETTABLE: {\n                let rb = L.stack[RB(L, base, i)];\n                let rc = RKC(L, base, k, i);\n                luaV_gettable(L, rb, rc, ra);\n                break;\n            }\n            case OP_SETTABUP: {\n                let upval = cl.upvals[i.A];\n                let rb = RKB(L, base, k, i);\n                let rc = RKC(L, base, k, i);\n                settable(L, upval, rb, rc);\n                break;\n            }\n            case OP_SETUPVAL: {\n                let uv = cl.upvals[i.B];\n                uv.setfrom(L.stack[ra]);\n                break;\n            }\n            case OP_SETTABLE: {\n                let table = L.stack[ra];\n                let key = RKB(L, base, k, i);\n                let v = RKC(L, base, k, i);\n\n                settable(L, table, key, v);\n                break;\n            }\n            case OP_NEWTABLE: {\n                L.stack[ra].sethvalue(ltable.luaH_new(L));\n                break;\n            }\n            case OP_SELF: {\n                let rb = RB(L, base, i);\n                let rc = RKC(L, base, k, i);\n                lobject.setobjs2s(L, ra + 1, rb);\n                luaV_gettable(L, L.stack[rb], rc, ra);\n                break;\n            }\n            case OP_ADD: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue((op1.value + op2.value)|0);\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(numberop1 + numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_ADD);\n                }\n                break;\n            }\n            case OP_SUB: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue((op1.value - op2.value)|0);\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(numberop1 - numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SUB);\n                }\n                break;\n            }\n            case OP_MUL: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue(luaV_imul(op1.value, op2.value));\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(numberop1 * numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_MUL);\n                }\n                break;\n            }\n            case OP_MOD: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue(luaV_mod(L, op1.value, op2.value));\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(luai_nummod(L, numberop1, numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_MOD);\n                }\n                break;\n            }\n            case OP_POW: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(Math.pow(numberop1, numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_POW);\n                }\n                break;\n            }\n            case OP_DIV: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(numberop1 / numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_DIV);\n                }\n                break;\n            }\n            case OP_IDIV: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if (op1.ttisinteger() && op2.ttisinteger()) {\n                    L.stack[ra].setivalue(luaV_div(L, op1.value, op2.value));\n                } else if ((numberop1 = tonumber(op1)) !== false && (numberop2 = tonumber(op2)) !== false) {\n                    L.stack[ra].setfltvalue(Math.floor(numberop1 / numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_IDIV);\n                }\n                break;\n            }\n            case OP_BAND: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(numberop1 & numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BAND);\n                }\n                break;\n            }\n            case OP_BOR: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(numberop1 | numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BOR);\n                }\n                break;\n            }\n            case OP_BXOR: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(numberop1 ^ numberop2);\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_BXOR);\n                }\n                break;\n            }\n            case OP_SHL: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(luaV_shiftl(numberop1, numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SHL);\n                }\n                break;\n            }\n            case OP_SHR: {\n                let op1 = RKB(L, base, k, i);\n                let op2 = RKC(L, base, k, i);\n                let numberop1, numberop2;\n\n                if ((numberop1 = tointeger(op1)) !== false && (numberop2 = tointeger(op2)) !== false) {\n                    L.stack[ra].setivalue(luaV_shiftl(numberop1, -numberop2));\n                } else {\n                    ltm.luaT_trybinTM(L, op1, op2, L.stack[ra], ltm.TMS.TM_SHR);\n                }\n                break;\n            }\n            case OP_UNM: {\n                let op = L.stack[RB(L, base, i)];\n                let numberop;\n\n                if (op.ttisinteger()) {\n                    L.stack[ra].setivalue((-op.value)|0);\n                } else if ((numberop = tonumber(op)) !== false) {\n                    L.stack[ra].setfltvalue(-numberop);\n                } else {\n                    ltm.luaT_trybinTM(L, op, op, L.stack[ra], ltm.TMS.TM_UNM);\n                }\n                break;\n            }\n            case OP_BNOT: {\n                let op = L.stack[RB(L, base, i)];\n\n                if (op.ttisinteger()) {\n                    L.stack[ra].setivalue(~op.value);\n                } else {\n                    ltm.luaT_trybinTM(L, op, op, L.stack[ra], ltm.TMS.TM_BNOT);\n                }\n                break;\n            }\n            case OP_NOT: {\n                let op = L.stack[RB(L, base, i)];\n                L.stack[ra].setbvalue(op.l_isfalse());\n                break;\n            }\n            case OP_LEN: {\n                luaV_objlen(L, L.stack[ra], L.stack[RB(L, base, i)]);\n                break;\n            }\n            case OP_CONCAT: {\n                let b = i.B;\n                let c = i.C;\n                L.top = base + c + 1; /* mark the end of concat operands */\n                luaV_concat(L, c - b + 1);\n                let rb = base + b;\n                lobject.setobjs2s(L, ra, rb);\n                ldo.adjust_top(L, ci.top); /* restore top */\n                break;\n            }\n            case OP_JMP: {\n                dojump(L, ci, i, 0);\n                break;\n            }\n            case OP_EQ: {\n                if (luaV_equalobj(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A)\n                    ci.l_savedpc++;\n                else\n                    donextjump(L, ci);\n                break;\n            }\n            case OP_LT: {\n                if (luaV_lessthan(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A)\n                    ci.l_savedpc++;\n                else\n                    donextjump(L, ci);\n                break;\n            }\n            case OP_LE: {\n                if (luaV_lessequal(L, RKB(L, base, k, i), RKC(L, base, k, i)) !== i.A)\n                    ci.l_savedpc++;\n                else\n                    donextjump(L, ci);\n                break;\n            }\n            case OP_TEST: {\n                if (i.C ? L.stack[ra].l_isfalse() : !L.stack[ra].l_isfalse())\n                    ci.l_savedpc++;\n                else\n                    donextjump(L, ci);\n                break;\n            }\n            case OP_TESTSET: {\n                let rbIdx = RB(L, base, i);\n                let rb = L.stack[rbIdx];\n                if (i.C ? rb.l_isfalse() : !rb.l_isfalse())\n                    ci.l_savedpc++;\n                else {\n                    lobject.setobjs2s(L, ra, rbIdx);\n                    donextjump(L, ci);\n                }\n                break;\n            }\n            case OP_CALL: {\n                let b = i.B;\n                let nresults = i.C - 1;\n                if (b !== 0) ldo.adjust_top(L, ra+b);  /* else previous instruction set top */\n                if (ldo.luaD_precall(L, ra, nresults)) {\n                    if (nresults >= 0)\n                        ldo.adjust_top(L, ci.top);  /* adjust results */\n                } else {\n                    ci = L.ci;\n                    continue newframe;\n                }\n\n                break;\n            }\n            case OP_TAILCALL: {\n                let b = i.B;\n                if (b !== 0) ldo.adjust_top(L, ra+b);  /* else previous instruction set top */\n                if (ldo.luaD_precall(L, ra, LUA_MULTRET)) { // JS function\n                } else {\n                    /* tail call: put called frame (n) in place of caller one (o) */\n                    let nci = L.ci;\n                    let oci = nci.previous;\n                    let nfunc = nci.func;\n                    let nfuncOff = nci.funcOff;\n                    let ofuncOff = oci.funcOff;\n                    let lim = nci.l_base + nfunc.value.p.numparams;\n                    if (cl.p.p.length > 0) lfunc.luaF_close(L, oci.l_base);\n                    for (let aux = 0; nfuncOff + aux < lim; aux++)\n                        lobject.setobjs2s(L, ofuncOff + aux, nfuncOff + aux);\n                    oci.l_base = ofuncOff + (nci.l_base - nfuncOff);\n                    oci.top = ofuncOff + (L.top - nfuncOff);\n                    ldo.adjust_top(L, oci.top);  /* correct top */\n                    oci.l_code = nci.l_code;\n                    oci.l_savedpc = nci.l_savedpc;\n                    oci.callstatus |= lstate.CIST_TAIL;\n                    oci.next = null;\n                    ci = L.ci = oci;\n\n                    lua_assert(L.top === oci.l_base + L.stack[ofuncOff].value.p.maxstacksize);\n\n                    continue newframe;\n                }\n                break;\n            }\n            case OP_RETURN: {\n                if (cl.p.p.length > 0) lfunc.luaF_close(L, base);\n                let b = ldo.luaD_poscall(L, ci, ra, (i.B !== 0 ? i.B - 1 : L.top - ra));\n\n                if (ci.callstatus & lstate.CIST_FRESH)\n                    return; /* external invocation: return */\n                /* invocation via reentry: continue execution */\n                ci = L.ci;\n                if (b) ldo.adjust_top(L, ci.top);\n                lua_assert(ci.callstatus & lstate.CIST_LUA);\n                lua_assert(ci.l_code[ci.l_savedpc - 1].opcode === OP_CALL);\n                continue newframe;\n            }\n            case OP_FORLOOP: {\n                if (L.stack[ra].ttisinteger()) { /* integer loop? */\n                    let step = L.stack[ra + 2].value;\n                    let idx = (L.stack[ra].value + step)|0;\n                    let limit = L.stack[ra + 1].value;\n\n                    if (0 < step ? idx <= limit : limit <= idx) {\n                        ci.l_savedpc += i.sBx;\n                        L.stack[ra].chgivalue(idx);  /* update internal index... */\n                        L.stack[ra + 3].setivalue(idx);\n                    }\n                } else { /* floating loop */\n                    let step = L.stack[ra + 2].value;\n                    let idx = L.stack[ra].value + step;\n                    let limit = L.stack[ra + 1].value;\n\n                    if (0 < step ? idx <= limit : limit <= idx) {\n                        ci.l_savedpc += i.sBx;\n                        L.stack[ra].chgfltvalue(idx);  /* update internal index... */\n                        L.stack[ra + 3].setfltvalue(idx);\n                    }\n                }\n                break;\n            }\n            case OP_FORPREP: {\n                let init = L.stack[ra];\n                let plimit = L.stack[ra + 1];\n                let pstep = L.stack[ra + 2];\n                let forlim;\n\n                if (init.ttisinteger() && pstep.ttisinteger() && (forlim = forlimit(plimit, pstep.value))) {\n                    /* all values are integer */\n                    let initv = forlim.stopnow ? 0 : init.value;\n                    plimit.value = forlim.ilimit;\n                    init.value = (initv - pstep.value)|0;\n                } else { /* try making all values floats */\n                    let nlimit, nstep, ninit;\n                    if ((nlimit = tonumber(plimit)) === false)\n                        ldebug.luaG_runerror(L, to_luastring(\"'for' limit must be a number\", true));\n                    L.stack[ra + 1].setfltvalue(nlimit);\n                    if ((nstep = tonumber(pstep)) === false)\n                        ldebug.luaG_runerror(L, to_luastring(\"'for' step must be a number\", true));\n                    L.stack[ra + 2].setfltvalue(nstep);\n                    if ((ninit = tonumber(init)) === false)\n                        ldebug.luaG_runerror(L, to_luastring(\"'for' initial value must be a number\", true));\n                    L.stack[ra].setfltvalue(ninit - nstep);\n                }\n\n                ci.l_savedpc += i.sBx;\n                break;\n            }\n            case OP_TFORCALL: {\n                let cb = ra + 3; /* call base */\n                lobject.setobjs2s(L, cb+2, ra+2);\n                lobject.setobjs2s(L, cb+1, ra+1);\n                lobject.setobjs2s(L, cb, ra);\n                ldo.adjust_top(L, cb+3);  /* func. + 2 args (state and index) */\n                ldo.luaD_call(L, cb, i.C);\n                ldo.adjust_top(L, ci.top);\n                /* go straight to OP_TFORLOOP */\n                i = ci.l_code[ci.l_savedpc++];\n                ra = RA(L, base, i);\n                lua_assert(i.opcode === OP_TFORLOOP);\n            }\n            /* fall through */\n            case OP_TFORLOOP: {\n                if (!L.stack[ra + 1].ttisnil()) { /* continue loop? */\n                    lobject.setobjs2s(L, ra, ra + 1); /* save control variable */\n                    ci.l_savedpc += i.sBx; /* jump back */\n                }\n                break;\n            }\n            case OP_SETLIST: {\n                let n = i.B;\n                let c = i.C;\n\n                if (n === 0) n = L.top - ra - 1;\n\n                if (c === 0) {\n                    lua_assert(ci.l_code[ci.l_savedpc].opcode === OP_EXTRAARG);\n                    c = ci.l_code[ci.l_savedpc++].Ax;\n                }\n\n                let h = L.stack[ra].value;\n                let last = ((c - 1) * LFIELDS_PER_FLUSH) + n;\n\n                for (; n > 0; n--) {\n                    ltable.luaH_setint(h, last--, L.stack[ra + n]);\n                }\n                ldo.adjust_top(L, ci.top);  /* correct top (in case of previous open call) */\n                break;\n            }\n            case OP_CLOSURE: {\n                let p = cl.p.p[i.Bx];\n                let ncl = getcached(p, cl.upvals, L.stack, base);  /* cached closure */\n                if (ncl === null)  /* no match? */\n                    pushclosure(L, p, cl.upvals, base, ra);  /* create a new one */\n                else\n                    L.stack[ra].setclLvalue(ncl);\n                break;\n            }\n            case OP_VARARG: {\n                let b = i.B - 1;\n                let n = base - ci.funcOff - cl.p.numparams - 1;\n                let j;\n\n                if (n < 0) /* less arguments than parameters? */\n                    n = 0; /* no vararg arguments */\n\n                if (b < 0) {\n                    b = n;  /* get all var. arguments */\n                    ldo.luaD_checkstack(L, n);\n                    ldo.adjust_top(L, ra + n);\n                }\n\n                for (j = 0; j < b && j < n; j++)\n                    lobject.setobjs2s(L, ra + j, base - n + j);\n\n                for (; j < b; j++) /* complete required results with nil */\n                    L.stack[ra + j].setnilvalue();\n                break;\n            }\n            case OP_EXTRAARG: {\n                throw Error(\"invalid opcode\");\n            }\n        }\n    }\n};\n\nconst dojump = function(L, ci, i, e) {\n    let a = i.A;\n    if (a !== 0) lfunc.luaF_close(L, ci.l_base + a - 1);\n    ci.l_savedpc += i.sBx + e;\n};\n\nconst donextjump = function(L, ci) {\n    dojump(L, ci, ci.l_code[ci.l_savedpc], 1);\n};\n\n\nconst luaV_lessthan = function(L, l, r) {\n    if (l.ttisnumber() && r.ttisnumber())\n        return LTnum(l, r) ? 1 : 0;\n    else if (l.ttisstring() && r.ttisstring())\n        return l_strcmp(l.tsvalue(), r.tsvalue()) < 0 ? 1 : 0;\n    else {\n        let res = ltm.luaT_callorderTM(L, l, r, ltm.TMS.TM_LT);\n        if (res === null)\n            ldebug.luaG_ordererror(L, l, r);\n        return res ? 1 : 0;\n    }\n};\n\nconst luaV_lessequal = function(L, l, r) {\n    let res;\n\n    if (l.ttisnumber() && r.ttisnumber())\n        return LEnum(l, r) ? 1 : 0;\n    else if (l.ttisstring() && r.ttisstring())\n        return l_strcmp(l.tsvalue(), r.tsvalue()) <= 0 ? 1 : 0;\n    else {\n        res = ltm.luaT_callorderTM(L, l, r, ltm.TMS.TM_LE);\n        if (res !== null)\n            return res ? 1 : 0;\n    }\n    /* try 'lt': */\n    L.ci.callstatus |= lstate.CIST_LEQ; /* mark it is doing 'lt' for 'le' */\n    res = ltm.luaT_callorderTM(L, r, l, ltm.TMS.TM_LT);\n    L.ci.callstatus ^= lstate.CIST_LEQ; /* clear mark */\n    if (res === null)\n        ldebug.luaG_ordererror(L, l, r);\n    return res ? 0 : 1; /* result is negated */\n};\n\nconst luaV_equalobj = function(L, t1, t2) {\n    if (t1.ttype() !== t2.ttype()) { /* not the same variant? */\n        if (t1.ttnov() !== t2.ttnov() || t1.ttnov() !== LUA_TNUMBER)\n            return 0; /* only numbers can be equal with different variants */\n        else { /* two numbers with different variants */\n            /* OPTIMIZATION: instead of calling luaV_tointeger we can just let JS do the comparison */\n            return (t1.value === t2.value) ? 1 : 0;\n        }\n    }\n\n    let tm;\n\n    /* values have same type and same variant */\n    switch(t1.ttype()) {\n        case LUA_TNIL:\n            return 1;\n        case LUA_TBOOLEAN:\n            return t1.value == t2.value ? 1 : 0; // Might be 1 or true\n        case LUA_TLIGHTUSERDATA:\n        case LUA_TNUMINT:\n        case LUA_TNUMFLT:\n        case LUA_TLCF:\n            return t1.value === t2.value ? 1 : 0;\n        case LUA_TSHRSTR:\n        case LUA_TLNGSTR: {\n            return luaS_eqlngstr(t1.tsvalue(), t2.tsvalue()) ? 1 : 0;\n        }\n        case LUA_TUSERDATA:\n        case LUA_TTABLE:\n            if (t1.value === t2.value) return 1;\n            else if (L === null) return 0;\n\n            tm = ltm.fasttm(L, t1.value.metatable, ltm.TMS.TM_EQ);\n            if (tm === null)\n                tm = ltm.fasttm(L, t2.value.metatable, ltm.TMS.TM_EQ);\n            break;\n        default:\n            return t1.value === t2.value ? 1 : 0;\n    }\n\n    if (tm === null) /* no TM? */\n        return 0;\n\n    let tv = new lobject.TValue(); /* doesn't use the stack */\n    ltm.luaT_callTM(L, tm, t1, t2, tv, 1);\n    return tv.l_isfalse() ? 0 : 1;\n};\n\nconst luaV_rawequalobj = function(t1, t2) {\n    return luaV_equalobj(null, t1, t2);\n};\n\nconst forlimit = function(obj, step) {\n    let stopnow = false;\n    let ilimit = luaV_tointeger(obj, step < 0 ? 2 : 1);\n    if (ilimit === false) {\n        let n = tonumber(obj);\n        if (n === false)\n            return false;\n\n        if (0 < n) {\n            ilimit = LUA_MAXINTEGER;\n            if (step < 0) stopnow = true;\n        } else {\n            ilimit = LUA_MININTEGER;\n            if (step >= 0) stopnow = true;\n        }\n    }\n\n    return {\n        stopnow: stopnow,\n        ilimit: ilimit\n    };\n};\n\n/*\n** try to convert a value to an integer, rounding according to 'mode':\n** mode === 0: accepts only integral values\n** mode === 1: takes the floor of the number\n** mode === 2: takes the ceil of the number\n*/\nconst luaV_tointeger = function(obj, mode) {\n    if (obj.ttisfloat()) {\n        let n = obj.value;\n        let f = Math.floor(n);\n\n        if (n !== f) { /* not an integral value? */\n            if (mode === 0)\n                return false;  /* fails if mode demands integral value */\n            else if (mode > 1)  /* needs ceil? */\n                f += 1;  /* convert floor to ceil (remember: n !== f) */\n        }\n\n        return lua_numbertointeger(f);\n    } else if (obj.ttisinteger()) {\n        return obj.value;\n    } else if (cvt2num(obj)) {\n        let v = new lobject.TValue();\n        if (lobject.luaO_str2num(obj.svalue(), v) === (obj.vslen() + 1))\n            return luaV_tointeger(v, mode);\n    }\n\n    return false;\n};\n\nconst tointeger = function(o) {\n    return o.ttisinteger() ? o.value : luaV_tointeger(o, 0);\n};\n\nconst tonumber = function(o) {\n    if (o.ttnov() === LUA_TNUMBER)\n        return o.value;\n\n    if (cvt2num(o)) {  /* string convertible to number? */\n        let v = new lobject.TValue();\n        if (lobject.luaO_str2num(o.svalue(), v) === (o.vslen() + 1))\n            return v.value;\n    }\n\n    return false;\n};\n\n/*\n** Return 'l < r', for numbers.\n** As fengari uses javascript numbers for both floats and integers and has\n** correct semantics, we can just compare values.\n*/\nconst LTnum = function(l, r) {\n    return l.value < r.value;\n};\n\n/*\n** Return 'l <= r', for numbers.\n*/\nconst LEnum = function(l, r) {\n    return l.value <= r.value;\n};\n\n/*\n** Compare two strings 'ls' x 'rs', returning an integer smaller-equal-\n** -larger than zero if 'ls' is smaller-equal-larger than 'rs'.\n*/\nconst l_strcmp = function(ls, rs) {\n    let l = luaS_hashlongstr(ls);\n    let r = luaS_hashlongstr(rs);\n    /* In fengari we assume string hash has same collation as byte values */\n    if (l === r)\n        return 0;\n    else if (l < r)\n        return -1;\n    else\n        return 1;\n};\n\n/*\n** Main operation 'ra' = #rb'.\n*/\nconst luaV_objlen = function(L, ra, rb) {\n    let tm;\n    switch(rb.ttype()) {\n        case LUA_TTABLE: {\n            let h = rb.value;\n            tm = ltm.fasttm(L, h.metatable, ltm.TMS.TM_LEN);\n            if (tm !== null) break; /* metamethod? break switch to call it */\n            ra.setivalue(ltable.luaH_getn(h)); /* else primitive len */\n            return;\n        }\n        case LUA_TSHRSTR:\n        case LUA_TLNGSTR:\n            ra.setivalue(rb.vslen());\n            return;\n        default: {\n            tm = ltm.luaT_gettmbyobj(L, rb, ltm.TMS.TM_LEN);\n            if (tm.ttisnil())\n                ldebug.luaG_typeerror(L, rb, to_luastring(\"get length of\", true));\n            break;\n        }\n    }\n\n    ltm.luaT_callTM(L, tm, rb, rb, ra, 1);\n};\n\n/* Shim taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul */\nconst luaV_imul = Math.imul || function(a, b) {\n    let aHi = (a >>> 16) & 0xffff;\n    let aLo = a & 0xffff;\n    let bHi = (b >>> 16) & 0xffff;\n    let bLo = b & 0xffff;\n    /*\n    ** the shift by 0 fixes the sign on the high part\n    ** the final |0 converts the unsigned value into a signed value\n    */\n    return ((aLo * bLo) + (((aHi * bLo + aLo * bHi) << 16) >>> 0) | 0);\n};\n\nconst luaV_div = function(L, m, n) {\n    if (n === 0)\n        ldebug.luaG_runerror(L, to_luastring(\"attempt to divide by zero\"));\n    return Math.floor(m / n)|0;\n};\n\n// % semantic on negative numbers is different in js\nconst luaV_mod = function(L, m, n) {\n    if (n === 0)\n        ldebug.luaG_runerror(L, to_luastring(\"attempt to perform 'n%%0'\"));\n    return (m - Math.floor(m / n) * n)|0;\n};\n\nconst NBITS = 32;\n\nconst luaV_shiftl = function(x, y) {\n    if (y < 0) {  /* shift right? */\n        if (y <= -NBITS) return 0;\n        else return x >>> -y;\n    }\n    else {  /* shift left */\n        if (y >= NBITS) return 0;\n        else return x << y;\n    }\n};\n\n/*\n** check whether cached closure in prototype 'p' may be reused, that is,\n** whether there is a cached closure with the same upvalues needed by\n** new closure to be created.\n*/\nconst getcached = function(p, encup, stack, base) {\n    let c = p.cache;\n    if (c !== null) {  /* is there a cached closure? */\n        let uv = p.upvalues;\n        let nup = uv.length;\n        for (let i = 0; i < nup; i++) {  /* check whether it has right upvalues */\n            let v = uv[i].instack ? stack[base + uv[i].idx] : encup[uv[i].idx];\n            if (c.upvals[i] !== v)\n                return null;  /* wrong upvalue; cannot reuse closure */\n        }\n    }\n    return c;  /* return cached closure (or NULL if no cached closure) */\n};\n\n/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues.\n*/\nconst pushclosure = function(L, p, encup, base, ra) {\n    let nup = p.upvalues.length;\n    let uv = p.upvalues;\n    let ncl = new lobject.LClosure(L, nup);\n    ncl.p = p;\n    L.stack[ra].setclLvalue(ncl);\n    for (let i = 0; i < nup; i++) {\n        if (uv[i].instack)\n            ncl.upvals[i] = lfunc.luaF_findupval(L, base + uv[i].idx);\n        else\n            ncl.upvals[i] = encup[uv[i].idx];\n    }\n    p.cache = ncl;  /* save it on cache for reuse */\n};\n\nconst cvt2str = function(o) {\n    return o.ttisnumber();\n};\n\nconst cvt2num = function(o) {\n    return o.ttisstring();\n};\n\nconst tostring = function(L, i) {\n    let o = L.stack[i];\n\n    if (o.ttisstring()) return true;\n\n    if (cvt2str(o)) {\n        lobject.luaO_tostring(L, o);\n        return true;\n    }\n\n    return false;\n};\n\nconst isemptystr = function(o) {\n    return o.ttisstring() && o.vslen() === 0;\n};\n\n/* copy strings in stack from top - n up to top - 1 to buffer */\nconst copy2buff = function(L, top, n, buff) {\n    let tl = 0;  /* size already copied */\n    do {\n        let tv = L.stack[top-n];\n        let l = tv.vslen();  /* length of string being copied */\n        let s = tv.svalue();\n        buff.set(s, tl);\n        tl += l;\n    } while (--n > 0);\n};\n\n/*\n** Main operation for concatenation: concat 'total' values in the stack,\n** from 'L->top - total' up to 'L->top - 1'.\n*/\nconst luaV_concat = function(L, total) {\n    lua_assert(total >= 2);\n    do {\n        let top = L.top;\n        let n = 2; /* number of elements handled in this pass (at least 2) */\n\n        if (!(L.stack[top-2].ttisstring() || cvt2str(L.stack[top-2])) || !tostring(L, top - 1)) {\n            ltm.luaT_trybinTM(L, L.stack[top-2], L.stack[top-1], L.stack[top-2], ltm.TMS.TM_CONCAT);\n        } else if (isemptystr(L.stack[top-1])) {\n            tostring(L, top - 2);\n        } else if (isemptystr(L.stack[top-2])) {\n            lobject.setobjs2s(L, top - 2, top - 1);\n        } else {\n            /* at least two non-empty string values; get as many as possible */\n            let tl = L.stack[top-1].vslen();\n            /* collect total length and number of strings */\n            for (n = 1; n < total && tostring(L, top - n - 1); n++) {\n                let l = L.stack[top - n - 1].vslen();\n                tl += l;\n            }\n            let buff = new Uint8Array(tl);\n            copy2buff(L, top, n, buff);\n            let ts = luaS_bless(L, buff);\n            lobject.setsvalue2s(L, top - n, ts);\n        }\n        total -= n - 1; /* got 'n' strings to create 1 new */\n        /* popped 'n' strings and pushed one */\n        for (; L.top > top-(n-1);)\n            delete L.stack[--L.top];\n    } while (total > 1); /* repeat until only 1 result left */\n};\n\nconst MAXTAGLOOP = 2000;\n\nconst luaV_gettable = function(L, t, key, ra) {\n    for (let loop = 0; loop < MAXTAGLOOP; loop++) {\n        let tm;\n\n        if (!t.ttistable()) {\n            tm = ltm.luaT_gettmbyobj(L, t, ltm.TMS.TM_INDEX);\n            if (tm.ttisnil())\n                ldebug.luaG_typeerror(L, t, to_luastring('index', true)); /* no metamethod */\n            /* else will try the metamethod */\n        } else {\n            let slot = ltable.luaH_get(L, t.value, key);\n            if (!slot.ttisnil()) {\n                lobject.setobj2s(L, ra, slot);\n                return;\n            } else { /* 't' is a table */\n                tm = ltm.fasttm(L, t.value.metatable, ltm.TMS.TM_INDEX);  /* table's metamethod */\n                if (tm === null) { /* no metamethod? */\n                    L.stack[ra].setnilvalue(); /* result is nil */\n                    return;\n                }\n            }\n            /* else will try the metamethod */\n        }\n        if (tm.ttisfunction()) { /* is metamethod a function? */\n            ltm.luaT_callTM(L, tm, t, key, L.stack[ra], 1); /* call it */\n            return;\n        }\n        t = tm;  /* else try to access 'tm[key]' */\n    }\n\n    ldebug.luaG_runerror(L, to_luastring(\"'__index' chain too long; possible loop\", true));\n};\n\nconst settable = function(L, t, key, val) {\n    for (let loop = 0; loop < MAXTAGLOOP; loop++) {\n        let tm;\n        if (t.ttistable()) {\n            let h = t.value; /* save 't' table */\n            let slot = ltable.luaH_get(L, h, key);\n            if (!slot.ttisnil() || (tm = ltm.fasttm(L, h.metatable, ltm.TMS.TM_NEWINDEX)) === null) {\n                ltable.luaH_setfrom(L, h, key, val);\n                ltable.invalidateTMcache(h);\n                return;\n            }\n            /* else will try the metamethod */\n        } else { /* not a table; check metamethod */\n            if ((tm = ltm.luaT_gettmbyobj(L, t, ltm.TMS.TM_NEWINDEX)).ttisnil())\n                ldebug.luaG_typeerror(L, t, to_luastring('index', true));\n        }\n        /* try the metamethod */\n        if (tm.ttisfunction()) {\n            ltm.luaT_callTM(L, tm, t, key, val, 0);\n            return;\n        }\n        t = tm;  /* else repeat assignment over 'tm' */\n    }\n\n    ldebug.luaG_runerror(L, to_luastring(\"'__newindex' chain too long; possible loop\", true));\n};\n\n\nmodule.exports.cvt2str          = cvt2str;\nmodule.exports.cvt2num          = cvt2num;\nmodule.exports.luaV_gettable    = luaV_gettable;\nmodule.exports.luaV_concat      = luaV_concat;\nmodule.exports.luaV_div         = luaV_div;\nmodule.exports.luaV_equalobj    = luaV_equalobj;\nmodule.exports.luaV_execute     = luaV_execute;\nmodule.exports.luaV_finishOp    = luaV_finishOp;\nmodule.exports.luaV_imul        = luaV_imul;\nmodule.exports.luaV_lessequal   = luaV_lessequal;\nmodule.exports.luaV_lessthan    = luaV_lessthan;\nmodule.exports.luaV_mod         = luaV_mod;\nmodule.exports.luaV_objlen      = luaV_objlen;\nmodule.exports.luaV_rawequalobj = luaV_rawequalobj;\nmodule.exports.luaV_shiftl      = luaV_shiftl;\nmodule.exports.luaV_tointeger   = luaV_tointeger;\nmodule.exports.settable         = settable;\nmodule.exports.tointeger        = tointeger;\nmodule.exports.tonumber         = tonumber;\n","\"use strict\";\n\nconst OpCodes = [\n    \"MOVE\",\n    \"LOADK\",\n    \"LOADKX\",\n    \"LOADBOOL\",\n    \"LOADNIL\",\n    \"GETUPVAL\",\n    \"GETTABUP\",\n    \"GETTABLE\",\n    \"SETTABUP\",\n    \"SETUPVAL\",\n    \"SETTABLE\",\n    \"NEWTABLE\",\n    \"SELF\",\n    \"ADD\",\n    \"SUB\",\n    \"MUL\",\n    \"MOD\",\n    \"POW\",\n    \"DIV\",\n    \"IDIV\",\n    \"BAND\",\n    \"BOR\",\n    \"BXOR\",\n    \"SHL\",\n    \"SHR\",\n    \"UNM\",\n    \"BNOT\",\n    \"NOT\",\n    \"LEN\",\n    \"CONCAT\",\n    \"JMP\",\n    \"EQ\",\n    \"LT\",\n    \"LE\",\n    \"TEST\",\n    \"TESTSET\",\n    \"CALL\",\n    \"TAILCALL\",\n    \"RETURN\",\n    \"FORLOOP\",\n    \"FORPREP\",\n    \"TFORCALL\",\n    \"TFORLOOP\",\n    \"SETLIST\",\n    \"CLOSURE\",\n    \"VARARG\",\n    \"EXTRAARG\"\n];\n\nconst OpCodesI = {\n    OP_MOVE:     0,\n    OP_LOADK:    1,\n    OP_LOADKX:   2,\n    OP_LOADBOOL: 3,\n    OP_LOADNIL:  4,\n    OP_GETUPVAL: 5,\n    OP_GETTABUP: 6,\n    OP_GETTABLE: 7,\n    OP_SETTABUP: 8,\n    OP_SETUPVAL: 9,\n    OP_SETTABLE: 10,\n    OP_NEWTABLE: 11,\n    OP_SELF:     12,\n    OP_ADD:      13,\n    OP_SUB:      14,\n    OP_MUL:      15,\n    OP_MOD:      16,\n    OP_POW:      17,\n    OP_DIV:      18,\n    OP_IDIV:     19,\n    OP_BAND:     20,\n    OP_BOR:      21,\n    OP_BXOR:     22,\n    OP_SHL:      23,\n    OP_SHR:      24,\n    OP_UNM:      25,\n    OP_BNOT:     26,\n    OP_NOT:      27,\n    OP_LEN:      28,\n    OP_CONCAT:   29,\n    OP_JMP:      30,\n    OP_EQ:       31,\n    OP_LT:       32,\n    OP_LE:       33,\n    OP_TEST:     34,\n    OP_TESTSET:  35,\n    OP_CALL:     36,\n    OP_TAILCALL: 37,\n    OP_RETURN:   38,\n    OP_FORLOOP:  39,\n    OP_FORPREP:  40,\n    OP_TFORCALL: 41,\n    OP_TFORLOOP: 42,\n    OP_SETLIST:  43,\n    OP_CLOSURE:  44,\n    OP_VARARG:   45,\n    OP_EXTRAARG: 46\n};\n\n/*\n** masks for instruction properties. The format is:\n** bits 0-1: op mode\n** bits 2-3: C arg mode\n** bits 4-5: B arg mode\n** bit 6: instruction set register A\n** bit 7: operator is a test (next instruction must be a jump)\n*/\nconst OpArgN = 0;  /* argument is not used */\nconst OpArgU = 1;  /* argument is used */\nconst OpArgR = 2;  /* argument is a register or a jump offset */\nconst OpArgK = 3;  /* argument is a constant or register/constant */\n\n/* basic instruction format */\nconst iABC  = 0;\nconst iABx  = 1;\nconst iAsBx = 2;\nconst iAx   = 3;\n\nconst luaP_opmodes = [\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_MOVE */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgN << 2 | iABx,   /* OP_LOADK */\n    0 << 7 | 1 << 6 | OpArgN << 4 | OpArgN << 2 | iABx,   /* OP_LOADKX */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_LOADBOOL */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_LOADNIL */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_GETUPVAL */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgK << 2 | iABC,   /* OP_GETTABUP */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgK << 2 | iABC,   /* OP_GETTABLE */\n    0 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SETTABUP */\n    0 << 7 | 0 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_SETUPVAL */\n    0 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SETTABLE */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_NEWTABLE */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgK << 2 | iABC,   /* OP_SELF */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_ADD */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SUB */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_MUL */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_MOD */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_POW */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_DIV */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_IDIV */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_BAND */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_BOR */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_BXOR */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SHL */\n    0 << 7 | 1 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_SHR */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_UNM */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_BNOT */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_NOT */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iABC,   /* OP_LEN */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgR << 2 | iABC,   /* OP_CONCAT */\n    0 << 7 | 0 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,  /* OP_JMP */\n    1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_EQ */\n    1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_LT */\n    1 << 7 | 0 << 6 | OpArgK << 4 | OpArgK << 2 | iABC,   /* OP_LE */\n    1 << 7 | 0 << 6 | OpArgN << 4 | OpArgU << 2 | iABC,   /* OP_TEST */\n    1 << 7 | 1 << 6 | OpArgR << 4 | OpArgU << 2 | iABC,   /* OP_TESTSET */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_CALL */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_TAILCALL */\n    0 << 7 | 0 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_RETURN */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,  /* OP_FORLOOP */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,  /* OP_FORPREP */\n    0 << 7 | 0 << 6 | OpArgN << 4 | OpArgU << 2 | iABC,   /* OP_TFORCALL */\n    0 << 7 | 1 << 6 | OpArgR << 4 | OpArgN << 2 | iAsBx,  /* OP_TFORLOOP */\n    0 << 7 | 0 << 6 | OpArgU << 4 | OpArgU << 2 | iABC,   /* OP_SETLIST */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABx,   /* OP_CLOSURE */\n    0 << 7 | 1 << 6 | OpArgU << 4 | OpArgN << 2 | iABC,   /* OP_VARARG */\n    0 << 7 | 0 << 6 | OpArgU << 4 | OpArgU << 2 | iAx     /* OP_EXTRAARG */\n];\n\nconst getOpMode = function(m) {\n    return luaP_opmodes[m] & 3;\n};\n\nconst getBMode = function(m) {\n    return (luaP_opmodes[m] >> 4) & 3;\n};\n\nconst getCMode = function(m) {\n    return (luaP_opmodes[m] >> 2) & 3;\n};\n\nconst testAMode = function(m) {\n    return luaP_opmodes[m] & (1 << 6);\n};\n\nconst testTMode = function(m) {\n    return luaP_opmodes[m] & (1 << 7);\n};\n\nconst SIZE_C     = 9;\nconst SIZE_B     = 9;\nconst SIZE_Bx    = (SIZE_C + SIZE_B);\nconst SIZE_A     = 8;\nconst SIZE_Ax    = (SIZE_C + SIZE_B + SIZE_A);\nconst SIZE_OP    = 6;\nconst POS_OP     = 0;\nconst POS_A      = (POS_OP + SIZE_OP);\nconst POS_C      = (POS_A + SIZE_A);\nconst POS_B      = (POS_C + SIZE_C);\nconst POS_Bx     = POS_C;\nconst POS_Ax     = POS_A;\nconst MAXARG_Bx  = ((1 << SIZE_Bx) - 1);\nconst MAXARG_sBx = (MAXARG_Bx >> 1); /* 'sBx' is signed */\nconst MAXARG_Ax  = ((1<<SIZE_Ax)-1);\nconst MAXARG_A   = ((1 << SIZE_A) - 1);\nconst MAXARG_B   = ((1 << SIZE_B) - 1);\nconst MAXARG_C   = ((1 << SIZE_C) - 1);\n\n/* this bit 1 means constant (0 means register) */\nconst BITRK      = (1 << (SIZE_B - 1));\n\nconst MAXINDEXRK = (BITRK - 1);\n\n/*\n** invalid register that fits in 8 bits\n*/\nconst NO_REG     = MAXARG_A;\n\n/* test whether value is a constant */\nconst ISK = function (x) {\n    return x & BITRK;\n};\n\n/* gets the index of the constant */\nconst INDEXK = function (r) {\n    return r & ~BITRK;\n};\n\n/* code a constant index as a RK value */\nconst RKASK = function(x) {\n    return x | BITRK;\n};\n\n\n/* creates a mask with 'n' 1 bits at position 'p' */\nconst MASK1 = function(n, p) {\n    return ((~((~0)<<(n)))<<(p));\n};\n\n/* creates a mask with 'n' 0 bits at position 'p' */\nconst MASK0 = function(n, p) {\n    return (~MASK1(n, p));\n};\n\nconst GET_OPCODE = function(i) {\n    return i.opcode;\n};\n\nconst SET_OPCODE = function(i, o) {\n    i.code = (i.code & MASK0(SIZE_OP, POS_OP)) | ((o << POS_OP) & MASK1(SIZE_OP, POS_OP));\n    return fullins(i);\n};\n\nconst setarg = function(i, v, pos, size) {\n    i.code = (i.code & MASK0(size, pos)) | ((v << pos) & MASK1(size, pos));\n    return fullins(i);\n};\n\nconst GETARG_A = function(i) {\n    return i.A;\n};\n\nconst SETARG_A = function(i,v) {\n    return setarg(i, v, POS_A, SIZE_A);\n};\n\nconst GETARG_B = function(i) {\n    return i.B;\n};\n\nconst SETARG_B = function(i,v) {\n    return setarg(i, v, POS_B, SIZE_B);\n};\n\nconst GETARG_C = function(i) {\n    return i.C;\n};\n\nconst SETARG_C = function(i,v) {\n    return setarg(i, v, POS_C, SIZE_C);\n};\n\nconst GETARG_Bx = function(i) {\n    return i.Bx;\n};\n\nconst SETARG_Bx = function(i,v) {\n    return setarg(i, v, POS_Bx, SIZE_Bx);\n};\n\nconst GETARG_Ax = function(i) {\n    return i.Ax;\n};\n\nconst SETARG_Ax = function(i,v) {\n    return setarg(i, v, POS_Ax, SIZE_Ax);\n};\n\nconst GETARG_sBx = function(i) {\n    return i.sBx;\n};\n\nconst SETARG_sBx = function(i, b) {\n    return SETARG_Bx(i, b + MAXARG_sBx);\n};\n\n/*\n** Pre-calculate all possible part of the instruction\n*/\nconst fullins = function(ins) {\n    if (typeof ins === \"number\") {\n        return {\n            code:   ins,\n            opcode: (ins >> POS_OP) & MASK1(SIZE_OP, 0),\n            A:      (ins >> POS_A)  & MASK1(SIZE_A,  0),\n            B:      (ins >> POS_B)  & MASK1(SIZE_B,  0),\n            C:      (ins >> POS_C)  & MASK1(SIZE_C,  0),\n            Bx:     (ins >> POS_Bx) & MASK1(SIZE_Bx, 0),\n            Ax:     (ins >> POS_Ax) & MASK1(SIZE_Ax, 0),\n            sBx:    ((ins >> POS_Bx) & MASK1(SIZE_Bx, 0)) - MAXARG_sBx\n        };\n    } else {\n        let i = ins.code;\n        ins.opcode = (i >> POS_OP) & MASK1(SIZE_OP, 0);\n        ins.A      = (i >> POS_A)  & MASK1(SIZE_A,  0);\n        ins.B      = (i >> POS_B)  & MASK1(SIZE_B,  0);\n        ins.C      = (i >> POS_C)  & MASK1(SIZE_C,  0);\n        ins.Bx     = (i >> POS_Bx) & MASK1(SIZE_Bx, 0);\n        ins.Ax     = (i >> POS_Ax) & MASK1(SIZE_Ax, 0);\n        ins.sBx    = ((i >> POS_Bx) & MASK1(SIZE_Bx, 0)) - MAXARG_sBx;\n        return ins;\n    }\n};\n\nconst CREATE_ABC = function(o, a, b, c) {\n    return fullins(o << POS_OP | a << POS_A | b << POS_B | c << POS_C);\n};\n\nconst CREATE_ABx = function(o, a, bc) {\n    return fullins(o << POS_OP | a << POS_A | bc << POS_Bx);\n};\n\nconst CREATE_Ax = function(o, a) {\n    return fullins(o << POS_OP | a << POS_Ax);\n};\n\n/* number of list items to accumulate before a SETLIST instruction */\nconst LFIELDS_PER_FLUSH = 50;\n\nmodule.exports.BITRK               = BITRK;\nmodule.exports.CREATE_ABC          = CREATE_ABC;\nmodule.exports.CREATE_ABx          = CREATE_ABx;\nmodule.exports.CREATE_Ax           = CREATE_Ax;\nmodule.exports.GET_OPCODE          = GET_OPCODE;\nmodule.exports.GETARG_A            = GETARG_A;\nmodule.exports.GETARG_B            = GETARG_B;\nmodule.exports.GETARG_C            = GETARG_C;\nmodule.exports.GETARG_Bx           = GETARG_Bx;\nmodule.exports.GETARG_Ax           = GETARG_Ax;\nmodule.exports.GETARG_sBx          = GETARG_sBx;\nmodule.exports.INDEXK              = INDEXK;\nmodule.exports.ISK                 = ISK;\nmodule.exports.LFIELDS_PER_FLUSH   = LFIELDS_PER_FLUSH;\nmodule.exports.MAXARG_A            = MAXARG_A;\nmodule.exports.MAXARG_Ax           = MAXARG_Ax;\nmodule.exports.MAXARG_B            = MAXARG_B;\nmodule.exports.MAXARG_Bx           = MAXARG_Bx;\nmodule.exports.MAXARG_C            = MAXARG_C;\nmodule.exports.MAXARG_sBx          = MAXARG_sBx;\nmodule.exports.MAXINDEXRK          = MAXINDEXRK;\nmodule.exports.NO_REG              = NO_REG;\nmodule.exports.OpArgK              = OpArgK;\nmodule.exports.OpArgN              = OpArgN;\nmodule.exports.OpArgR              = OpArgR;\nmodule.exports.OpArgU              = OpArgU;\nmodule.exports.OpCodes             = OpCodes;\nmodule.exports.OpCodesI            = OpCodesI;\nmodule.exports.POS_A               = POS_A;\nmodule.exports.POS_Ax              = POS_Ax;\nmodule.exports.POS_B               = POS_B;\nmodule.exports.POS_Bx              = POS_Bx;\nmodule.exports.POS_C               = POS_C;\nmodule.exports.POS_OP              = POS_OP;\nmodule.exports.RKASK               = RKASK;\nmodule.exports.SETARG_A            = SETARG_A;\nmodule.exports.SETARG_Ax           = SETARG_Ax;\nmodule.exports.SETARG_B            = SETARG_B;\nmodule.exports.SETARG_Bx           = SETARG_Bx;\nmodule.exports.SETARG_C            = SETARG_C;\nmodule.exports.SETARG_sBx          = SETARG_sBx;\nmodule.exports.SET_OPCODE          = SET_OPCODE;\nmodule.exports.SIZE_A              = SIZE_A;\nmodule.exports.SIZE_Ax             = SIZE_Ax;\nmodule.exports.SIZE_B              = SIZE_B;\nmodule.exports.SIZE_Bx             = SIZE_Bx;\nmodule.exports.SIZE_C              = SIZE_C;\nmodule.exports.SIZE_OP             = SIZE_OP;\nmodule.exports.fullins             = fullins;\nmodule.exports.getBMode            = getBMode;\nmodule.exports.getCMode            = getCMode;\nmodule.exports.getOpMode           = getOpMode;\nmodule.exports.iABC                = iABC;\nmodule.exports.iABx                = iABx;\nmodule.exports.iAsBx               = iAsBx;\nmodule.exports.iAx                 = iAx;\nmodule.exports.testAMode           = testAMode;\nmodule.exports.testTMode           = testTMode;\n","\"use strict\";\n\nconst {\n    LUA_VERSION_MAJOR,\n    LUA_VERSION_MINOR\n} = require(\"./lua.js\");\n\nconst LUA_VERSUFFIX = \"_\" + LUA_VERSION_MAJOR + \"_\" + LUA_VERSION_MINOR;\nmodule.exports.LUA_VERSUFFIX = LUA_VERSUFFIX;\n\nmodule.exports.lua_assert = function(c) {};\n\nmodule.exports.luaopen_base = require(\"./lbaselib.js\").luaopen_base;\n\nconst LUA_COLIBNAME = \"coroutine\";\nmodule.exports.LUA_COLIBNAME = LUA_COLIBNAME;\nmodule.exports.luaopen_coroutine = require(\"./lcorolib.js\").luaopen_coroutine;\n\nconst LUA_TABLIBNAME = \"table\";\nmodule.exports.LUA_TABLIBNAME = LUA_TABLIBNAME;\nmodule.exports.luaopen_table = require(\"./ltablib.js\").luaopen_table;\n\nif (typeof process !== \"undefined\") {\n    const LUA_IOLIBNAME = \"io\";\n    module.exports.LUA_IOLIBNAME = LUA_IOLIBNAME;\n    module.exports.luaopen_io = require(\"./liolib.js\").luaopen_io;\n}\n\nconst LUA_OSLIBNAME = \"os\";\nmodule.exports.LUA_OSLIBNAME = LUA_OSLIBNAME;\nmodule.exports.luaopen_os = require(\"./loslib.js\").luaopen_os;\n\nconst LUA_STRLIBNAME = \"string\";\nmodule.exports.LUA_STRLIBNAME = LUA_STRLIBNAME;\nmodule.exports.luaopen_string = require(\"./lstrlib.js\").luaopen_string;\n\nconst LUA_UTF8LIBNAME = \"utf8\";\nmodule.exports.LUA_UTF8LIBNAME = LUA_UTF8LIBNAME;\nmodule.exports.luaopen_utf8 = require(\"./lutf8lib.js\").luaopen_utf8;\n\nconst LUA_BITLIBNAME = \"bit32\";\nmodule.exports.LUA_BITLIBNAME = LUA_BITLIBNAME;\n// module.exports.luaopen_bit32 = require(\"./lbitlib.js\").luaopen_bit32;\n\nconst LUA_MATHLIBNAME = \"math\";\nmodule.exports.LUA_MATHLIBNAME = LUA_MATHLIBNAME;\nmodule.exports.luaopen_math = require(\"./lmathlib.js\").luaopen_math;\n\nconst LUA_DBLIBNAME = \"debug\";\nmodule.exports.LUA_DBLIBNAME = LUA_DBLIBNAME;\nmodule.exports.luaopen_debug = require(\"./ldblib.js\").luaopen_debug;\n\nconst LUA_LOADLIBNAME = \"package\";\nmodule.exports.LUA_LOADLIBNAME = LUA_LOADLIBNAME;\nmodule.exports.luaopen_package = require(\"./loadlib.js\").luaopen_package;\n\nconst LUA_FENGARILIBNAME = \"fengari\";\nmodule.exports.LUA_FENGARILIBNAME = LUA_FENGARILIBNAME;\nmodule.exports.luaopen_fengari = require(\"./fengarilib.js\").luaopen_fengari;\n\nconst linit = require('./linit.js');\nmodule.exports.luaL_openlibs = linit.luaL_openlibs;\n","\"use strict\";\n\nconst {\n    LUA_MULTRET,\n    LUA_OPBNOT,\n    LUA_OPEQ,\n    LUA_OPLE,\n    LUA_OPLT,\n    LUA_OPUNM,\n    LUA_REGISTRYINDEX,\n    LUA_RIDX_GLOBALS,\n    LUA_VERSION_NUM,\n    constant_types: {\n        LUA_NUMTAGS,\n        LUA_TBOOLEAN,\n        LUA_TCCL,\n        LUA_TFUNCTION,\n        LUA_TLCF,\n        LUA_TLCL,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNONE,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR,\n        LUA_TTABLE,\n        LUA_TTHREAD,\n        LUA_TUSERDATA\n    },\n    thread_status: { LUA_OK },\n    from_userstring,\n    to_luastring,\n} = require('./defs.js');\nconst { api_check } = require('./llimits.js');\nconst ldebug    = require('./ldebug.js');\nconst ldo       = require('./ldo.js');\nconst { luaU_dump } = require('./ldump.js');\nconst lfunc     = require('./lfunc.js');\nconst lobject   = require('./lobject.js');\nconst lstate    = require('./lstate.js');\nconst {\n    luaS_bless,\n    luaS_new,\n    luaS_newliteral\n} = require('./lstring.js');\nconst ltm       = require('./ltm.js');\nconst { LUAI_MAXSTACK } = require('./luaconf.js');\nconst lvm       = require('./lvm.js');\nconst ltable    = require('./ltable.js');\nconst { ZIO } = require('./lzio.js');\nconst TValue    = lobject.TValue;\nconst CClosure  = lobject.CClosure;\n\nconst api_incr_top = function(L) {\n    L.top++;\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n};\n\nconst api_checknelems = function(L, n) {\n    api_check(L, n < (L.top - L.ci.funcOff), \"not enough elements in the stack\");\n};\n\nconst fengari_argcheck = function(c) {\n    if (!c) throw TypeError(\"invalid argument\");\n};\n\nconst fengari_argcheckinteger = function(n) {\n    fengari_argcheck(typeof n === \"number\" && (n|0) === n);\n};\n\nconst isvalid = function(o) {\n    return o !== lobject.luaO_nilobject;\n};\n\nconst lua_version = function(L) {\n    if (L === null) return LUA_VERSION_NUM;\n    else return L.l_G.version;\n};\n\nconst lua_atpanic = function(L, panicf) {\n    let old = L.l_G.panic;\n    L.l_G.panic = panicf;\n    return old;\n};\n\nconst lua_atnativeerror = function(L, errorf) {\n    let old = L.l_G.atnativeerror;\n    L.l_G.atnativeerror = errorf;\n    return old;\n};\n\n// Return value for idx on stack\nconst index2addr = function(L, idx) {\n    let ci = L.ci;\n    if (idx > 0) {\n        let o = ci.funcOff + idx;\n        api_check(L, idx <= ci.top - (ci.funcOff + 1), \"unacceptable index\");\n        if (o >= L.top) return lobject.luaO_nilobject;\n        else return L.stack[o];\n    } else if (idx > LUA_REGISTRYINDEX) {\n        api_check(L, idx !== 0 && -idx <= L.top, \"invalid index\");\n        return L.stack[L.top + idx];\n    } else if (idx === LUA_REGISTRYINDEX) {\n        return L.l_G.l_registry;\n    } else { /* upvalues */\n        idx = LUA_REGISTRYINDEX - idx;\n        api_check(L, idx <= lfunc.MAXUPVAL + 1, \"upvalue index too large\");\n        if (ci.func.ttislcf()) /* light C function? */\n            return lobject.luaO_nilobject; /* it has no upvalues */\n        else {\n            return idx <= ci.func.value.nupvalues ? ci.func.value.upvalue[idx - 1] : lobject.luaO_nilobject;\n        }\n    }\n};\n\n// Like index2addr but returns the index on stack; doesn't allow pseudo indices\nconst index2addr_ = function(L, idx) {\n    let ci = L.ci;\n    if (idx > 0) {\n        let o = ci.funcOff + idx;\n        api_check(L, idx <= ci.top - (ci.funcOff + 1), \"unacceptable index\");\n        if (o >= L.top) return null;\n        else return o;\n    } else if (idx > LUA_REGISTRYINDEX) {\n        api_check(L, idx !== 0 && -idx <= L.top, \"invalid index\");\n        return L.top + idx;\n    } else { /* registry or upvalue */\n        throw Error(\"attempt to use pseudo-index\");\n    }\n};\n\nconst lua_checkstack = function(L, n) {\n    let res;\n    let ci = L.ci;\n    api_check(L, n >= 0, \"negative 'n'\");\n    if (L.stack_last - L.top > n) /* stack large enough? */\n        res = true;\n    else { /* no; need to grow stack */\n        let inuse = L.top + lstate.EXTRA_STACK;\n        if (inuse > LUAI_MAXSTACK - n)  /* can grow without overflow? */\n            res = false;  /* no */\n        else { /* try to grow stack */\n            ldo.luaD_growstack(L, n);\n            res = true;\n        }\n    }\n\n    if (res && ci.top < L.top + n)\n        ci.top = L.top + n;  /* adjust frame top */\n\n    return res;\n};\n\nconst lua_xmove = function(from, to, n) {\n    if (from === to) return;\n    api_checknelems(from, n);\n    api_check(from, from.l_G === to.l_G, \"moving among independent states\");\n    api_check(from, to.ci.top - to.top >= n, \"stack overflow\");\n    from.top -= n;\n    for (let i = 0; i < n; i++) {\n        to.stack[to.top] = new lobject.TValue();\n        lobject.setobj2s(to, to.top, from.stack[from.top + i]);\n        delete from.stack[from.top + i];\n        to.top++;\n    }\n};\n\n/*\n** basic stack manipulation\n*/\n\n/*\n** convert an acceptable stack index into an absolute index\n*/\nconst lua_absindex = function(L, idx) {\n    return (idx > 0 || idx <= LUA_REGISTRYINDEX)\n        ? idx\n        : (L.top - L.ci.funcOff) + idx;\n};\n\nconst lua_gettop = function(L) {\n    return L.top - (L.ci.funcOff + 1);\n};\n\nconst lua_pushvalue = function(L, idx) {\n    lobject.pushobj2s(L, index2addr(L, idx));\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n};\n\nconst lua_settop = function(L, idx) {\n    let func = L.ci.funcOff;\n    let newtop;\n    if (idx >= 0) {\n        api_check(L, idx <= L.stack_last - (func + 1), \"new top too large\");\n        newtop = func + 1 + idx;\n    } else {\n        api_check(L, -(idx + 1) <= L.top - (func + 1), \"invalid new top\");\n        newtop = L.top + idx + 1; /* 'subtract' index (index is negative) */\n    }\n    ldo.adjust_top(L, newtop);\n};\n\nconst lua_pop = function(L, n) {\n    lua_settop(L, -n - 1);\n};\n\nconst reverse = function(L, from, to) {\n    for (; from < to; from++, to--) {\n        let fromtv = L.stack[from];\n        let temp = new TValue(fromtv.type, fromtv.value);\n        lobject.setobjs2s(L, from, to);\n        lobject.setobj2s(L, to, temp);\n    }\n};\n\n/*\n** Let x = AB, where A is a prefix of length 'n'. Then,\n** rotate x n === BA. But BA === (A^r . B^r)^r.\n*/\nconst lua_rotate = function(L, idx, n) {\n    let t = L.top - 1;\n    let pIdx = index2addr_(L, idx);\n    let p = L.stack[pIdx];\n    api_check(L, isvalid(p) && idx > LUA_REGISTRYINDEX, \"index not in the stack\");\n    api_check(L, (n >= 0 ? n : -n) <= (t - pIdx + 1), \"invalid 'n'\");\n    let m = n >= 0 ? t - n : pIdx - n - 1;  /* end of prefix */\n    reverse(L, pIdx, m);\n    reverse(L, m + 1, L.top - 1);\n    reverse(L, pIdx, L.top - 1);\n};\n\nconst lua_copy = function(L, fromidx, toidx) {\n    let from = index2addr(L, fromidx);\n    index2addr(L, toidx).setfrom(from);\n};\n\nconst lua_remove = function(L, idx) {\n    lua_rotate(L, idx, -1);\n    lua_pop(L, 1);\n};\n\nconst lua_insert = function(L, idx) {\n    lua_rotate(L, idx, 1);\n};\n\nconst lua_replace = function(L, idx) {\n    lua_copy(L, -1, idx);\n    lua_pop(L, 1);\n};\n\n/*\n** push functions (JS -> stack)\n*/\n\nconst lua_pushnil = function(L) {\n    L.stack[L.top] = new TValue(LUA_TNIL, null);\n    api_incr_top(L);\n};\n\nconst lua_pushnumber = function(L, n) {\n    fengari_argcheck(typeof n === \"number\");\n    L.stack[L.top] = new TValue(LUA_TNUMFLT, n);\n    api_incr_top(L);\n};\n\nconst lua_pushinteger = function(L, n) {\n    fengari_argcheckinteger(n);\n    L.stack[L.top] = new TValue(LUA_TNUMINT, n);\n    api_incr_top(L);\n};\n\nconst lua_pushlstring = function(L, s, len) {\n    fengari_argcheckinteger(len);\n    let ts;\n    if (len === 0) {\n        s = to_luastring(\"\", true);\n        ts = luaS_bless(L, s);\n    } else {\n        s = from_userstring(s);\n        api_check(L, s.length >= len, \"invalid length to lua_pushlstring\");\n        ts = luaS_new(L, s.subarray(0, len));\n    }\n    lobject.pushsvalue2s(L, ts);\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    return ts.value;\n};\n\nconst lua_pushstring = function (L, s) {\n    if (s === undefined || s === null) {\n        L.stack[L.top] = new TValue(LUA_TNIL, null);\n        L.top++;\n    } else {\n        let ts = luaS_new(L, from_userstring(s));\n        lobject.pushsvalue2s(L, ts);\n        s = ts.getstr(); /* internal copy */\n    }\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    return s;\n};\n\nconst lua_pushvfstring = function (L, fmt, argp) {\n    fmt = from_userstring(fmt);\n    return lobject.luaO_pushvfstring(L, fmt, argp);\n};\n\nconst lua_pushfstring = function (L, fmt, ...argp) {\n    fmt = from_userstring(fmt);\n    return lobject.luaO_pushvfstring(L, fmt, argp);\n};\n\n/* Similar to lua_pushstring, but takes a JS string */\nconst lua_pushliteral = function (L, s) {\n    if (s === undefined || s === null) {\n        L.stack[L.top] = new TValue(LUA_TNIL, null);\n        L.top++;\n    } else {\n        fengari_argcheck(typeof s === \"string\");\n        let ts = luaS_newliteral(L, s);\n        lobject.pushsvalue2s(L, ts);\n        s = ts.getstr(); /* internal copy */\n    }\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n\n    return s;\n};\n\nconst lua_pushcclosure = function(L, fn, n) {\n    fengari_argcheck(typeof fn === \"function\");\n    fengari_argcheckinteger(n);\n    if (n === 0)\n        L.stack[L.top] = new TValue(LUA_TLCF, fn);\n    else {\n        api_checknelems(L, n);\n        api_check(L, n <= lfunc.MAXUPVAL, \"upvalue index too large\");\n        let cl = new CClosure(L, fn, n);\n        for (let i=0; i<n; i++)\n            cl.upvalue[i].setfrom(L.stack[L.top - n + i]);\n        for (let i=1; i<n; i++)\n            delete L.stack[--L.top];\n        if (n>0)\n            --L.top;\n        L.stack[L.top].setclCvalue(cl);\n    }\n    api_incr_top(L);\n};\n\nconst lua_pushjsclosure = lua_pushcclosure;\n\nconst lua_pushcfunction = function(L, fn) {\n    lua_pushcclosure(L, fn, 0);\n};\n\nconst lua_pushjsfunction = lua_pushcfunction;\n\nconst lua_pushboolean = function(L, b) {\n    L.stack[L.top] = new TValue(LUA_TBOOLEAN, !!b);\n    api_incr_top(L);\n};\n\nconst lua_pushlightuserdata = function(L, p) {\n    L.stack[L.top] = new TValue(LUA_TLIGHTUSERDATA, p);\n    api_incr_top(L);\n};\n\nconst lua_pushthread = function(L) {\n    L.stack[L.top] = new TValue(LUA_TTHREAD, L);\n    api_incr_top(L);\n    return L.l_G.mainthread === L;\n};\n\nconst lua_pushglobaltable = function(L) {\n    lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS);\n};\n\n/*\n** set functions (stack -> Lua)\n*/\n\n/*\n** t[k] = value at the top of the stack (where 'k' is a string)\n*/\nconst auxsetstr = function(L, t, k) {\n    let str = luaS_new(L, from_userstring(k));\n    api_checknelems(L, 1);\n    lobject.pushsvalue2s(L, str); /* push 'str' (to make it a TValue) */\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    lvm.settable(L, t, L.stack[L.top - 1], L.stack[L.top - 2]);\n    /* pop value and key */\n    delete L.stack[--L.top];\n    delete L.stack[--L.top];\n};\n\nconst lua_setglobal = function(L, name) {\n    auxsetstr(L, ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS), name);\n};\n\nconst lua_setmetatable = function(L, objindex) {\n    api_checknelems(L, 1);\n    let mt;\n    let obj = index2addr(L, objindex);\n    if (L.stack[L.top - 1].ttisnil())\n        mt = null;\n    else {\n        api_check(L, L.stack[L.top - 1].ttistable(), \"table expected\");\n        mt = L.stack[L.top - 1].value;\n    }\n\n    switch (obj.ttnov()) {\n        case LUA_TUSERDATA:\n        case LUA_TTABLE: {\n            obj.value.metatable = mt;\n            break;\n        }\n        default: {\n            L.l_G.mt[obj.ttnov()] = mt;\n            break;\n        }\n    }\n\n    delete L.stack[--L.top];\n    return true;\n};\n\nconst lua_settable = function(L, idx) {\n    api_checknelems(L, 2);\n    let t = index2addr(L, idx);\n    lvm.settable(L, t, L.stack[L.top - 2], L.stack[L.top - 1]);\n    delete L.stack[--L.top];\n    delete L.stack[--L.top];\n};\n\nconst lua_setfield = function(L, idx, k) {\n    auxsetstr(L, index2addr(L, idx), k);\n};\n\nconst lua_seti = function(L, idx, n) {\n    fengari_argcheckinteger(n);\n    api_checknelems(L, 1);\n    let t = index2addr(L, idx);\n    L.stack[L.top] = new TValue(LUA_TNUMINT, n);\n    api_incr_top(L);\n    lvm.settable(L, t, L.stack[L.top - 1], L.stack[L.top - 2]);\n    /* pop value and key */\n    delete L.stack[--L.top];\n    delete L.stack[--L.top];\n};\n\nconst lua_rawset = function(L, idx) {\n    api_checknelems(L, 2);\n    let o = index2addr(L, idx);\n    api_check(L, o.ttistable(), \"table expected\");\n    let k = L.stack[L.top - 2];\n    let v = L.stack[L.top - 1];\n    ltable.luaH_setfrom(L, o.value, k, v);\n    ltable.invalidateTMcache(o.value);\n    delete L.stack[--L.top];\n    delete L.stack[--L.top];\n};\n\nconst lua_rawseti = function(L, idx, n) {\n    fengari_argcheckinteger(n);\n    api_checknelems(L, 1);\n    let o = index2addr(L, idx);\n    api_check(L, o.ttistable(), \"table expected\");\n    ltable.luaH_setint(o.value, n, L.stack[L.top - 1]);\n    delete L.stack[--L.top];\n};\n\nconst lua_rawsetp = function(L, idx, p) {\n    api_checknelems(L, 1);\n    let o = index2addr(L, idx);\n    api_check(L, o.ttistable(), \"table expected\");\n    let k = new TValue(LUA_TLIGHTUSERDATA, p);\n    let v = L.stack[L.top - 1];\n    ltable.luaH_setfrom(L, o.value, k, v);\n    delete L.stack[--L.top];\n};\n\n/*\n** get functions (Lua -> stack)\n*/\n\nconst auxgetstr = function(L, t, k) {\n    let str = luaS_new(L, from_userstring(k));\n    lobject.pushsvalue2s(L, str);\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_rawgeti = function(L, idx, n) {\n    let t = index2addr(L, idx);\n    fengari_argcheckinteger(n);\n    api_check(L, t.ttistable(), \"table expected\");\n    lobject.pushobj2s(L, ltable.luaH_getint(t.value, n));\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_rawgetp = function(L, idx, p) {\n    let t = index2addr(L, idx);\n    api_check(L, t.ttistable(), \"table expected\");\n    let k = new TValue(LUA_TLIGHTUSERDATA, p);\n    lobject.pushobj2s(L, ltable.luaH_get(L, t.value, k));\n    api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_rawget = function(L, idx) {\n    let t = index2addr(L, idx);\n    api_check(L, t.ttistable(t), \"table expected\");\n    lobject.setobj2s(L, L.top - 1, ltable.luaH_get(L, t.value, L.stack[L.top - 1]));\n    return L.stack[L.top - 1].ttnov();\n};\n\n// narray and nrec are mostly useless for this implementation\nconst lua_createtable = function(L, narray, nrec) {\n    let t = new lobject.TValue(LUA_TTABLE, ltable.luaH_new(L));\n    L.stack[L.top] = t;\n    api_incr_top(L);\n};\n\nconst luaS_newudata = function(L, size) {\n    return new lobject.Udata(L, size);\n};\n\nconst lua_newuserdata = function(L, size) {\n    let u = luaS_newudata(L, size);\n    L.stack[L.top] = new lobject.TValue(LUA_TUSERDATA, u);\n    api_incr_top(L);\n    return u.data;\n};\n\nconst aux_upvalue = function(L, fi, n) {\n    fengari_argcheckinteger(n);\n    switch(fi.ttype()) {\n        case LUA_TCCL: {  /* C closure */\n            let f = fi.value;\n            if (!(1 <= n && n <= f.nupvalues)) return null;\n            return {\n                name: to_luastring(\"\", true),\n                val: f.upvalue[n-1]\n            };\n        }\n        case LUA_TLCL: {  /* Lua closure */\n            let f = fi.value;\n            let p = f.p;\n            if (!(1 <= n && n <= p.upvalues.length)) return null;\n            let name = p.upvalues[n-1].name;\n            return {\n                name: name ? name.getstr() : to_luastring(\"(*no name)\", true),\n                val: f.upvals[n-1]\n            };\n        }\n        default: return null;  /* not a closure */\n    }\n};\n\nconst lua_getupvalue = function(L, funcindex, n) {\n    let up = aux_upvalue(L, index2addr(L, funcindex), n);\n    if (up) {\n        let name = up.name;\n        let val = up.val;\n        lobject.pushobj2s(L, val);\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n        return name;\n    }\n    return null;\n};\n\nconst lua_setupvalue = function(L, funcindex, n) {\n    let fi = index2addr(L, funcindex);\n    api_checknelems(L, 1);\n    let aux = aux_upvalue(L, fi, n);\n    if (aux) {\n        let name = aux.name;\n        let val = aux.val;\n        val.setfrom(L.stack[L.top-1]);\n        delete L.stack[--L.top];\n        return name;\n    }\n    return null;\n};\n\nconst lua_newtable = function(L) {\n    lua_createtable(L, 0, 0);\n};\n\nconst lua_register = function(L, n, f) {\n    lua_pushcfunction(L, f);\n    lua_setglobal(L, n);\n};\n\nconst lua_getmetatable = function(L, objindex) {\n    let obj = index2addr(L, objindex);\n    let mt;\n    let res = false;\n    switch (obj.ttnov()) {\n        case LUA_TTABLE:\n        case LUA_TUSERDATA:\n            mt = obj.value.metatable;\n            break;\n        default:\n            mt = L.l_G.mt[obj.ttnov()];\n            break;\n    }\n\n    if (mt !== null && mt !== undefined) {\n        L.stack[L.top] = new TValue(LUA_TTABLE, mt);\n        api_incr_top(L);\n        res = true;\n    }\n\n    return res;\n};\n\nconst lua_getuservalue = function(L, idx) {\n    let o = index2addr(L, idx);\n    api_check(L, o.ttisfulluserdata(), \"full userdata expected\");\n    let uv = o.value.uservalue;\n    L.stack[L.top] = new TValue(uv.type, uv.value);\n    api_incr_top(L);\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_gettable = function(L, idx) {\n    let t = index2addr(L, idx);\n    lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_getfield = function(L, idx, k) {\n    return auxgetstr(L, index2addr(L, idx), k);\n};\n\nconst lua_geti = function(L, idx, n) {\n    let t = index2addr(L, idx);\n    fengari_argcheckinteger(n);\n    L.stack[L.top] = new TValue(LUA_TNUMINT, n);\n    api_incr_top(L);\n    lvm.luaV_gettable(L, t, L.stack[L.top - 1], L.top - 1);\n    return L.stack[L.top - 1].ttnov();\n};\n\nconst lua_getglobal = function(L, name) {\n    return auxgetstr(L, ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS), name);\n};\n\n/*\n** access functions (stack -> JS)\n*/\n\nconst lua_toboolean = function(L, idx) {\n    let o = index2addr(L, idx);\n    return !o.l_isfalse();\n};\n\nconst lua_tolstring = function(L, idx) {\n    let o = index2addr(L, idx);\n\n    if (!o.ttisstring()) {\n        if (!lvm.cvt2str(o)) {  /* not convertible? */\n            return null;\n        }\n        lobject.luaO_tostring(L, o);\n    }\n    return o.svalue();\n};\n\nconst lua_tostring =  lua_tolstring;\n\nconst lua_tojsstring = function(L, idx) {\n    let o = index2addr(L, idx);\n\n    if (!o.ttisstring()) {\n        if (!lvm.cvt2str(o)) {  /* not convertible? */\n            return null;\n        }\n        lobject.luaO_tostring(L, o);\n    }\n    return o.jsstring();\n};\n\nconst lua_todataview = function(L, idx) {\n    let u8 = lua_tolstring(L, idx);\n    return new DataView(u8.buffer, u8.byteOffset, u8.byteLength);\n};\n\nconst lua_rawlen = function(L, idx) {\n    let o = index2addr(L, idx);\n    switch (o.ttype()) {\n        case LUA_TSHRSTR:\n        case LUA_TLNGSTR:\n            return o.vslen();\n        case LUA_TUSERDATA:\n            return o.value.len;\n        case LUA_TTABLE:\n            return ltable.luaH_getn(o.value);\n        default:\n            return 0;\n    }\n};\n\nconst lua_tocfunction = function(L, idx) {\n    let o = index2addr(L, idx);\n    if (o.ttislcf() || o.ttisCclosure()) return o.value;\n    else return null;  /* not a C function */\n};\n\nconst lua_tointeger = function(L, idx) {\n    let n = lua_tointegerx(L, idx);\n    return n === false ? 0 : n;\n};\n\nconst lua_tointegerx = function(L, idx) {\n    return lvm.tointeger(index2addr(L, idx));\n};\n\nconst lua_tonumber = function(L, idx) {\n    let n = lua_tonumberx(L, idx);\n    return n === false ? 0 : n;\n};\n\nconst lua_tonumberx = function(L, idx) {\n    return lvm.tonumber(index2addr(L, idx));\n};\n\nconst lua_touserdata = function(L, idx) {\n    let o = index2addr(L, idx);\n    switch (o.ttnov()) {\n        case LUA_TUSERDATA:\n            return o.value.data;\n        case LUA_TLIGHTUSERDATA:\n            return o.value;\n        default: return null;\n    }\n};\n\nconst lua_tothread = function(L, idx) {\n    let o = index2addr(L, idx);\n    return o.ttisthread() ? o.value : null;\n};\n\nconst lua_topointer = function(L, idx) {\n    let o = index2addr(L, idx);\n    switch (o.ttype()) {\n        case LUA_TTABLE:\n        case LUA_TLCL:\n        case LUA_TCCL:\n        case LUA_TLCF:\n        case LUA_TTHREAD:\n        case LUA_TUSERDATA: /* note: this differs in behaviour to reference lua implementation */\n        case LUA_TLIGHTUSERDATA:\n            return o.value;\n        default:\n            return null;\n    }\n};\n\n\n/* A proxy is a function that the same lua value to the given lua state. */\n\n/* Having a weakmap of created proxies was only way I could think of to provide an 'isproxy' function */\nconst seen = new WeakMap();\n\n/* is the passed object a proxy? is it from the given state? (if passed) */\nconst lua_isproxy = function(p, L) {\n    let G = seen.get(p);\n    if (!G)\n        return false;\n    return (L === null) || (L.l_G === G);\n};\n\n/* Use 'create_proxy' helper function so that 'L' is not in scope */\nconst create_proxy = function(G, type, value) {\n    let proxy = function(L) {\n        api_check(L, L instanceof lstate.lua_State && G === L.l_G, \"must be from same global state\");\n        L.stack[L.top] = new TValue(type, value);\n        api_incr_top(L);\n    };\n    seen.set(proxy, G);\n    return proxy;\n};\n\nconst lua_toproxy = function(L, idx) {\n    let tv = index2addr(L, idx);\n    /* pass broken down tv incase it is an upvalue index */\n    return create_proxy(L.l_G, tv.type, tv.value);\n};\n\n\nconst lua_compare = function(L, index1, index2, op) {\n    let o1 = index2addr(L, index1);\n    let o2 = index2addr(L, index2);\n\n    let i = 0;\n\n    if (isvalid(o1) && isvalid(o2)) {\n        switch (op) {\n            case LUA_OPEQ: i = lvm.luaV_equalobj(L, o1, o2); break;\n            case LUA_OPLT: i = lvm.luaV_lessthan(L, o1, o2); break;\n            case LUA_OPLE: i = lvm.luaV_lessequal(L, o1, o2); break;\n            default: api_check(L, false, \"invalid option\");\n        }\n    }\n\n    return i;\n};\n\nconst lua_stringtonumber = function(L, s) {\n    let tv = new TValue();\n    let sz = lobject.luaO_str2num(s, tv);\n    if (sz !== 0) {\n        L.stack[L.top] = tv;\n        api_incr_top(L);\n    }\n    return sz;\n};\n\nconst f_call = function(L, ud) {\n    ldo.luaD_callnoyield(L, ud.funcOff, ud.nresults);\n};\n\nconst lua_type = function(L, idx) {\n    let o = index2addr(L, idx);\n    return isvalid(o) ?  o.ttnov() : LUA_TNONE;\n};\n\nconst lua_typename = function(L, t) {\n    api_check(L, LUA_TNONE <= t && t < LUA_NUMTAGS, \"invalid tag\");\n    return ltm.ttypename(t);\n};\n\nconst lua_iscfunction = function(L, idx) {\n    let o = index2addr(L, idx);\n    return o.ttislcf(o) || o.ttisCclosure();\n};\n\nconst lua_isnil = function(L, n) {\n    return lua_type(L, n) === LUA_TNIL;\n};\n\nconst lua_isboolean = function(L, n) {\n    return lua_type(L, n) === LUA_TBOOLEAN;\n};\n\nconst lua_isnone = function(L, n) {\n    return lua_type(L, n) === LUA_TNONE;\n};\n\nconst lua_isnoneornil = function(L, n) {\n    return lua_type(L, n) <= 0;\n};\n\nconst lua_istable = function(L, idx) {\n    return index2addr(L, idx).ttistable();\n};\n\nconst lua_isinteger = function(L, idx) {\n    return index2addr(L, idx).ttisinteger();\n};\n\nconst lua_isnumber = function(L, idx) {\n    return lvm.tonumber(index2addr(L, idx)) !== false;\n};\n\nconst lua_isstring = function(L, idx) {\n    let o = index2addr(L, idx);\n    return o.ttisstring() || lvm.cvt2str(o);\n};\n\nconst lua_isuserdata = function(L, idx) {\n    let o = index2addr(L, idx);\n    return o.ttisfulluserdata(o) || o.ttislightuserdata();\n};\n\nconst lua_isthread = function(L, idx) {\n    return lua_type(L, idx) === LUA_TTHREAD;\n};\n\nconst lua_isfunction = function(L, idx) {\n    return lua_type(L, idx) === LUA_TFUNCTION;\n};\n\nconst lua_islightuserdata = function(L, idx) {\n    return lua_type(L, idx) === LUA_TLIGHTUSERDATA;\n};\n\nconst lua_rawequal = function(L, index1, index2) {\n    let o1 = index2addr(L, index1);\n    let o2 = index2addr(L, index2);\n    return isvalid(o1) && isvalid(o2) ? lvm.luaV_equalobj(null, o1, o2) : 0;\n};\n\nconst lua_arith = function(L, op) {\n    if (op !== LUA_OPUNM && op !== LUA_OPBNOT)\n        api_checknelems(L, 2);  /* all other operations expect two operands */\n    else {  /* for unary operations, add fake 2nd operand */\n        api_checknelems(L, 1);\n        lobject.pushobj2s(L, L.stack[L.top-1]);\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    }\n    /* first operand at top - 2, second at top - 1; result go to top - 2 */\n    lobject.luaO_arith(L, op, L.stack[L.top - 2], L.stack[L.top - 1], L.stack[L.top - 2]);\n    delete L.stack[--L.top];  /* remove second operand */\n};\n\n/*\n** 'load' and 'call' functions (run Lua code)\n*/\n\nconst default_chunkname = to_luastring(\"?\");\nconst lua_load = function(L, reader, data, chunkname, mode) {\n    if (!chunkname) chunkname = default_chunkname;\n    else chunkname = from_userstring(chunkname);\n    if (mode !== null) mode = from_userstring(mode);\n    let z = new ZIO(L, reader, data);\n    let status = ldo.luaD_protectedparser(L, z, chunkname, mode);\n    if (status === LUA_OK) {  /* no errors? */\n        let f = L.stack[L.top - 1].value; /* get newly created function */\n        if (f.nupvalues >= 1) {  /* does it have an upvalue? */\n            /* get global table from registry */\n            let gt = ltable.luaH_getint(L.l_G.l_registry.value, LUA_RIDX_GLOBALS);\n            /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */\n            f.upvals[0].setfrom(gt);\n        }\n    }\n    return status;\n};\n\nconst lua_dump = function(L, writer, data, strip) {\n    api_checknelems(L, 1);\n    let o = L.stack[L.top -1];\n    if (o.ttisLclosure())\n        return luaU_dump(L, o.value.p, writer, data, strip);\n    return 1;\n};\n\nconst lua_status = function(L) {\n    return L.status;\n};\n\nconst lua_setuservalue = function(L, idx) {\n    api_checknelems(L, 1);\n    let o = index2addr(L, idx);\n    api_check(L, o.ttisfulluserdata(), \"full userdata expected\");\n    o.value.uservalue.setfrom(L.stack[L.top - 1]);\n    delete L.stack[--L.top];\n};\n\nconst checkresults = function(L,na,nr) {\n    api_check(L, nr === LUA_MULTRET || (L.ci.top - L.top >= (nr) - (na)),\n        \"results from function overflow current stack size\");\n};\n\nconst lua_callk = function(L, nargs, nresults, ctx, k) {\n    api_check(L, k === null || !(L.ci.callstatus & lstate.CIST_LUA), \"cannot use continuations inside hooks\");\n    api_checknelems(L, nargs + 1);\n    api_check(L, L.status === LUA_OK, \"cannot do calls on non-normal thread\");\n    checkresults(L, nargs, nresults);\n    let func = L.top - (nargs + 1);\n    if (k !== null && L.nny === 0) { /* need to prepare continuation? */\n        L.ci.c_k = k;\n        L.ci.c_ctx = ctx;\n        ldo.luaD_call(L, func, nresults);\n    } else { /* no continuation or no yieldable */\n        ldo.luaD_callnoyield(L, func, nresults);\n    }\n\n    if (nresults === LUA_MULTRET && L.ci.top < L.top)\n        L.ci.top = L.top;\n};\n\nconst lua_call = function(L, n, r) {\n    lua_callk(L, n, r, 0, null);\n};\n\nconst lua_pcallk = function(L, nargs, nresults, errfunc, ctx, k) {\n    api_check(L, k === null || !(L.ci.callstatus & lstate.CIST_LUA), \"cannot use continuations inside hooks\");\n    api_checknelems(L, nargs + 1);\n    api_check(L, L.status === LUA_OK, \"cannot do calls on non-normal thread\");\n    checkresults(L, nargs, nresults);\n    let status;\n    let func;\n    if (errfunc === 0)\n        func = 0;\n    else {\n        func = index2addr_(L, errfunc);\n    }\n    let funcOff = L.top - (nargs + 1); /* function to be called */\n    if (k === null || L.nny > 0) { /* no continuation or no yieldable? */\n        let c = {\n            funcOff: funcOff,\n            nresults: nresults /* do a 'conventional' protected call */\n        };\n        status = ldo.luaD_pcall(L, f_call, c, funcOff, func);\n    } else { /* prepare continuation (call is already protected by 'resume') */\n        let ci = L.ci;\n        ci.c_k = k;  /* prepare continuation (call is already protected by 'resume') */\n        ci.c_ctx = ctx;  /* prepare continuation (call is already protected by 'resume') */\n        /* save information for error recovery */\n        ci.extra = funcOff;\n        ci.c_old_errfunc = L.errfunc;\n        L.errfunc = func;\n        ci.callstatus &= ~lstate.CIST_OAH | L.allowhook;\n        ci.callstatus |= lstate.CIST_YPCALL;  /* function can do error recovery */\n        ldo.luaD_call(L, funcOff, nresults);  /* do the call */\n        ci.callstatus &= ~lstate.CIST_YPCALL;\n        L.errfunc = ci.c_old_errfunc;\n        status = LUA_OK;\n    }\n\n    if (nresults === LUA_MULTRET && L.ci.top < L.top)\n        L.ci.top = L.top;\n\n    return status;\n};\n\nconst lua_pcall = function(L, n, r, f) {\n    return lua_pcallk(L, n, r, f, 0, null);\n};\n\n/*\n** miscellaneous functions\n*/\n\nconst lua_error = function(L) {\n    api_checknelems(L, 1);\n    ldebug.luaG_errormsg(L);\n};\n\nconst lua_next = function(L, idx) {\n    let t = index2addr(L, idx);\n    api_check(L, t.ttistable(), \"table expected\");\n    L.stack[L.top] = new TValue();\n    let more = ltable.luaH_next(L, t.value, L.top - 1);\n    if (more) {\n        api_incr_top(L);\n        return 1;\n    } else {\n        delete L.stack[L.top];\n        delete L.stack[--L.top];\n        return 0;\n    }\n};\n\nconst lua_concat = function(L, n) {\n    api_checknelems(L, n);\n    if (n >= 2)\n        lvm.luaV_concat(L, n);\n    else if (n === 0) {\n        lobject.pushsvalue2s(L, luaS_bless(L, to_luastring(\"\", true)));\n        api_check(L, L.top <= L.ci.top, \"stack overflow\");\n    }\n};\n\nconst lua_len = function(L, idx) {\n    let t = index2addr(L, idx);\n    let tv = new TValue();\n    lvm.luaV_objlen(L, tv, t);\n    L.stack[L.top] = tv;\n    api_incr_top(L);\n};\n\nconst getupvalref = function(L, fidx, n) {\n    let fi = index2addr(L, fidx);\n    api_check(L, fi.ttisLclosure(), \"Lua function expected\");\n    let f = fi.value;\n    fengari_argcheckinteger(n);\n    api_check(L, 1 <= n && n <= f.p.upvalues.length, \"invalid upvalue index\");\n    return {\n        f: f,\n        i: n - 1\n    };\n};\n\nconst lua_upvalueid = function(L, fidx, n) {\n    let fi = index2addr(L, fidx);\n    switch (fi.ttype()) {\n        case LUA_TLCL: {  /* lua closure */\n            let ref = getupvalref(L, fidx, n);\n            return ref.f.upvals[ref.i];\n        }\n        case LUA_TCCL: {  /* C closure */\n            let f = fi.value;\n            api_check(L, (n|0) === n && n > 0 && n <= f.nupvalues, \"invalid upvalue index\");\n            return f.upvalue[n - 1];\n        }\n        default: {\n            api_check(L, false, \"closure expected\");\n            return null;\n        }\n    }\n};\n\nconst lua_upvaluejoin = function(L, fidx1, n1, fidx2, n2) {\n    let ref1 = getupvalref(L, fidx1, n1);\n    let ref2 = getupvalref(L, fidx2, n2);\n    let up2 = ref2.f.upvals[ref2.i];\n    ref1.f.upvals[ref1.i] = up2;\n};\n\n// This functions are only there for compatibility purposes\nconst lua_gc = function () {};\n\nconst lua_getallocf = function () {\n    console.warn(\"lua_getallocf is not available\");\n    return 0;\n};\n\nconst lua_setallocf = function () {\n    console.warn(\"lua_setallocf is not available\");\n    return 0;\n};\n\nconst lua_getextraspace = function () {\n    console.warn(\"lua_getextraspace is not available\");\n    return 0;\n};\n\nmodule.exports.api_incr_top          = api_incr_top;\nmodule.exports.api_checknelems       = api_checknelems;\nmodule.exports.lua_absindex          = lua_absindex;\nmodule.exports.lua_arith             = lua_arith;\nmodule.exports.lua_atpanic           = lua_atpanic;\nmodule.exports.lua_atnativeerror     = lua_atnativeerror;\nmodule.exports.lua_call              = lua_call;\nmodule.exports.lua_callk             = lua_callk;\nmodule.exports.lua_checkstack        = lua_checkstack;\nmodule.exports.lua_compare           = lua_compare;\nmodule.exports.lua_concat            = lua_concat;\nmodule.exports.lua_copy              = lua_copy;\nmodule.exports.lua_createtable       = lua_createtable;\nmodule.exports.lua_dump              = lua_dump;\nmodule.exports.lua_error             = lua_error;\nmodule.exports.lua_gc                = lua_gc;\nmodule.exports.lua_getallocf         = lua_getallocf;\nmodule.exports.lua_getextraspace     = lua_getextraspace;\nmodule.exports.lua_getfield          = lua_getfield;\nmodule.exports.lua_getglobal         = lua_getglobal;\nmodule.exports.lua_geti              = lua_geti;\nmodule.exports.lua_getmetatable      = lua_getmetatable;\nmodule.exports.lua_gettable          = lua_gettable;\nmodule.exports.lua_gettop            = lua_gettop;\nmodule.exports.lua_getupvalue        = lua_getupvalue;\nmodule.exports.lua_getuservalue      = lua_getuservalue;\nmodule.exports.lua_insert            = lua_insert;\nmodule.exports.lua_isboolean         = lua_isboolean;\nmodule.exports.lua_iscfunction       = lua_iscfunction;\nmodule.exports.lua_isfunction        = lua_isfunction;\nmodule.exports.lua_isinteger         = lua_isinteger;\nmodule.exports.lua_islightuserdata   = lua_islightuserdata;\nmodule.exports.lua_isnil             = lua_isnil;\nmodule.exports.lua_isnone            = lua_isnone;\nmodule.exports.lua_isnoneornil       = lua_isnoneornil;\nmodule.exports.lua_isnumber          = lua_isnumber;\nmodule.exports.lua_isproxy           = lua_isproxy;\nmodule.exports.lua_isstring          = lua_isstring;\nmodule.exports.lua_istable           = lua_istable;\nmodule.exports.lua_isthread          = lua_isthread;\nmodule.exports.lua_isuserdata        = lua_isuserdata;\nmodule.exports.lua_len               = lua_len;\nmodule.exports.lua_load              = lua_load;\nmodule.exports.lua_newtable          = lua_newtable;\nmodule.exports.lua_newuserdata       = lua_newuserdata;\nmodule.exports.lua_next              = lua_next;\nmodule.exports.lua_pcall             = lua_pcall;\nmodule.exports.lua_pcallk            = lua_pcallk;\nmodule.exports.lua_pop               = lua_pop;\nmodule.exports.lua_pushboolean       = lua_pushboolean;\nmodule.exports.lua_pushcclosure      = lua_pushcclosure;\nmodule.exports.lua_pushcfunction     = lua_pushcfunction;\nmodule.exports.lua_pushfstring       = lua_pushfstring;\nmodule.exports.lua_pushglobaltable   = lua_pushglobaltable;\nmodule.exports.lua_pushinteger       = lua_pushinteger;\nmodule.exports.lua_pushjsclosure     = lua_pushjsclosure;\nmodule.exports.lua_pushjsfunction    = lua_pushjsfunction;\nmodule.exports.lua_pushlightuserdata = lua_pushlightuserdata;\nmodule.exports.lua_pushliteral       = lua_pushliteral;\nmodule.exports.lua_pushlstring       = lua_pushlstring;\nmodule.exports.lua_pushnil           = lua_pushnil;\nmodule.exports.lua_pushnumber        = lua_pushnumber;\nmodule.exports.lua_pushstring        = lua_pushstring;\nmodule.exports.lua_pushthread        = lua_pushthread;\nmodule.exports.lua_pushvalue         = lua_pushvalue;\nmodule.exports.lua_pushvfstring      = lua_pushvfstring;\nmodule.exports.lua_rawequal          = lua_rawequal;\nmodule.exports.lua_rawget            = lua_rawget;\nmodule.exports.lua_rawgeti           = lua_rawgeti;\nmodule.exports.lua_rawgetp           = lua_rawgetp;\nmodule.exports.lua_rawlen            = lua_rawlen;\nmodule.exports.lua_rawset            = lua_rawset;\nmodule.exports.lua_rawseti           = lua_rawseti;\nmodule.exports.lua_rawsetp           = lua_rawsetp;\nmodule.exports.lua_register          = lua_register;\nmodule.exports.lua_remove            = lua_remove;\nmodule.exports.lua_replace           = lua_replace;\nmodule.exports.lua_rotate            = lua_rotate;\nmodule.exports.lua_setallocf         = lua_setallocf;\nmodule.exports.lua_setfield          = lua_setfield;\nmodule.exports.lua_setglobal         = lua_setglobal;\nmodule.exports.lua_seti              = lua_seti;\nmodule.exports.lua_setmetatable      = lua_setmetatable;\nmodule.exports.lua_settable          = lua_settable;\nmodule.exports.lua_settop            = lua_settop;\nmodule.exports.lua_setupvalue        = lua_setupvalue;\nmodule.exports.lua_setuservalue      = lua_setuservalue;\nmodule.exports.lua_status            = lua_status;\nmodule.exports.lua_stringtonumber    = lua_stringtonumber;\nmodule.exports.lua_toboolean         = lua_toboolean;\nmodule.exports.lua_tocfunction       = lua_tocfunction;\nmodule.exports.lua_todataview        = lua_todataview;\nmodule.exports.lua_tointeger         = lua_tointeger;\nmodule.exports.lua_tointegerx        = lua_tointegerx;\nmodule.exports.lua_tojsstring        = lua_tojsstring;\nmodule.exports.lua_tolstring         = lua_tolstring;\nmodule.exports.lua_tonumber          = lua_tonumber;\nmodule.exports.lua_tonumberx         = lua_tonumberx;\nmodule.exports.lua_topointer         = lua_topointer;\nmodule.exports.lua_toproxy           = lua_toproxy;\nmodule.exports.lua_tostring          = lua_tostring;\nmodule.exports.lua_tothread          = lua_tothread;\nmodule.exports.lua_touserdata        = lua_touserdata;\nmodule.exports.lua_type              = lua_type;\nmodule.exports.lua_typename          = lua_typename;\nmodule.exports.lua_upvalueid         = lua_upvalueid;\nmodule.exports.lua_upvaluejoin       = lua_upvaluejoin;\nmodule.exports.lua_version           = lua_version;\nmodule.exports.lua_xmove             = lua_xmove;\n","\"use strict\";\n\nconst { lua_assert } = require(\"./llimits.js\");\n\nclass MBuffer {\n    constructor() {\n        this.buffer = null;\n        this.n = 0;\n    }\n}\n\nconst luaZ_buffer = function(buff) {\n    return buff.buffer.subarray(0, buff.n);\n};\n\nconst luaZ_buffremove = function(buff, i) {\n    buff.n -= i;\n};\n\nconst luaZ_resetbuffer = function(buff) {\n    buff.n = 0;\n};\n\nconst luaZ_resizebuffer = function(L, buff, size) {\n    let newbuff = new Uint8Array(size);\n    if (buff.buffer)\n        newbuff.set(buff.buffer);\n    buff.buffer = newbuff;\n};\n\nclass ZIO {\n    constructor(L, reader, data) {\n        this.L = L;           /* Lua state (for reader) */\n        lua_assert(typeof reader == \"function\", \"ZIO requires a reader\");\n        this.reader = reader; /* reader function */\n        this.data = data;     /* additional data */\n        this.n = 0;           /* bytes still unread */\n        this.buffer = null;\n        this.off = 0;         /* current position in buffer */\n    }\n\n    zgetc () {\n        return ((this.n--) > 0) ? this.buffer[this.off++] : luaZ_fill(this);\n    }\n}\n\nconst EOZ = -1;\n\nconst luaZ_fill = function(z) {\n    let buff = z.reader(z.L, z.data);\n    if (buff === null)\n        return EOZ;\n    lua_assert(buff instanceof Uint8Array, \"Should only load binary of array of bytes\");\n    let size = buff.length;\n    if (size === 0)\n        return EOZ;\n    z.buffer = buff;\n    z.off = 0;\n    z.n = size - 1;\n    return z.buffer[z.off++];\n};\n\n/* b should be an array-like that will be set to bytes\n * b_offset is the offset at which to start filling */\nconst luaZ_read = function(z, b, b_offset, n) {\n    while (n) {\n        if (z.n === 0) { /* no bytes in buffer? */\n            if (luaZ_fill(z) === EOZ)\n                return n; /* no more input; return number of missing bytes */\n            else {\n                z.n++;  /* luaZ_fill consumed first byte; put it back */\n                z.off--;\n            }\n        }\n        let m = (n <= z.n) ? n : z.n; /* min. between n and z->n */\n        for (let i=0; i<m; i++) {\n            b[b_offset++] = z.buffer[z.off++];\n        }\n        z.n -= m;\n        if (z.n === 0) // remove reference to input so it can get freed\n            z.buffer = null;\n        n -= m;\n    }\n\n    return 0;\n};\n\nmodule.exports.EOZ               = EOZ;\nmodule.exports.luaZ_buffer       = luaZ_buffer;\nmodule.exports.luaZ_buffremove   = luaZ_buffremove;\nmodule.exports.luaZ_fill         = luaZ_fill;\nmodule.exports.luaZ_read         = luaZ_read;\nmodule.exports.luaZ_resetbuffer  = luaZ_resetbuffer;\nmodule.exports.luaZ_resizebuffer = luaZ_resizebuffer;\nmodule.exports.MBuffer           = MBuffer;\nmodule.exports.ZIO               = ZIO;\n","\"use strict\";\n\nconst {\n    constant_types: { LUA_TBOOLEAN, LUA_TLNGSTR },\n    thread_status: { LUA_ERRSYNTAX },\n    to_luastring\n} = require('./defs.js');\nconst {\n    LUA_MINBUFFER,\n    MAX_INT,\n    lua_assert\n} = require('./llimits.js');\nconst ldebug   = require('./ldebug.js');\nconst ldo      = require('./ldo.js');\nconst {\n    lisdigit,\n    lislalnum,\n    lislalpha,\n    lisspace,\n    lisxdigit\n} = require('./ljstype.js');\nconst lobject  = require('./lobject.js');\nconst {\n    luaS_bless,\n    luaS_hash,\n    luaS_hashlongstr,\n    luaS_new\n} = require('./lstring.js');\nconst ltable   = require('./ltable.js');\nconst {\n    EOZ,\n    luaZ_buffer,\n    luaZ_buffremove,\n    luaZ_resetbuffer,\n    luaZ_resizebuffer\n} = require('./lzio.js');\n\nconst FIRST_RESERVED = 257;\n\nconst LUA_ENV = to_luastring(\"_ENV\", true);\n\n/* terminal symbols denoted by reserved words */\nconst TK_AND      = FIRST_RESERVED;\nconst TK_BREAK    = FIRST_RESERVED + 1;\nconst TK_DO       = FIRST_RESERVED + 2;\nconst TK_ELSE     = FIRST_RESERVED + 3;\nconst TK_ELSEIF   = FIRST_RESERVED + 4;\nconst TK_END      = FIRST_RESERVED + 5;\nconst TK_FALSE    = FIRST_RESERVED + 6;\nconst TK_FOR      = FIRST_RESERVED + 7;\nconst TK_FUNCTION = FIRST_RESERVED + 8;\nconst TK_GOTO     = FIRST_RESERVED + 9;\nconst TK_IF       = FIRST_RESERVED + 10;\nconst TK_IN       = FIRST_RESERVED + 11;\nconst TK_LOCAL    = FIRST_RESERVED + 12;\nconst TK_NIL      = FIRST_RESERVED + 13;\nconst TK_NOT      = FIRST_RESERVED + 14;\nconst TK_OR       = FIRST_RESERVED + 15;\nconst TK_REPEAT   = FIRST_RESERVED + 16;\nconst TK_RETURN   = FIRST_RESERVED + 17;\nconst TK_THEN     = FIRST_RESERVED + 18;\nconst TK_TRUE     = FIRST_RESERVED + 19;\nconst TK_UNTIL    = FIRST_RESERVED + 20;\nconst TK_WHILE    = FIRST_RESERVED + 21;\n/* other terminal symbols */\nconst TK_IDIV     = FIRST_RESERVED + 22;\nconst TK_CONCAT   = FIRST_RESERVED + 23;\nconst TK_DOTS     = FIRST_RESERVED + 24;\nconst TK_EQ       = FIRST_RESERVED + 25;\nconst TK_GE       = FIRST_RESERVED + 26;\nconst TK_LE       = FIRST_RESERVED + 27;\nconst TK_NE       = FIRST_RESERVED + 28;\nconst TK_SHL      = FIRST_RESERVED + 29;\nconst TK_SHR      = FIRST_RESERVED + 30;\nconst TK_DBCOLON  = FIRST_RESERVED + 31;\nconst TK_EOS      = FIRST_RESERVED + 32;\nconst TK_FLT      = FIRST_RESERVED + 33;\nconst TK_INT      = FIRST_RESERVED + 34;\nconst TK_NAME     = FIRST_RESERVED + 35;\nconst TK_STRING   = FIRST_RESERVED + 36;\n\nconst RESERVED = {\n    \"TK_AND\":      TK_AND,\n    \"TK_BREAK\":    TK_BREAK,\n    \"TK_DO\":       TK_DO,\n    \"TK_ELSE\":     TK_ELSE,\n    \"TK_ELSEIF\":   TK_ELSEIF,\n    \"TK_END\":      TK_END,\n    \"TK_FALSE\":    TK_FALSE,\n    \"TK_FOR\":      TK_FOR,\n    \"TK_FUNCTION\": TK_FUNCTION,\n    \"TK_GOTO\":     TK_GOTO,\n    \"TK_IF\":       TK_IF,\n    \"TK_IN\":       TK_IN,\n    \"TK_LOCAL\":    TK_LOCAL,\n    \"TK_NIL\":      TK_NIL,\n    \"TK_NOT\":      TK_NOT,\n    \"TK_OR\":       TK_OR,\n    \"TK_REPEAT\":   TK_REPEAT,\n    \"TK_RETURN\":   TK_RETURN,\n    \"TK_THEN\":     TK_THEN,\n    \"TK_TRUE\":     TK_TRUE,\n    \"TK_UNTIL\":    TK_UNTIL,\n    \"TK_WHILE\":    TK_WHILE,\n    \"TK_IDIV\":     TK_IDIV,\n    \"TK_CONCAT\":   TK_CONCAT,\n    \"TK_DOTS\":     TK_DOTS,\n    \"TK_EQ\":       TK_EQ,\n    \"TK_GE\":       TK_GE,\n    \"TK_LE\":       TK_LE,\n    \"TK_NE\":       TK_NE,\n    \"TK_SHL\":      TK_SHL,\n    \"TK_SHR\":      TK_SHR,\n    \"TK_DBCOLON\":  TK_DBCOLON,\n    \"TK_EOS\":      TK_EOS,\n    \"TK_FLT\":      TK_FLT,\n    \"TK_INT\":      TK_INT,\n    \"TK_NAME\":     TK_NAME,\n    \"TK_STRING\":   TK_STRING\n};\n\nconst luaX_tokens = [\n    \"and\", \"break\", \"do\", \"else\", \"elseif\",\n    \"end\", \"false\", \"for\", \"function\", \"goto\", \"if\",\n    \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\",\n    \"return\", \"then\", \"true\", \"until\", \"while\",\n    \"//\", \"..\", \"...\", \"==\", \">=\", \"<=\", \"~=\",\n    \"<<\", \">>\", \"::\", \"<eof>\",\n    \"<number>\", \"<integer>\", \"<name>\", \"<string>\"\n].map((e, i)=>to_luastring(e));\n\nclass SemInfo {\n    constructor() {\n        this.r = NaN;\n        this.i = NaN;\n        this.ts = null;\n    }\n}\n\nclass Token {\n    constructor() {\n        this.token = NaN;\n        this.seminfo = new SemInfo();\n    }\n}\n\n/* state of the lexer plus state of the parser when shared by all\n   functions */\nclass LexState {\n    constructor() {\n        this.current = NaN;  /* current character (charint) */\n        this.linenumber = NaN;  /* input line counter */\n        this.lastline = NaN;  /* line of last token 'consumed' */\n        this.t = new Token();  /* current token */\n        this.lookahead = new Token();  /* look ahead token */\n        this.fs = null;  /* current function (parser) */\n        this.L = null;\n        this.z = null; /* input stream */\n        this.buff = null;  /* buffer for tokens */\n        this.h = null;  /* to reuse strings */\n        this.dyd = null;  /* dynamic structures used by the parser */\n        this.source = null;  /* current source name */\n        this.envn = null;  /* environment variable name */\n    }\n}\n\nconst save = function(ls, c) {\n    let b = ls.buff;\n    if (b.n + 1 > b.buffer.length) {\n        if (b.buffer.length >= MAX_INT/2)\n            lexerror(ls, to_luastring(\"lexical element too long\", true), 0);\n        let newsize = b.buffer.length*2;\n        luaZ_resizebuffer(ls.L, b, newsize);\n    }\n    b.buffer[b.n++] = c < 0 ? 255 + c + 1 : c;\n};\n\nconst luaX_token2str = function(ls, token) {\n    if (token < FIRST_RESERVED) {  /* single-byte symbols? */\n        return lobject.luaO_pushfstring(ls.L, to_luastring(\"'%c'\", true), token);\n    } else {\n        let s = luaX_tokens[token - FIRST_RESERVED];\n        if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */\n            return lobject.luaO_pushfstring(ls.L, to_luastring(\"'%s'\", true), s);\n        else  /* names, strings, and numerals */\n            return s;\n    }\n};\n\nconst currIsNewline = function(ls) {\n    return ls.current === 10 /* ('\\n').charCodeAt(0) */ || ls.current === 13 /* ('\\r').charCodeAt(0) */;\n};\n\nconst next = function(ls) {\n    ls.current = ls.z.zgetc();\n};\n\nconst save_and_next = function(ls) {\n    save(ls, ls.current);\n    next(ls);\n};\n\n/*\n** creates a new string and anchors it in scanner's table so that\n** it will not be collected until the end of the compilation\n** (by that time it should be anchored somewhere)\n*/\nconst TVtrue = new lobject.TValue(LUA_TBOOLEAN, true);\nconst luaX_newstring = function(ls, str) {\n    let L = ls.L;\n    let ts = luaS_new(L, str);\n    /* HACK: Workaround lack of ltable 'keyfromval' */\n    let tpair = ls.h.strong.get(luaS_hashlongstr(ts));\n    if (!tpair) { /* not in use yet? */\n        let key = new lobject.TValue(LUA_TLNGSTR, ts);\n        ltable.luaH_setfrom(L, ls.h, key, TVtrue);\n    } else { /* string already present */\n        ts = tpair.key.tsvalue(); /* re-use value previously stored */\n    }\n    return ts;\n};\n\n/*\n** increment line number and skips newline sequence (any of\n** \\n, \\r, \\n\\r, or \\r\\n)\n*/\nconst inclinenumber = function(ls) {\n    let old = ls.current;\n    lua_assert(currIsNewline(ls));\n    next(ls);  /* skip '\\n' or '\\r' */\n    if (currIsNewline(ls) && ls.current !== old)\n        next(ls);  /* skip '\\n\\r' or '\\r\\n' */\n    if (++ls.linenumber >= MAX_INT)\n        lexerror(ls, to_luastring(\"chunk has too many lines\", true), 0);\n};\n\nconst luaX_setinput = function(L, ls, z, source, firstchar) {\n    ls.t = {\n        token: 0,\n        seminfo: new SemInfo()\n    };\n    ls.L = L;\n    ls.current = firstchar;\n    ls.lookahead = {\n        token: TK_EOS,\n        seminfo: new SemInfo()\n    };\n    ls.z = z;\n    ls.fs = null;\n    ls.linenumber = 1;\n    ls.lastline = 1;\n    ls.source = source;\n    ls.envn = luaS_bless(L, LUA_ENV);\n    luaZ_resizebuffer(L, ls.buff, LUA_MINBUFFER);  /* initialize buffer */\n};\n\nconst check_next1 = function(ls, c) {\n    if (ls.current === c) {\n        next(ls);\n        return true;\n    }\n\n    return false;\n};\n\n/*\n** Check whether current char is in set 'set' (with two chars) and\n** saves it\n*/\nconst check_next2 = function(ls, set) {\n    if (ls.current === set[0].charCodeAt(0) || ls.current === set[1].charCodeAt(0)) {\n        save_and_next(ls);\n        return true;\n    }\n\n    return false;\n};\n\nconst read_numeral = function(ls, seminfo) {\n    let expo = \"Ee\";\n    let first = ls.current;\n    lua_assert(lisdigit(ls.current));\n    save_and_next(ls);\n    if (first === 48 /* ('0').charCodeAt(0) */ && check_next2(ls, \"xX\"))  /* hexadecimal? */\n        expo = \"Pp\";\n\n    for (;;) {\n        if (check_next2(ls, expo))  /* exponent part? */\n            check_next2(ls, \"-+\");  /* optional exponent sign */\n        if (lisxdigit(ls.current))\n            save_and_next(ls);\n        else if (ls.current === 46 /* ('.').charCodeAt(0) */)\n            save_and_next(ls);\n        else break;\n    }\n\n    // save(ls, 0);\n\n    let obj = new lobject.TValue();\n    if (lobject.luaO_str2num(luaZ_buffer(ls.buff), obj) === 0)  /* format error? */\n        lexerror(ls, to_luastring(\"malformed number\", true), TK_FLT);\n    if (obj.ttisinteger()) {\n        seminfo.i = obj.value;\n        return TK_INT;\n    } else {\n        lua_assert(obj.ttisfloat());\n        seminfo.r = obj.value;\n        return TK_FLT;\n    }\n};\n\nconst txtToken = function(ls, token) {\n    switch (token) {\n        case TK_NAME: case TK_STRING:\n        case TK_FLT: case TK_INT:\n            // save(ls, 0);\n            return lobject.luaO_pushfstring(ls.L, to_luastring(\"'%s'\", true), luaZ_buffer(ls.buff));\n        default:\n            return luaX_token2str(ls, token);\n    }\n};\n\nconst lexerror = function(ls, msg, token) {\n    msg = ldebug.luaG_addinfo(ls.L, msg, ls.source, ls.linenumber);\n    if (token)\n        lobject.luaO_pushfstring(ls.L, to_luastring(\"%s near %s\"), msg, txtToken(ls, token));\n    ldo.luaD_throw(ls.L, LUA_ERRSYNTAX);\n};\n\nconst luaX_syntaxerror = function(ls, msg) {\n    lexerror(ls, msg, ls.t.token);\n};\n\n/*\n** skip a sequence '[=*[' or ']=*]'; if sequence is well formed, return\n** its number of '='s; otherwise, return a negative number (-1 iff there\n** are no '='s after initial bracket)\n*/\nconst skip_sep = function(ls) {\n    let count = 0;\n    let s = ls.current;\n    lua_assert(s === 91 /* ('[').charCodeAt(0) */ || s === 93 /* (']').charCodeAt(0) */);\n    save_and_next(ls);\n    while (ls.current === 61 /* ('=').charCodeAt(0) */) {\n        save_and_next(ls);\n        count++;\n    }\n    return ls.current === s ? count : (-count) - 1;\n};\n\nconst read_long_string = function(ls, seminfo, sep) {\n    let line = ls.linenumber;  /* initial line (for error message) */\n    save_and_next(ls);  /* skip 2nd '[' */\n\n    if (currIsNewline(ls))  /* string starts with a newline? */\n        inclinenumber(ls);  /* skip it */\n\n    let skip = false;\n    for (; !skip ;) {\n        switch (ls.current) {\n            case EOZ: {  /* error */\n                let what = seminfo ? \"string\" : \"comment\";\n                let msg = `unfinished long ${what} (starting at line ${line})`;\n                lexerror(ls, to_luastring(msg), TK_EOS);\n                break;\n            }\n            case 93 /* (']').charCodeAt(0) */: {\n                if (skip_sep(ls) === sep) {\n                    save_and_next(ls);  /* skip 2nd ']' */\n                    skip = true;\n                }\n                break;\n            }\n            case 10 /* ('\\n').charCodeAt(0) */:\n            case 13 /* ('\\r').charCodeAt(0) */: {\n                save(ls, 10 /* ('\\n').charCodeAt(0) */);\n                inclinenumber(ls);\n                if (!seminfo) luaZ_resetbuffer(ls.buff);\n                break;\n            }\n            default: {\n                if (seminfo) save_and_next(ls);\n                else next(ls);\n            }\n        }\n    }\n\n    if (seminfo)\n        seminfo.ts = luaX_newstring(ls, ls.buff.buffer.subarray(2 + sep, ls.buff.n - (2 + sep)));\n};\n\nconst esccheck = function(ls, c, msg) {\n    if (!c) {\n        if (ls.current !== EOZ)\n            save_and_next(ls);  /* add current to buffer for error message */\n        lexerror(ls, msg, TK_STRING);\n    }\n};\n\nconst gethexa = function(ls) {\n    save_and_next(ls);\n    esccheck(ls, lisxdigit(ls.current), to_luastring(\"hexadecimal digit expected\", true));\n    return lobject.luaO_hexavalue(ls.current);\n};\n\nconst readhexaesc = function(ls) {\n    let r = gethexa(ls);\n    r = (r << 4) + gethexa(ls);\n    luaZ_buffremove(ls.buff, 2);  /* remove saved chars from buffer */\n    return r;\n};\n\nconst readutf8desc = function(ls) {\n    let i = 4;  /* chars to be removed: '\\', 'u', '{', and first digit */\n    save_and_next(ls);  /* skip 'u' */\n    esccheck(ls, ls.current === 123 /* ('{').charCodeAt(0) */, to_luastring(\"missing '{'\", true));\n    let r = gethexa(ls);  /* must have at least one digit */\n\n    save_and_next(ls);\n    while (lisxdigit(ls.current)) {\n        i++;\n        r = (r << 4) + lobject.luaO_hexavalue(ls.current);\n        esccheck(ls, r <= 0x10FFFF, to_luastring(\"UTF-8 value too large\", true));\n        save_and_next(ls);\n    }\n    esccheck(ls, ls.current === 125 /* ('}').charCodeAt(0) */, to_luastring(\"missing '}'\", true));\n    next(ls);  /* skip '}' */\n    luaZ_buffremove(ls.buff, i);  /* remove saved chars from buffer */\n    return r;\n};\n\nconst utf8esc = function(ls) {\n    let buff = new Uint8Array(lobject.UTF8BUFFSZ);\n    let n = lobject.luaO_utf8esc(buff, readutf8desc(ls));\n    for (; n > 0; n--)  /* add 'buff' to string */\n        save(ls, buff[lobject.UTF8BUFFSZ - n]);\n};\n\nconst readdecesc = function(ls) {\n    let r = 0;  /* result accumulator */\n    let i;\n    for (i = 0; i < 3 && lisdigit(ls.current); i++) {  /* read up to 3 digits */\n        r = 10 * r + ls.current - 48 /* ('0').charCodeAt(0) */;\n        save_and_next(ls);\n    }\n    esccheck(ls, r <= 255, to_luastring(\"decimal escape too large\", true));\n    luaZ_buffremove(ls.buff, i);  /* remove read digits from buffer */\n    return r;\n};\n\nconst read_string = function(ls, del, seminfo) {\n    save_and_next(ls);  /* keep delimiter (for error messages) */\n\n    while (ls.current !== del) {\n        switch (ls.current) {\n            case EOZ:\n                lexerror(ls, to_luastring(\"unfinished string\", true), TK_EOS);\n                break;\n            case 10 /* ('\\n').charCodeAt(0) */:\n            case 13 /* ('\\r').charCodeAt(0) */:\n                lexerror(ls, to_luastring(\"unfinished string\", true), TK_STRING);\n                break;\n            case 92 /* ('\\\\').charCodeAt(0) */: {  /* escape sequences */\n                save_and_next(ls);  /* keep '\\\\' for error messages */\n                let will;\n                let c;\n                switch(ls.current) {\n                    case 97 /* ('a').charCodeAt(0) */: c = 7 /* \\a isn't valid JS */; will = 'read_save'; break;\n                    case 98 /* ('b').charCodeAt(0) */: c = 8 /* ('\\b').charCodeAt(0) */; will = 'read_save'; break;\n                    case 102 /* ('f').charCodeAt(0) */: c = 12 /* ('\\f').charCodeAt(0) */; will = 'read_save'; break;\n                    case 110 /* ('n').charCodeAt(0) */: c = 10 /* ('\\n').charCodeAt(0) */; will = 'read_save'; break;\n                    case 114 /* ('r').charCodeAt(0) */: c = 13 /* ('\\r').charCodeAt(0) */; will = 'read_save'; break;\n                    case 116 /* ('t').charCodeAt(0) */: c = 9 /* ('\\t').charCodeAt(0) */; will = 'read_save'; break;\n                    case 118 /* ('v').charCodeAt(0) */: c = 11 /* ('\\v').charCodeAt(0) */; will = 'read_save'; break;\n                    case 120 /* ('x').charCodeAt(0) */: c = readhexaesc(ls); will = 'read_save'; break;\n                    case 117 /* ('u').charCodeAt(0) */: utf8esc(ls); will = 'no_save'; break;\n                    case 10 /* ('\\n').charCodeAt(0) */:\n                    case 13 /* ('\\r').charCodeAt(0) */:\n                        inclinenumber(ls); c = 10 /* ('\\n').charCodeAt(0) */; will = 'only_save'; break;\n                    case 92 /* ('\\\\').charCodeAt(0) */:\n                    case 34 /* ('\"').charCodeAt(0) */:\n                    case 39 /* ('\\'').charCodeAt(0) */:\n                        c = ls.current; will = 'read_save'; break;\n                    case EOZ: will = 'no_save'; break;  /* will raise an error next loop */\n                    case 122 /* ('z').charCodeAt(0) */: {  /* zap following span of spaces */\n                        luaZ_buffremove(ls.buff, 1);  /* remove '\\\\' */\n                        next(ls);  /* skip the 'z' */\n                        while (lisspace(ls.current)) {\n                            if (currIsNewline(ls)) inclinenumber(ls);\n                            else next(ls);\n                        }\n                        will = 'no_save'; break;\n                    }\n                    default: {\n                        esccheck(ls, lisdigit(ls.current), to_luastring(\"invalid escape sequence\", true));\n                        c = readdecesc(ls);  /* digital escape '\\ddd' */\n                        will = 'only_save'; break;\n                    }\n                }\n\n                if (will === 'read_save')\n                    next(ls);\n\n                if (will === 'read_save' || will === 'only_save') {\n                    luaZ_buffremove(ls.buff, 1);  /* remove '\\\\' */\n                    save(ls, c);\n                }\n\n                break;\n            }\n            default:\n                save_and_next(ls);\n        }\n    }\n    save_and_next(ls);  /* skip delimiter */\n\n    seminfo.ts = luaX_newstring(ls, ls.buff.buffer.subarray(1, ls.buff.n-1));\n};\n\nconst token_to_index = Object.create(null); /* don't want to return true for e.g. 'hasOwnProperty' */\nluaX_tokens.forEach((e, i)=>token_to_index[luaS_hash(e)] = i);\n\nconst isreserved = function(w) {\n    let kidx = token_to_index[luaS_hashlongstr(w)];\n    return kidx !== void 0 && kidx <= 22;\n};\n\nconst llex = function(ls, seminfo) {\n    luaZ_resetbuffer(ls.buff);\n    for (;;) {\n        lua_assert(typeof ls.current == \"number\"); /* fengari addition */\n        switch (ls.current) {\n            case 10 /* ('\\n').charCodeAt(0) */:\n            case 13 /* ('\\r').charCodeAt(0) */: {  /* line breaks */\n                inclinenumber(ls);\n                break;\n            }\n            case 32 /* (' ').charCodeAt(0) */:\n            case 12 /* ('\\f').charCodeAt(0) */:\n            case 9 /* ('\\t').charCodeAt(0) */:\n            case 11 /* ('\\v').charCodeAt(0) */: {  /* spaces */\n                next(ls);\n                break;\n            }\n            case 45 /* ('-').charCodeAt(0) */: {  /* '-' or '--' (comment) */\n                next(ls);\n                if (ls.current !== 45 /* ('-').charCodeAt(0) */) return 45 /* ('-').charCodeAt(0) */;\n                /* else is a comment */\n                next(ls);\n                if (ls.current === 91 /* ('[').charCodeAt(0) */) {  /* long comment? */\n                    let sep = skip_sep(ls);\n                    luaZ_resetbuffer(ls.buff);  /* 'skip_sep' may dirty the buffer */\n                    if (sep >= 0) {\n                        read_long_string(ls, null, sep);  /* skip long comment */\n                        luaZ_resetbuffer(ls.buff);  /* previous call may dirty the buff. */\n                        break;\n                    }\n                }\n\n                /* else short comment */\n                while (!currIsNewline(ls) && ls.current !== EOZ)\n                    next(ls);  /* skip until end of line (or end of file) */\n                break;\n            }\n            case 91 /* ('[').charCodeAt(0) */: {  /* long string or simply '[' */\n                let sep = skip_sep(ls);\n                if (sep >= 0) {\n                    read_long_string(ls, seminfo, sep);\n                    return TK_STRING;\n                } else if (sep !== -1)  /* '[=...' missing second bracket */\n                    lexerror(ls, to_luastring(\"invalid long string delimiter\", true), TK_STRING);\n                return 91 /* ('[').charCodeAt(0) */;\n            }\n            case 61 /* ('=').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 61 /* ('=').charCodeAt(0) */)) return TK_EQ;\n                else return 61 /* ('=').charCodeAt(0) */;\n            }\n            case 60 /* ('<').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 61 /* ('=').charCodeAt(0) */)) return TK_LE;\n                else if (check_next1(ls, 60 /* ('<').charCodeAt(0) */)) return TK_SHL;\n                else return 60 /* ('<').charCodeAt(0) */;\n            }\n            case 62 /* ('>').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 61 /* ('=').charCodeAt(0) */)) return TK_GE;\n                else if (check_next1(ls, 62 /* ('>').charCodeAt(0) */)) return TK_SHR;\n                else return 62 /* ('>').charCodeAt(0) */;\n            }\n            case 47 /* ('/').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 47 /* ('/').charCodeAt(0) */)) return TK_IDIV;\n                else return 47 /* ('/').charCodeAt(0) */;\n            }\n            case 126 /* ('~').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 61 /* ('=').charCodeAt(0) */)) return TK_NE;\n                else return 126 /* ('~').charCodeAt(0) */;\n            }\n            case 58 /* (':').charCodeAt(0) */: {\n                next(ls);\n                if (check_next1(ls, 58 /* (':').charCodeAt(0) */)) return TK_DBCOLON;\n                else return 58 /* (':').charCodeAt(0) */;\n            }\n            case 34 /* ('\"').charCodeAt(0) */:\n            case 39 /* ('\\'').charCodeAt(0) */: {  /* short literal strings */\n                read_string(ls, ls.current, seminfo);\n                return TK_STRING;\n            }\n            case 46 /* ('.').charCodeAt(0) */: {  /* '.', '..', '...', or number */\n                save_and_next(ls);\n                if (check_next1(ls, 46 /* ('.').charCodeAt(0) */)) {\n                    if (check_next1(ls, 46 /* ('.').charCodeAt(0) */))\n                        return TK_DOTS;   /* '...' */\n                    else return TK_CONCAT;   /* '..' */\n                }\n                else if (!lisdigit(ls.current)) return 46 /* ('.').charCodeAt(0) */;\n                else return read_numeral(ls, seminfo);\n            }\n            case 48 /* ('0').charCodeAt(0) */: case 49 /* ('1').charCodeAt(0) */: case 50 /* ('2').charCodeAt(0) */: case 51 /* ('3').charCodeAt(0) */: case 52 /* ('4').charCodeAt(0) */:\n            case 53 /* ('5').charCodeAt(0) */: case 54 /* ('6').charCodeAt(0) */: case 55 /* ('7').charCodeAt(0) */: case 56 /* ('8').charCodeAt(0) */: case 57 /* ('9').charCodeAt(0) */: {\n                return read_numeral(ls, seminfo);\n            }\n            case EOZ: {\n                return TK_EOS;\n            }\n            default: {\n                if (lislalpha(ls.current)) {  /* identifier or reserved word? */\n                    do {\n                        save_and_next(ls);\n                    } while (lislalnum(ls.current));\n                    let ts = luaX_newstring(ls, luaZ_buffer(ls.buff));\n                    seminfo.ts = ts;\n                    let kidx = token_to_index[luaS_hashlongstr(ts)];\n                    if (kidx !== void 0 && kidx <= 22)  /* reserved word? */\n                        return kidx + FIRST_RESERVED;\n                    else\n                        return TK_NAME;\n                } else {  /* single-char tokens (+ - / ...) */\n                    let c = ls.current;\n                    next(ls);\n                    return c;\n                }\n            }\n        }\n    }\n};\n\nconst luaX_next = function(ls) {\n    ls.lastline = ls.linenumber;\n    if (ls.lookahead.token !== TK_EOS) {  /* is there a look-ahead token? */\n        ls.t.token = ls.lookahead.token;  /* use this one */\n        ls.t.seminfo.i = ls.lookahead.seminfo.i;\n        ls.t.seminfo.r = ls.lookahead.seminfo.r;\n        ls.t.seminfo.ts = ls.lookahead.seminfo.ts;\n        ls.lookahead.token = TK_EOS;  /* and discharge it */\n    } else\n        ls.t.token = llex(ls, ls.t.seminfo);  /* read next token */\n};\n\nconst luaX_lookahead = function(ls) {\n    lua_assert(ls.lookahead.token === TK_EOS);\n    ls.lookahead.token = llex(ls, ls.lookahead.seminfo);\n    return ls.lookahead.token;\n};\n\nmodule.exports.FIRST_RESERVED   = FIRST_RESERVED;\nmodule.exports.LUA_ENV          = LUA_ENV;\nmodule.exports.LexState         = LexState;\nmodule.exports.RESERVED         = RESERVED;\nmodule.exports.isreserved       = isreserved;\nmodule.exports.luaX_lookahead   = luaX_lookahead;\nmodule.exports.luaX_newstring   = luaX_newstring;\nmodule.exports.luaX_next        = luaX_next;\nmodule.exports.luaX_setinput    = luaX_setinput;\nmodule.exports.luaX_syntaxerror = luaX_syntaxerror;\nmodule.exports.luaX_token2str   = luaX_token2str;\nmodule.exports.luaX_tokens      = luaX_tokens;\n","\"use strict\";\n\nconst {\n\tlua,\n\tlauxlib,\n\tlualib,\n\tto_luastring\n} = require('fengari');\nconst {\n\tLUA_MULTRET,\n\tLUA_OK,\n\tLUA_REGISTRYINDEX,\n\tLUA_RIDX_MAINTHREAD,\n\tLUA_TBOOLEAN,\n\tLUA_TFUNCTION,\n\tLUA_TLIGHTUSERDATA,\n\tLUA_TNIL,\n\tLUA_TNONE,\n\tLUA_TNUMBER,\n\tLUA_TSTRING,\n\tLUA_TTABLE,\n\tLUA_TTHREAD,\n\tLUA_TUSERDATA,\n\tlua_atnativeerror,\n\tlua_call,\n\tlua_getfield,\n\tlua_gettable,\n\tlua_gettop,\n\tlua_isnil,\n\tlua_isproxy,\n\tlua_newuserdata,\n\tlua_pcall,\n\tlua_pop,\n\tlua_pushboolean,\n\tlua_pushcfunction,\n\tlua_pushinteger,\n\tlua_pushlightuserdata,\n\tlua_pushliteral,\n\tlua_pushnil,\n\tlua_pushnumber,\n\tlua_pushstring,\n\tlua_pushvalue,\n\tlua_rawgeti,\n\tlua_rawgetp,\n\tlua_rawsetp,\n\tlua_rotate,\n\tlua_setfield,\n\tlua_settable,\n\tlua_settop,\n\tlua_toboolean,\n\tlua_tojsstring,\n\tlua_tonumber,\n\tlua_toproxy,\n\tlua_tothread,\n\tlua_touserdata,\n\tlua_type\n} = lua;\nconst {\n\tluaL_argerror,\n\tluaL_checkany,\n\tluaL_checkoption,\n\tluaL_checkstack,\n\tluaL_checkudata,\n\tluaL_error,\n\tluaL_getmetafield,\n\tluaL_newlib,\n\tluaL_newmetatable,\n\tluaL_requiref,\n\tluaL_setfuncs,\n\tluaL_setmetatable,\n\tluaL_testudata,\n\tluaL_tolstring\n} = lauxlib;\nconst {\n\tluaopen_base\n} = lualib;\n\nconst FENGARI_INTEROP_VERSION_MAJOR   = \"0\";\nconst FENGARI_INTEROP_VERSION_MINOR   = \"1\";\nconst FENGARI_INTEROP_VERSION_NUM     = 1;\nconst FENGARI_INTEROP_VERSION_RELEASE = \"2\";\nconst FENGARI_INTEROP_VERSION         = FENGARI_INTEROP_VERSION_MAJOR + \".\" + FENGARI_INTEROP_VERSION_MINOR;\nconst FENGARI_INTEROP_RELEASE         = FENGARI_INTEROP_VERSION + \".\" + FENGARI_INTEROP_VERSION_RELEASE;\n\nlet custom_inspect_symbol;\nif (typeof process !== \"undefined\") {\n\ttry { /* for node.js */\n\t\tcustom_inspect_symbol = require('util').inspect.custom;\n\t} catch (e) {}\n}\n\nconst global_env = (function() {\n\t/* global WorkerGlobalScope */ /* see https://github.com/sindresorhus/globals/issues/127 */\n\tif (typeof process !== \"undefined\") {\n\t\t/* node */\n\t\treturn global;\n\t} else if (typeof window !== \"undefined\") {\n\t\t/* browser window */\n\t\treturn window;\n\t} else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n\t\t/* web worker */\n\t\treturn self;\n\t} else {\n\t\t/* unknown global env */\n\t\treturn (0, eval)('this'); /* use non-strict mode to get global env */\n\t}\n})();\n\nlet apply, construct, Reflect_deleteProperty;\nif (typeof Reflect !== \"undefined\") {\n\tapply = Reflect.apply;\n\tconstruct = Reflect.construct;\n\tReflect_deleteProperty = Reflect.deleteProperty;\n} else {\n\tconst fApply = Function.apply;\n\tconst bind = Function.bind;\n\tapply = function(target, thisArgument, argumentsList) {\n\t\treturn fApply.call(target, thisArgument, argumentsList);\n\t};\n\tconstruct = function(target, argumentsList /*, newTarget */) {\n\t\tswitch (argumentsList.length) {\n\t\t\tcase 0: return new target();\n\t\t\tcase 1: return new target(argumentsList[0]);\n\t\t\tcase 2: return new target(argumentsList[0], argumentsList[1]);\n\t\t\tcase 3: return new target(argumentsList[0], argumentsList[1], argumentsList[2]);\n\t\t\tcase 4: return new target(argumentsList[0], argumentsList[1], argumentsList[2], argumentsList[3]);\n\t\t}\n\t\tlet args = [null];\n\t\targs.push.apply(args, argumentsList);\n\t\treturn new (bind.apply(target, args))();\n\t};\n\t/* need to be in non-strict mode */\n\tReflect_deleteProperty = Function(\"t\", \"k\", \"delete t[k]\");\n}\n\n/*\nString.concat coerces to string with correct hint for Symbol.toPrimitive\n`this` isn't allowed to be null, so bind the empty string\n*/\nconst toString = String.prototype.concat.bind(\"\");\n\nconst isobject = function(o) {\n\treturn typeof o === \"object\" ? o !== null : typeof o === \"function\";\n};\n\nconst js_tname = to_luastring(\"js object\");\nconst js_library_not_loaded = \"js library not loaded into lua_State\";\n\nconst testjs = function(L, idx) {\n\tlet u = luaL_testudata(L, idx, js_tname);\n\tif (u)\n\t\treturn u.data;\n\telse\n\t\treturn void 0;\n};\n\nconst checkjs = function(L, idx) {\n\treturn luaL_checkudata(L, idx, js_tname).data;\n};\n\nconst pushjs = function(L, v) {\n\tlet b = lua_newuserdata(L);\n\tb.data = v;\n\tluaL_setmetatable(L, js_tname);\n};\n\nconst getmainthread = function(L) {\n\tlua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_MAINTHREAD);\n\tlet mainL = lua_tothread(L, -1);\n\tlua_pop(L, 1);\n\treturn mainL;\n};\n\n/* weak map from states to proxy objects (for each object) in that state */\nconst states = new WeakMap();\n\nconst push = function(L, v) {\n\tswitch (typeof v) {\n\t\tcase \"undefined\":\n\t\t\tlua_pushnil(L);\n\t\t\tbreak;\n\t\tcase \"number\":\n\t\t\tlua_pushnumber(L, v);\n\t\t\tbreak;\n\t\tcase \"string\":\n\t\t\tlua_pushstring(L, to_luastring(v));\n\t\t\tbreak;\n\t\tcase \"boolean\":\n\t\t\tlua_pushboolean(L, v);\n\t\t\tbreak;\n\t\tcase \"symbol\":\n\t\t\tlua_pushlightuserdata(L, v);\n\t\t\tbreak;\n\t\tcase \"function\":\n\t\t\tif (lua_isproxy(v, L)) {\n\t\t\t\tv(L);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase \"object\":\n\t\t\tif (v === null) {\n\t\t\t\t/* can't use null in a WeakMap; grab from registry */\n\t\t\t\tif (lua_rawgetp(L, LUA_REGISTRYINDEX, null) !== LUA_TUSERDATA)\n\t\t\t\t\tthrow Error(js_library_not_loaded);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tdefault: {\n\t\t\t/* Try and push same object again */\n\t\t\tlet objects_seen = states.get(getmainthread(L));\n\t\t\tif (!objects_seen) throw Error(js_library_not_loaded);\n\t\t\tlet p = objects_seen.get(v);\n\t\t\tif (p) {\n\t\t\t\tp(L);\n\t\t\t} else {\n\t\t\t\tpushjs(L, v);\n\t\t\t\tp = lua_toproxy(L, -1);\n\t\t\t\tobjects_seen.set(v, p);\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst atnativeerror = function(L) {\n\tlet u = lua_touserdata(L, 1);\n\tpush(L, u);\n\treturn 1;\n};\n\nconst tojs = function(L, idx) {\n\tswitch(lua_type(L, idx)) {\n\t\tcase LUA_TNONE:\n\t\tcase LUA_TNIL:\n\t\t\treturn void 0;\n\t\tcase LUA_TBOOLEAN:\n\t\t\treturn lua_toboolean(L, idx);\n\t\tcase LUA_TLIGHTUSERDATA:\n\t\t\treturn lua_touserdata(L, idx);\n\t\tcase LUA_TNUMBER:\n\t\t\treturn lua_tonumber(L, idx);\n\t\tcase LUA_TSTRING:\n\t\t\treturn lua_tojsstring(L, idx);\n\t\tcase LUA_TUSERDATA: {\n\t\t\tlet u = testjs(L, idx);\n\t\t\tif (u !== void 0)\n\t\t\t\treturn u;\n\t\t}\n\t\t/* fall through */\n\t\tcase LUA_TTABLE:\n\t\tcase LUA_TFUNCTION:\n\t\tcase LUA_TTHREAD:\n\t\t/* fall through */\n\t\tdefault:\n\t\t\treturn wrap(L, lua_toproxy(L, idx));\n\t}\n};\n\n/* Calls function on the stack with `nargs` from the stack.\n   On lua error, re-throws as javascript error\n   On success, returns single return value */\nconst jscall = function(L, nargs) {\n\tlet status = lua_pcall(L, nargs, 1, 0);\n\tlet r = tojs(L, -1);\n\tlua_pop(L, 1);\n\tswitch(status) {\n\t\tcase LUA_OK:\n\t\t\treturn r;\n\t\tdefault:\n\t\t\tthrow r;\n\t}\n};\n\nconst invoke = function(L, p, thisarg, args, n_results) {\n\tif (!isobject(args)) throw new TypeError(\"`args` argument must be an object\");\n\tlet length = +args.length;\n\tif (!(length >= 0)) length = 0; /* Keep NaN in mind */\n\tluaL_checkstack(L, 2+length, null);\n\tlet base = lua_gettop(L);\n\tp(L);\n\tpush(L, thisarg);\n\tfor (let i=0; i<length; i++) {\n\t\tpush(L, args[i]);\n\t}\n\tswitch(lua_pcall(L, 1+length, n_results, 0)) {\n\t\tcase LUA_OK: {\n\t\t\tlet nres = lua_gettop(L)-base;\n\t\t\tlet res = new Array(nres);\n\t\t\tfor (let i=0; i<nres; i++) {\n\t\t\t\tres[i] = tojs(L, base+i+1);\n\t\t\t}\n\t\t\tlua_settop(L, base);\n\t\t\treturn res;\n\t\t}\n\t\tdefault: {\n\t\t\tlet r = tojs(L, -1);\n\t\t\tlua_settop(L, base);\n\t\t\tthrow r;\n\t\t}\n\t}\n};\n\nconst gettable = function(L) {\n\tlua_gettable(L, 1);\n\treturn 1;\n};\n\nconst get = function(L, p, prop) {\n\tluaL_checkstack(L, 3, null);\n\tlua_pushcfunction(L, gettable);\n\tp(L);\n\tpush(L, prop);\n\treturn jscall(L, 2);\n};\n\nconst has = function(L, p, prop) {\n\tluaL_checkstack(L, 3, null);\n\tlua_pushcfunction(L, gettable);\n\tp(L);\n\tpush(L, prop);\n\tlet status = lua_pcall(L, 2, 1, 0);\n\tswitch(status) {\n\t\tcase LUA_OK: {\n\t\t\tlet r = lua_isnil(L, -1);\n\t\t\tlua_pop(L, 1);\n\t\t\treturn !r;\n\t\t}\n\t\tdefault: {\n\t\t\tlet r = tojs(L, -1);\n\t\t\tlua_pop(L, 1);\n\t\t\tthrow r;\n\t\t}\n\t}\n};\n\nconst set = function(L, p, prop, value) {\n\tluaL_checkstack(L, 4, null);\n\tlua_pushcfunction(L, function(L) {\n\t\tlua_settable(L, 1);\n\t\treturn 0;\n\t});\n\tp(L);\n\tpush(L, prop);\n\tpush(L, value);\n\tswitch(lua_pcall(L, 3, 0, 0)) {\n\t\tcase LUA_OK:\n\t\t\treturn;\n\t\tdefault: {\n\t\t\tlet r = tojs(L, -1);\n\t\t\tlua_pop(L, 1);\n\t\t\tthrow r;\n\t\t}\n\t}\n};\n\nconst deleteProperty = function(L, p, prop) {\n\tluaL_checkstack(L, 4, null);\n\tlua_pushcfunction(L, function(L) {\n\t\tlua_settable(L, 1);\n\t\treturn 0;\n\t});\n\tp(L);\n\tpush(L, prop);\n\tlua_pushnil(L);\n\tswitch(lua_pcall(L, 3, 0, 0)) {\n\t\tcase LUA_OK:\n\t\t\treturn;\n\t\tdefault: {\n\t\t\tlet r = tojs(L, -1);\n\t\t\tlua_pop(L, 1);\n\t\t\tthrow r;\n\t\t}\n\t}\n};\n\nconst tostring = function(L, p) {\n\tluaL_checkstack(L, 2, null);\n\tlua_pushcfunction(L, function(L) {\n\t\tluaL_tolstring(L, 1);\n\t\treturn 1;\n\t});\n\tp(L);\n\treturn jscall(L, 1);\n};\n\n/* implements lua's \"Generic For\" protocol */\nconst iter_next = function() {\n\tlet L = this.L;\n\tluaL_checkstack(L, 3, null);\n\tlet top = lua_gettop(L);\n\tthis.iter(L);\n\tthis.state(L);\n\tthis.last(L);\n\tswitch(lua_pcall(L, 2, LUA_MULTRET, 0)) {\n\t\tcase LUA_OK: {\n\t\t\tthis.last = lua_toproxy(L, top+1);\n\t\t\tlet r;\n\t\t\tif (lua_isnil(L, -1)) {\n\t\t\t\tr = {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: void 0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlet n_results = lua_gettop(L) - top;\n\t\t\t\tlet result = new Array(n_results);\n\t\t\t\tfor (let i=0; i<n_results; i++) {\n\t\t\t\t\tresult[i] = tojs(L, top+i+1);\n\t\t\t\t}\n\t\t\t\tr = {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t\tlua_settop(L, top);\n\t\t\treturn r;\n\t\t}\n\t\tdefault: {\n\t\t\tlet e = tojs(L, -1);\n\t\t\tlua_pop(L, 1);\n\t\t\tthrow e;\n\t\t}\n\t}\n};\n\n/* make iteration use pairs() */\nconst jsiterator = function(L, p) {\n\tluaL_checkstack(L, 1, null);\n\tlua_pushcfunction(L, function(L) {\n\t\tluaL_requiref(L, to_luastring(\"_G\"), luaopen_base, 0);\n\t\tlua_getfield(L, -1, to_luastring(\"pairs\"));\n\t\tp(L);\n\t\tlua_call(L, 1, 3);\n\t\treturn 3;\n\t});\n\tswitch(lua_pcall(L, 0, 3, 0)) {\n\t\tcase LUA_OK: {\n\t\t\tlet iter = lua_toproxy(L, -3);\n\t\t\tlet state = lua_toproxy(L, -2);\n\t\t\tlet last = lua_toproxy(L, -1);\n\t\t\tlua_pop(L, 3);\n\t\t\treturn {\n\t\t\t\tL: L,\n\t\t\t\titer: iter,\n\t\t\t\tstate: state,\n\t\t\t\tlast: last,\n\t\t\t\tnext: iter_next\n\t\t\t};\n\t\t}\n\t\tdefault: {\n\t\t\tlet r = tojs(L, -1);\n\t\t\tlua_pop(L, 1);\n\t\t\tthrow r;\n\t\t}\n\t}\n};\n\nconst wrap = function(L1, p) {\n\tconst L = getmainthread(L1);\n\t/* we need `typeof js_proxy` to be \"function\" so that it's acceptable to native apis */\n\tlet js_proxy = function() {\n\t\t/* only get one result */\n\t\treturn invoke(L, p, this, arguments, 1)[0];\n\t};\n\tjs_proxy.apply = function(thisarg, args) {\n\t\t/* only get one result */\n\t\treturn invoke(L, p, thisarg, args, 1)[0];\n\t};\n\tjs_proxy.invoke = function(thisarg, args) {\n\t\treturn invoke(L, p, thisarg, args, LUA_MULTRET);\n\t};\n\tjs_proxy.get = function(k) {\n\t\treturn get(L, p, k);\n\t};\n\tjs_proxy.has = function(k) {\n\t\treturn has(L, p, k);\n\t};\n\tjs_proxy.set = function(k, v) {\n\t\treturn set(L, p, k, v);\n\t};\n\tjs_proxy.delete = function(k) {\n\t\treturn deleteProperty(L, p, k);\n\t};\n\tjs_proxy.toString = function() {\n\t\treturn tostring(L, p);\n\t};\n\tif (typeof Symbol === \"function\") {\n\t\tjs_proxy[Symbol.toStringTag] = \"Fengari object\";\n\t\tjs_proxy[Symbol.iterator] = function() {\n\t\t\treturn jsiterator(L, p);\n\t\t};\n\t\tif (Symbol.toPrimitive) {\n\t\t\tjs_proxy[Symbol.toPrimitive] = function(hint) {\n\t\t\t\tif (hint === \"string\") {\n\t\t\t\t\treturn tostring(L, p);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\tif (custom_inspect_symbol) {\n\t\tjs_proxy[custom_inspect_symbol] = js_proxy.toString;\n\t}\n\tlet objects_seen = states.get(L);\n\tif (!objects_seen) throw Error(js_library_not_loaded);\n\tobjects_seen.set(js_proxy, p);\n\treturn js_proxy;\n};\n\nconst jslib = {\n\t\"new\": function(L) {\n\t\tlet u = tojs(L, 1);\n\t\tlet nargs = lua_gettop(L)-1;\n\t\tlet args = new Array(nargs);\n\t\tfor (let i = 0; i < nargs; i++) {\n\t\t\targs[i] = tojs(L, i+2);\n\t\t}\n\t\tpush(L, construct(u, args));\n\t\treturn 1;\n\t},\n\t\"tonumber\": function(L) {\n\t\tlet u = tojs(L, 1);\n\t\tlua_pushnumber(L, +u);\n\t\treturn 1;\n\t},\n\t\"tostring\": function(L) {\n\t\tlet u = tojs(L, 1);\n\t\tlua_pushliteral(L, toString(u));\n\t\treturn 1;\n\t},\n\t\"instanceof\": function(L) {\n\t\tlet u1 = tojs(L, 1);\n\t\tlet u2 = tojs(L, 2);\n\t\tlua_pushboolean(L, u1 instanceof u2);\n\t\treturn 1;\n\t},\n\t\"typeof\": function(L) {\n\t\tlet u = tojs(L, 1);\n\t\tlua_pushliteral(L, typeof u);\n\t\treturn 1;\n\t}\n};\n\nif (typeof Symbol === \"function\" && Symbol.iterator) {\n\tconst get_iterator = function(L, idx) {\n\t\tlet u = checkjs(L, idx);\n\t\tlet getiter = u[Symbol.iterator];\n\t\tif (!getiter)\n\t\t\tluaL_argerror(L, idx, to_luastring(\"object not iterable\"));\n\t\tlet iter = apply(getiter, u, []);\n\t\tif (!isobject(iter))\n\t\t\tluaL_argerror(L, idx, to_luastring(\"Result of the Symbol.iterator method is not an object\"));\n\t\treturn iter;\n\t};\n\n\tconst next = function(L) {\n\t\tlet iter = tojs(L, 1);\n\t\tlet r = iter.next();\n\t\tif (r.done) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpush(L, r.value);\n\t\t\treturn 1;\n\t\t}\n\t};\n\n\tjslib[\"of\"] = function(L) {\n\t\tlet iter = get_iterator(L, 1);\n\t\tlua_pushcfunction(L, next);\n\t\tpush(L, iter);\n\t\treturn 2;\n\t};\n}\n\nif (typeof Proxy === \"function\" && typeof Symbol === \"function\") {\n\tconst L_symbol = Symbol(\"lua_State\");\n\tconst p_symbol = Symbol(\"fengari-proxy\");\n\n\tconst proxy_handlers = {\n\t\t\"apply\": function(target, thisarg, args) {\n\t\t\treturn invoke(target[L_symbol], target[p_symbol], thisarg, args, 1)[0];\n\t\t},\n\t\t\"construct\": function(target, argumentsList) {\n\t\t\tlet L = target[L_symbol];\n\t\t\tlet p = target[p_symbol];\n\t\t\tlet arg_length = argumentsList.length;\n\t\t\tluaL_checkstack(L, 2+arg_length, null);\n\t\t\tp(L);\n\t\t\tlet idx = lua_gettop(L);\n\t\t\tif (luaL_getmetafield(L, idx, to_luastring(\"construct\")) === LUA_TNIL) {\n\t\t\t\tlua_pop(L, 1);\n\t\t\t\tthrow new TypeError(\"not a constructor\");\n\t\t\t}\n\t\t\tlua_rotate(L, idx, 1);\n\t\t\tfor (let i=0; i<arg_length; i++) {\n\t\t\t\tpush(L, argumentsList[i]);\n\t\t\t}\n\t\t\treturn jscall(L, 1+arg_length);\n\t\t},\n\t\t\"defineProperty\": function(target, prop, desc) {\n\t\t\tlet L = target[L_symbol];\n\t\t\tlet p = target[p_symbol];\n\t\t\tluaL_checkstack(L, 4, null);\n\t\t\tp(L);\n\t\t\tif (luaL_getmetafield(L, -1, to_luastring(\"defineProperty\")) === LUA_TNIL) {\n\t\t\t\tlua_pop(L, 1);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlua_rotate(L, -2, 1);\n\t\t\tpush(L, prop);\n\t\t\tpush(L, desc);\n\t\t\treturn jscall(L, 3);\n\t\t},\n\t\t\"deleteProperty\": function(target, k) {\n\t\t\treturn deleteProperty(target[L_symbol], target[p_symbol], k);\n\t\t},\n\t\t\"get\": function(target, k) {\n\t\t\treturn get(target[L_symbol], target[p_symbol], k);\n\t\t},\n\t\t\"getOwnPropertyDescriptor\": function(target, prop) {\n\t\t\tlet L = target[L_symbol];\n\t\t\tlet p = target[p_symbol];\n\t\t\tluaL_checkstack(L, 3, null);\n\t\t\tp(L);\n\t\t\tif (luaL_getmetafield(L, -1, to_luastring(\"getOwnPropertyDescriptor\")) === LUA_TNIL) {\n\t\t\t\tlua_pop(L, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlua_rotate(L, -2, 1);\n\t\t\tpush(L, prop);\n\t\t\treturn jscall(L, 2);\n\t\t},\n\t\t\"getPrototypeOf\": function(target) {\n\t\t\tlet L = target[L_symbol];\n\t\t\tlet p = target[p_symbol];\n\t\t\tluaL_checkstack(L, 2, null);\n\t\t\tp(L);\n\t\t\tif (luaL_getmetafield(L, -1, to_luastring(\"getPrototypeOf\")) === LUA_TNIL) {\n\t\t\t\tlua_pop(L, 1);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tlua_rotate(L, -2, 1);\n\t\t\treturn jscall(L, 1);\n\t\t},\n\t\t\"has\": function(target, k) {\n\t\t\treturn has(target[L_symbol], target[p_symbol], k);\n\t\t},\n\t\t\"ownKeys\": function(target) {\n\t\t\tlet L = target[L_symbol];\n\t\t\tlet p = target[p_symbol];\n\t\t\tluaL_checkstack(L, 2, null);\n\t\t\tp(L);\n\t\t\tif (luaL_getmetafield(L, -1, to_luastring(\"ownKeys\")) === LUA_TNIL) {\n\t\t\t\tlua_pop(L, 1);\n\t\t\t\tthrow Error(\"ownKeys unknown for fengari object\");\n\t\t\t}\n\t\t\tlua_rotate(L, -2, 1);\n\t\t\treturn jscall(L, 1);\n\t\t},\n\t\t\"set\": function(target, k, v) {\n\t\t\tset(target[L_symbol], target[p_symbol], k, v);\n\t\t\treturn true;\n\t\t},\n\t\t\"setPrototypeOf\": function(target, prototype) {\n\t\t\tlet L = target[L_symbol];\n\t\t\tlet p = target[p_symbol];\n\t\t\tluaL_checkstack(L, 3, null);\n\t\t\tp(L);\n\t\t\tif (luaL_getmetafield(L, -1, to_luastring(\"setPrototypeOf\")) === LUA_TNIL) {\n\t\t\t\tlua_pop(L, 1);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tlua_rotate(L, -2, 1);\n\t\t\tpush(L, prototype);\n\t\t\treturn jscall(L, 2);\n\t\t}\n\t};\n\n\t/*\n\tFunctions created with `function(){}` have a non-configurable .prototype\n\tfield. This causes issues with the .ownKeys and .getOwnPropertyDescriptor\n\ttraps.\n\tHowever using `.bind()` returns a function without the .prototype property.\n\n\t```js\n\tReflect.ownKeys((function(){})) // Array [ \"prototype\", \"length\", \"name\" ]\n\tReflect.ownKeys((function(){}).bind()) // Array [ \"length\", \"name\" ]\n\t```\n\t*/\n\tconst raw_function = function() {\n\t\tlet f = (function(){}).bind();\n\t\tdelete f.length;\n\t\tdelete f.name;\n\t\treturn f;\n\t};\n\n\t/*\n\tWe use Function() here to get prevent transpilers from converting to a\n\tnon-arrow function.\n\tAdditionally, we avoid setting the internal name field by never giving the\n\tnew function a name in the block it was defined (and instead delete-ing\n\tthe configurable fields .length and .name in a wrapper function)\n\t*/\n\tconst make_arrow_function = Function(\"return ()=>void 0;\");\n\tconst raw_arrow_function = function() {\n\t\tlet f = make_arrow_function();\n\t\tdelete f.length;\n\t\tdelete f.name;\n\t\treturn f;\n\t};\n\n\t/*\n\tArrow functions do not have a .prototype field:\n\n\t```js\n\tReflect.ownKeys((() = >void 0)) // Array [ \"length\", \"name\" ]\n\t```\n\n\tHowever they cannot be used as a constructor:\n\n\t```js\n\tnew (new Proxy(() => void 0, { construct: function() { return {}; } })) // TypeError: (intermediate value) is not a constructor\n\tnew (new Proxy(function(){}, { construct: function() { return {}; } })) // {}\n\t```\n\t*/\n\tconst createproxy = function(L1, p, type) {\n\t\tconst L = getmainthread(L1);\n\t\tlet target;\n\t\tswitch (type) {\n\t\t\tcase \"function\":\n\t\t\t\ttarget = raw_function();\n\t\t\t\tbreak;\n\t\t\tcase \"arrow_function\":\n\t\t\t\ttarget = raw_arrow_function();\n\t\t\t\tbreak;\n\t\t\tcase \"object\":\n\t\t\t\ttarget = {};\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow TypeError(\"invalid type to createproxy\");\n\t\t}\n\t\ttarget[p_symbol] = p;\n\t\ttarget[L_symbol] = L;\n\t\treturn new Proxy(target, proxy_handlers);\n\t};\n\n\tconst valid_types = [\"function\", \"arrow_function\", \"object\"];\n\tconst valid_types_as_luastring = valid_types.map((v) => to_luastring(v));\n\tjslib[\"createproxy\"] = function(L) {\n\t\tluaL_checkany(L, 1);\n\t\tlet type = valid_types[luaL_checkoption(L, 2, valid_types_as_luastring[0], valid_types_as_luastring)];\n\t\tlet fengariProxy = createproxy(L, lua_toproxy(L, 1), type);\n\t\tpush(L, fengariProxy);\n\t\treturn 1;\n\t};\n}\n\nlet jsmt = {\n\t\"__index\": function(L) {\n\t\tlet u = checkjs(L, 1);\n\t\tlet k = tojs(L, 2);\n\t\tpush(L, u[k]);\n\t\treturn 1;\n\t},\n\t\"__newindex\": function(L) {\n\t\tlet u = checkjs(L, 1);\n\t\tlet k = tojs(L, 2);\n\t\tlet v = tojs(L, 3);\n\t\tif (v === void 0)\n\t\t\tReflect_deleteProperty(u, k);\n\t\telse\n\t\t\tu[k] = v;\n\t\treturn 0;\n\t},\n\t\"__tostring\": function(L) {\n\t\tlet u = checkjs(L, 1);\n\t\tlet s = toString(u);\n\t\tlua_pushstring(L, to_luastring(s));\n\t\treturn 1;\n\t},\n\t\"__call\": function(L) {\n\t\tlet u = checkjs(L, 1);\n\t\tlet nargs = lua_gettop(L)-1;\n\t\tlet thisarg;\n\t\tlet args = new Array(Math.max(0, nargs-1));\n\t\tif (nargs > 0) {\n\t\t\tthisarg = tojs(L, 2);\n\t\t\tif (nargs-- > 0) {\n\t\t\t\tfor (let i = 0; i < nargs; i++) {\n\t\t\t\t\targs[i] = tojs(L, i+3);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpush(L, apply(u, thisarg, args));\n\t\treturn 1;\n\t},\n\t\"__pairs\": function(L) {\n\t\tlet u = checkjs(L, 1);\n\t\tlet f;\n\t\tlet iter, state, first;\n\t\tif (typeof Symbol !== \"function\" || (f = u[Symbol.for(\"__pairs\")]) === void 0) {\n\t\t\t/* By default, iterate over Object.keys */\n\t\t\titer = function(last) {\n\t\t\t\tif (this.index >= this.keys.length)\n\t\t\t\t\treturn;\n\t\t\t\tlet key = this.keys[this.index++];\n\t\t\t\treturn [key, this.object[key]];\n\t\t\t};\n\t\t\tstate = {\n\t\t\t\tobject: u,\n\t\t\t\tkeys: Object.keys(u),\n\t\t\t\tindex: 0,\n\t\t\t};\n\t\t} else {\n\t\t\tlet r = apply(f, u, []);\n\t\t\tif (r === void 0)\n\t\t\t\tluaL_error(L, to_luastring(\"bad '__pairs' result (object with keys 'iter', 'state', 'first' expected)\"));\n\t\t\titer = r.iter;\n\t\t\tif (iter === void 0)\n\t\t\t\tluaL_error(L, to_luastring(\"bad '__pairs' result (object.iter is missing)\"));\n\t\t\tstate = r.state;\n\t\t\tfirst = r.first;\n\t\t}\n\t\tlua_pushcfunction(L, function() {\n\t\t\tlet state = tojs(L, 1);\n\t\t\tlet last = tojs(L, 2);\n\t\t\tlet r = apply(iter, state, [last]);\n\t\t\t/* returning undefined indicates end of iteration */\n\t\t\tif (r === void 0)\n\t\t\t\treturn 0;\n\t\t\t/* otherwise it should return an array of results */\n\t\t\tif (!Array.isArray(r))\n\t\t\t\tluaL_error(L, to_luastring(\"bad iterator result (Array or undefined expected)\"));\n\t\t\tluaL_checkstack(L, r.length, null);\n\t\t\tfor (let i=0; i<r.length; i++) {\n\t\t\t\tpush(L, r[i]);\n\t\t\t}\n\t\t\treturn r.length;\n\t\t});\n\t\tpush(L, state);\n\t\tpush(L, first);\n\t\treturn 3;\n\t},\n\t\"__len\": function(L) {\n\t\tlet u = checkjs(L, 1);\n\t\tlet f;\n\t\tlet r;\n\t\tif (typeof Symbol !== \"function\" || (f = u[Symbol.for(\"__len\")]) === void 0) {\n\t\t\t/* by default use .length field */\n\t\t\tr = u.length;\n\t\t} else {\n\t\t\tr = apply(f, u, []);\n\t\t}\n\t\tpush(L, r);\n\t\treturn 1;\n\t}\n};\n\nconst luaopen_js = function(L) {\n\t/* Add weak map to track objects seen */\n\tstates.set(getmainthread(L), new WeakMap());\n\n\tlua_atnativeerror(L, atnativeerror);\n\n\tluaL_newlib(L, jslib);\n\tlua_pushliteral(L, FENGARI_INTEROP_VERSION);\n\tlua_setfield(L, -2, to_luastring(\"_VERSION\"));\n\tlua_pushinteger(L, FENGARI_INTEROP_VERSION_NUM);\n\tlua_setfield(L, -2, to_luastring(\"_VERSION_NUM\"));\n\tlua_pushliteral(L, FENGARI_INTEROP_RELEASE);\n\tlua_setfield(L, -2, to_luastring(\"_RELEASE\"));\n\n\tluaL_newmetatable(L, js_tname);\n\tluaL_setfuncs(L, jsmt, 0);\n\tlua_pop(L, 1);\n\n\tpushjs(L, null);\n\t/* Store null object in registry under lightuserdata null */\n\tlua_pushvalue(L, -1);\n\tlua_rawsetp(L, LUA_REGISTRYINDEX, null);\n\tlua_setfield(L, -2, to_luastring(\"null\"));\n\n\tpush(L, global_env);\n\tlua_setfield(L, -2, to_luastring(\"global\"));\n\n\treturn 1;\n};\n\nmodule.exports.FENGARI_INTEROP_VERSION = FENGARI_INTEROP_VERSION;\nmodule.exports.FENGARI_INTEROP_VERSION_NUM = FENGARI_INTEROP_VERSION_NUM;\nmodule.exports.FENGARI_INTEROP_RELEASE = FENGARI_INTEROP_RELEASE;\nmodule.exports.checkjs = checkjs;\nmodule.exports.testjs = testjs;\nmodule.exports.pushjs = pushjs;\nmodule.exports.push = push;\nmodule.exports.tojs = tojs;\nmodule.exports.luaopen_js = luaopen_js;\n","\"use strict\";\n\nconst { luastring_of } = require('./defs.js');\n\nconst luai_ctype_ = luastring_of(\n    0x00,  /* EOZ */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* 0. */\n    0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* 1. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,        /* 2. */\n    0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\n    0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,        /* 3. */\n    0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\n    0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,        /* 4. */\n    0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\n    0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,        /* 5. */\n    0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,\n    0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,        /* 6. */\n    0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\n    0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,        /* 7. */\n    0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* 8. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* 9. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* a. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* b. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* c. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* d. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* e. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,        /* f. */\n    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00\n);\n\nconst ALPHABIT = 0;\nconst DIGITBIT = 1;\nconst PRINTBIT = 2;\nconst SPACEBIT = 3;\nconst XDIGITBIT = 4;\n\nconst lisdigit = function(c) {\n    return (luai_ctype_[c+1] & (1<<DIGITBIT)) !== 0;\n};\n\nconst lisxdigit = function(c) {\n    return (luai_ctype_[c+1] & (1<<XDIGITBIT)) !== 0;\n};\n\nconst lisprint = function(c) {\n    return (luai_ctype_[c+1] & (1<<PRINTBIT)) !== 0;\n};\n\nconst lisspace = function(c) {\n    return (luai_ctype_[c+1] & (1<<SPACEBIT)) !== 0;\n};\n\nconst lislalpha = function(c) {\n    return (luai_ctype_[c+1] & (1<<ALPHABIT)) !== 0;\n};\n\nconst lislalnum = function(c) {\n    return (luai_ctype_[c+1] & ((1<<ALPHABIT)|(1<<DIGITBIT))) !== 0;\n};\n\nmodule.exports.lisdigit   = lisdigit;\nmodule.exports.lislalnum  = lislalnum;\nmodule.exports.lislalpha  = lislalpha;\nmodule.exports.lisprint   = lisprint;\nmodule.exports.lisspace   = lisspace;\nmodule.exports.lisxdigit  = lisxdigit;\n","\"use strict\";\n\nconst {\n    LUA_MULTRET,\n    to_luastring\n} = require('./defs.js');\nconst {\n    BinOpr: {\n        OPR_ADD,\n        OPR_AND,\n        OPR_BAND,\n        OPR_BOR,\n        OPR_BXOR,\n        OPR_CONCAT,\n        OPR_DIV,\n        OPR_EQ,\n        OPR_GE,\n        OPR_GT,\n        OPR_IDIV,\n        OPR_LE,\n        OPR_LT,\n        OPR_MOD,\n        OPR_MUL,\n        OPR_NE,\n        OPR_NOBINOPR,\n        OPR_OR,\n        OPR_POW,\n        OPR_SHL,\n        OPR_SHR,\n        OPR_SUB\n    },\n    UnOpr: {\n        OPR_BNOT,\n        OPR_LEN,\n        OPR_MINUS,\n        OPR_NOT,\n        OPR_NOUNOPR\n    },\n    NO_JUMP,\n    getinstruction,\n    luaK_checkstack,\n    luaK_codeABC,\n    luaK_codeABx,\n    luaK_codeAsBx,\n    luaK_codek,\n    luaK_concat,\n    luaK_dischargevars,\n    luaK_exp2RK,\n    luaK_exp2anyreg,\n    luaK_exp2anyregup,\n    luaK_exp2nextreg,\n    luaK_exp2val,\n    luaK_fixline,\n    luaK_getlabel,\n    luaK_goiffalse,\n    luaK_goiftrue,\n    luaK_indexed,\n    luaK_infix,\n    luaK_intK,\n    luaK_jump,\n    luaK_jumpto,\n    luaK_nil,\n    luaK_patchclose,\n    luaK_patchlist,\n    luaK_patchtohere,\n    luaK_posfix,\n    luaK_prefix,\n    luaK_reserveregs,\n    luaK_ret,\n    luaK_self,\n    luaK_setlist,\n    luaK_setmultret,\n    luaK_setoneret,\n    luaK_setreturns,\n    luaK_storevar,\n    luaK_stringK\n} = require('./lcode.js');\nconst ldo      = require('./ldo.js');\nconst lfunc    = require('./lfunc.js');\nconst llex     = require('./llex.js');\nconst {\n    LUAI_MAXCCALLS,\n    MAX_INT,\n    lua_assert\n}  = require('./llimits.js');\nconst lobject  = require('./lobject.js');\nconst {\n    OpCodesI: {\n        OP_CALL,\n        OP_CLOSURE,\n        OP_FORLOOP,\n        OP_FORPREP,\n        OP_GETUPVAL,\n        OP_MOVE,\n        OP_NEWTABLE,\n        OP_SETTABLE,\n        OP_TAILCALL,\n        OP_TFORCALL,\n        OP_TFORLOOP,\n        OP_VARARG\n    },\n    LFIELDS_PER_FLUSH,\n    SETARG_B,\n    SETARG_C,\n    SET_OPCODE\n} = require('./lopcodes.js');\nconst {\n    luaS_eqlngstr,\n    luaS_new,\n    luaS_newliteral\n} = require('./lstring.js');\nconst ltable   = require('./ltable.js');\nconst Proto    = lfunc.Proto;\nconst R        = llex.RESERVED;\n\nconst MAXVARS = 200;\n\nconst hasmultret = function(k) {\n    return k === expkind.VCALL || k === expkind.VVARARG;\n};\n\nconst eqstr = function(a, b) {\n    /* TODO: use plain equality as strings are cached */\n    return luaS_eqlngstr(a, b);\n};\n\nclass BlockCnt {\n    constructor() {\n        this.previous = null;  /* chain */\n        this.firstlabel = NaN; /* index of first label in this block */\n        this.firstgoto = NaN;  /* index of first pending goto in this block */\n        this.nactvar = NaN;    /* # active locals outside the block */\n        this.upval = NaN;      /* true if some variable in the block is an upvalue */\n        this.isloop = NaN;     /* true if 'block' is a loop */\n    }\n}\n\nconst expkind = {\n    VVOID: 0,        /* when 'expdesc' describes the last expression a list,\n                        this kind means an empty list (so, no expression) */\n    VNIL: 1,         /* constant nil */\n    VTRUE: 2,        /* constant true */\n    VFALSE: 3,       /* constant false */\n    VK: 4,           /* constant in 'k'; info = index of constant in 'k' */\n    VKFLT: 5,        /* floating constant; nval = numerical float value */\n    VKINT: 6,        /* integer constant; nval = numerical integer value */\n    VNONRELOC: 7,    /* expression has its value in a fixed register;\n                        info = result register */\n    VLOCAL: 8,       /* local variable; info = local register */\n    VUPVAL: 9,       /* upvalue variable; info = index of upvalue in 'upvalues' */\n    VINDEXED: 10,    /* indexed variable;\n                        ind.vt = whether 't' is register or upvalue;\n                        ind.t = table register or upvalue;\n                        ind.idx = key's R/K index */\n    VJMP: 11,        /* expression is a test/comparison;\n                        info = pc of corresponding jump instruction */\n    VRELOCABLE: 12,  /* expression can put result in any register;\n                        info = instruction pc */\n    VCALL: 13,       /* expression is a function call; info = instruction pc */\n    VVARARG: 14      /* vararg expression; info = instruction pc */\n};\n\nconst vkisvar = function(k) {\n    return expkind.VLOCAL <= k && k <= expkind.VINDEXED;\n};\n\nconst vkisinreg = function(k) {\n    return k === expkind.VNONRELOC || k === expkind.VLOCAL;\n};\n\nclass expdesc {\n    constructor() {\n        this.k = NaN;\n        this.u = {\n            ival: NaN,    /* for VKINT */\n            nval: NaN,    /* for VKFLT */\n            info: NaN,    /* for generic use */\n            ind: {        /* for indexed variables (VINDEXED) */\n                idx: NaN, /* index (R/K) */\n                t: NaN,   /* table (register or upvalue) */\n                vt: NaN   /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */\n            }\n        };\n        this.t = NaN;     /* patch list of 'exit when true' */\n        this.f = NaN;     /* patch list of 'exit when false' */\n    }\n\n    to(e) { // Copy e content to this, cf. luaK_posfix\n        this.k = e.k;\n        this.u = e.u;\n        this.t = e.t;\n        this.f = e.f;\n    }\n}\n\nclass FuncState {\n    constructor() {\n        this.f = null;         /* current function header */\n        this.prev = null;      /* enclosing function */\n        this.ls = null;        /* lexical state */\n        this.bl = null;        /* chain of current blocks */\n        this.pc = NaN;         /* next position to code (equivalent to 'ncode') */\n        this.lasttarget = NaN; /* 'label' of last 'jump label' */\n        this.jpc = NaN;        /* list of pending jumps to 'pc' */\n        this.nk = NaN;         /* number of elements in 'k' */\n        this.np = NaN;         /* number of elements in 'p' */\n        this.firstlocal = NaN; /* index of first local var (in Dyndata array) */\n        this.nlocvars = NaN;   /* number of elements in 'f->locvars' */\n        this.nactvar = NaN;    /* number of active local variables */\n        this.nups = NaN;       /* number of upvalues */\n        this.freereg = NaN;    /* first free register */\n    }\n}\n\n/* description of active local variable */\nclass Vardesc {\n    constructor() {\n        this.idx = NaN;  /* variable index in stack */\n    }\n}\n\n\n/* description of pending goto statements and label statements */\nclass Labeldesc {\n    constructor() {\n        this.name = null;  /* label identifier */\n        this.pc = NaN;  /* position in code */\n        this.line = NaN;  /* line where it appeared */\n        this.nactvar = NaN;  /* local level where it appears in current block */\n    }\n}\n\n\n/* list of labels or gotos */\nclass Labellist {\n    constructor() {\n        this.arr = []; /* array */\n        this.n = NaN;  /* number of entries in use */\n        this.size = NaN;  /* array size */\n    }\n}\n\n/* dynamic structures used by the parser */\nclass Dyndata {\n    constructor() {\n        this.actvar = {  /* list of active local variables */\n            arr: [],\n            n: NaN,\n            size: NaN\n        };\n        this.gt = new Labellist();\n        this.label = new Labellist();\n    }\n}\n\nconst semerror = function(ls, msg) {\n    ls.t.token = 0;  /* remove \"near <token>\" from final message */\n    llex.luaX_syntaxerror(ls, msg);\n};\n\nconst error_expected = function(ls, token) {\n    llex.luaX_syntaxerror(ls, lobject.luaO_pushfstring(ls.L, to_luastring(\"%s expected\", true), llex.luaX_token2str(ls, token)));\n};\n\nconst errorlimit = function(fs, limit, what) {\n    let L = fs.ls.L;\n    let line = fs.f.linedefined;\n    let where = (line === 0)\n        ? to_luastring(\"main function\", true)\n        : lobject.luaO_pushfstring(L, to_luastring(\"function at line %d\", true), line);\n    let msg = lobject.luaO_pushfstring(L, to_luastring(\"too many %s (limit is %d) in %s\", true),\n        what, limit, where);\n    llex.luaX_syntaxerror(fs.ls, msg);\n};\n\nconst checklimit = function(fs, v, l, what) {\n    if (v > l) errorlimit(fs, l, what);\n};\n\nconst testnext = function(ls, c) {\n    if (ls.t.token === c) {\n        llex.luaX_next(ls);\n        return true;\n    }\n\n    return false;\n};\n\nconst check = function(ls, c) {\n    if (ls.t.token !== c)\n        error_expected(ls, c);\n};\n\nconst checknext = function(ls, c) {\n    check(ls, c);\n    llex.luaX_next(ls);\n};\n\nconst check_condition = function(ls, c, msg) {\n    if (!c)\n        llex.luaX_syntaxerror(ls, msg);\n};\n\nconst check_match = function(ls, what, who, where) {\n    if (!testnext(ls, what)) {\n        if (where === ls.linenumber)\n            error_expected(ls, what);\n        else\n            llex.luaX_syntaxerror(ls, lobject.luaO_pushfstring(ls.L,\n                to_luastring(\"%s expected (to close %s at line %d)\"),\n                llex.luaX_token2str(ls, what), llex.luaX_token2str(ls, who), where));\n    }\n};\n\nconst str_checkname = function(ls) {\n    check(ls, R.TK_NAME);\n    let ts = ls.t.seminfo.ts;\n    llex.luaX_next(ls);\n    return ts;\n};\n\nconst init_exp = function(e, k, i) {\n    e.f = e.t = NO_JUMP;\n    e.k = k;\n    e.u.info = i;\n};\n\nconst codestring = function(ls, e, s) {\n    init_exp(e, expkind.VK, luaK_stringK(ls.fs, s));\n};\n\nconst checkname = function(ls, e) {\n    codestring(ls, e, str_checkname(ls));\n};\n\nconst registerlocalvar = function(ls, varname) {\n    let fs = ls.fs;\n    let f = fs.f;\n    f.locvars[fs.nlocvars] = new lobject.LocVar();\n    f.locvars[fs.nlocvars].varname = varname;\n    return fs.nlocvars++;\n};\n\nconst new_localvar = function(ls, name) {\n    let fs = ls.fs;\n    let dyd = ls.dyd;\n    let reg = registerlocalvar(ls, name);\n    checklimit(fs, dyd.actvar.n + 1 - fs.firstlocal, MAXVARS, to_luastring(\"local variables\", true));\n    dyd.actvar.arr[dyd.actvar.n] = new Vardesc();\n    dyd.actvar.arr[dyd.actvar.n].idx = reg;\n    dyd.actvar.n++;\n};\n\nconst new_localvarliteral = function(ls, name) {\n    new_localvar(ls, llex.luaX_newstring(ls, to_luastring(name, true)));\n};\n\nconst getlocvar = function(fs, i) {\n    let idx = fs.ls.dyd.actvar.arr[fs.firstlocal + i].idx;\n    lua_assert(idx < fs.nlocvars);\n    return fs.f.locvars[idx];\n};\n\nconst adjustlocalvars = function(ls, nvars) {\n    let fs = ls.fs;\n    fs.nactvar = fs.nactvar + nvars;\n    for (; nvars; nvars--)\n        getlocvar(fs, fs.nactvar - nvars).startpc = fs.pc;\n};\n\nconst removevars = function(fs, tolevel) {\n    fs.ls.dyd.actvar.n -= fs.nactvar - tolevel;\n    while (fs.nactvar > tolevel)\n        getlocvar(fs, --fs.nactvar).endpc = fs.pc;\n};\n\nconst searchupvalue = function(fs, name) {\n    let up = fs.f.upvalues;\n    for (let i = 0; i < fs.nups; i++) {\n        if (eqstr(up[i].name, name))\n            return i;\n    }\n    return -1;  /* not found */\n};\n\nconst newupvalue = function(fs, name, v) {\n    let f = fs.f;\n    checklimit(fs, fs.nups + 1, lfunc.MAXUPVAL, to_luastring(\"upvalues\", true));\n    f.upvalues[fs.nups] = {\n        instack: v.k === expkind.VLOCAL,\n        idx: v.u.info,\n        name: name\n    };\n    return fs.nups++;\n};\n\nconst searchvar = function(fs, n) {\n    for (let i = fs.nactvar - 1; i >= 0; i--) {\n        if (eqstr(n, getlocvar(fs, i).varname))\n            return i;\n    }\n\n    return -1;\n};\n\n/*\n** Mark block where variable at given level was defined\n** (to emit close instructions later).\n*/\nconst markupval = function(fs, level) {\n    let bl = fs.bl;\n    while (bl.nactvar > level)\n        bl = bl.previous;\n    bl.upval = 1;\n};\n\n/*\n** Find variable with given name 'n'. If it is an upvalue, add this\n** upvalue into all intermediate functions.\n*/\nconst singlevaraux = function(fs, n, vr, base) {\n    if (fs === null)  /* no more levels? */\n        init_exp(vr, expkind.VVOID, 0);  /* default is global */\n    else {\n        let v = searchvar(fs, n);  /* look up locals at current level */\n        if (v >= 0) {  /* found? */\n            init_exp(vr, expkind.VLOCAL, v);  /* variable is local */\n            if (!base)\n                markupval(fs, v);  /* local will be used as an upval */\n        } else {  /* not found as local at current level; try upvalues */\n            let idx = searchupvalue(fs, n);  /* try existing upvalues */\n            if (idx < 0) {  /* not found? */\n                singlevaraux(fs.prev, n, vr, 0);  /* try upper levels */\n                if (vr.k === expkind.VVOID)  /* not found? */\n                    return;  /* it is a global */\n                /* else was LOCAL or UPVAL */\n                idx = newupvalue(fs, n, vr);  /* will be a new upvalue */\n            }\n            init_exp(vr, expkind.VUPVAL, idx);  /* new or old upvalue */\n        }\n    }\n};\n\nconst singlevar = function(ls, vr) {\n    let varname = str_checkname(ls);\n    let fs = ls.fs;\n    singlevaraux(fs, varname, vr, 1);\n    if (vr.k === expkind.VVOID) {  /* is global name? */\n        let key = new expdesc();\n        singlevaraux(fs, ls.envn, vr, 1);  /* get environment variable */\n        lua_assert(vr.k !== expkind.VVOID);  /* this one must exist */\n        codestring(ls, key, varname);  /* key is variable name */\n        luaK_indexed(fs, vr, key);  /* env[varname] */\n    }\n};\n\nconst adjust_assign = function(ls, nvars, nexps, e) {\n    let fs = ls.fs;\n    let extra = nvars - nexps;\n    if (hasmultret(e.k)) {\n        extra++;  /* includes call itself */\n        if (extra < 0) extra = 0;\n        luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */\n        if (extra > 1) luaK_reserveregs(fs, extra - 1);\n    } else {\n        if (e.k !== expkind.VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */\n        if (extra > 0) {\n            let reg = fs.freereg;\n            luaK_reserveregs(fs, extra);\n            luaK_nil(fs, reg, extra);\n        }\n    }\n    if (nexps > nvars)\n        ls.fs.freereg -= nexps - nvars;  /* remove extra values */\n};\n\nconst enterlevel = function(ls) {\n    let L = ls.L;\n    ++L.nCcalls;\n    checklimit(ls.fs, L.nCcalls, LUAI_MAXCCALLS, to_luastring(\"JS levels\", true));\n};\n\nconst leavelevel = function(ls) {\n    return ls.L.nCcalls--;\n};\n\nconst closegoto = function(ls, g, label) {\n    let fs = ls.fs;\n    let gl = ls.dyd.gt;\n    let gt = gl.arr[g];\n    lua_assert(eqstr(gt.name, label.name));\n    if (gt.nactvar < label.nactvar) {\n        let vname = getlocvar(fs, gt.nactvar).varname;\n        let msg = lobject.luaO_pushfstring(ls.L,\n            to_luastring(\"<goto %s> at line %d jumps into the scope of local '%s'\"),\n            gt.name.getstr(), gt.line, vname.getstr());\n        semerror(ls, msg);\n    }\n    luaK_patchlist(fs, gt.pc, label.pc);\n    /* remove goto from pending list */\n    for (let i = g; i < gl.n - 1; i++)\n        gl.arr[i] = gl.arr[i + 1];\n    gl.n--;\n};\n\n/*\n** try to close a goto with existing labels; this solves backward jumps\n*/\nconst findlabel = function(ls, g) {\n    let bl = ls.fs.bl;\n    let dyd = ls.dyd;\n    let gt = dyd.gt.arr[g];\n    /* check labels in current block for a match */\n    for (let i = bl.firstlabel; i < dyd.label.n; i++) {\n        let lb = dyd.label.arr[i];\n        if (eqstr(lb.name, gt.name)) {  /* correct label? */\n            if (gt.nactvar > lb.nactvar && (bl.upval || dyd.label.n > bl.firstlabel))\n                luaK_patchclose(ls.fs, gt.pc, lb.nactvar);\n            closegoto(ls, g, lb);  /* close it */\n            return true;\n        }\n    }\n    return false;  /* label not found; cannot close goto */\n};\n\nconst newlabelentry = function(ls, l, name, line, pc) {\n    let n = l.n;\n    l.arr[n] = new Labeldesc();\n    l.arr[n].name = name;\n    l.arr[n].line = line;\n    l.arr[n].nactvar = ls.fs.nactvar;\n    l.arr[n].pc = pc;\n    l.n = n + 1;\n    return n;\n};\n\n/*\n** check whether new label 'lb' matches any pending gotos in current\n** block; solves forward jumps\n*/\nconst findgotos = function(ls, lb) {\n    let gl = ls.dyd.gt;\n    let i = ls.fs.bl.firstgoto;\n    while (i < gl.n) {\n        if (eqstr(gl.arr[i].name, lb.name))\n            closegoto(ls, i, lb);\n        else\n            i++;\n    }\n};\n\n/*\n** export pending gotos to outer level, to check them against\n** outer labels; if the block being exited has upvalues, and\n** the goto exits the scope of any variable (which can be the\n** upvalue), close those variables being exited.\n*/\nconst movegotosout = function(fs, bl) {\n    let i = bl.firstgoto;\n    let gl = fs.ls.dyd.gt;\n    /* correct pending gotos to current block and try to close it\n       with visible labels */\n    while (i < gl.n) {\n        let gt = gl.arr[i];\n        if (gt.nactvar > bl.nactvar) {\n            if (bl.upval)\n                luaK_patchclose(fs, gt.pc, bl.nactvar);\n            gt.nactvar = bl.nactvar;\n        }\n        if (!findlabel(fs.ls, i))\n            i++;  /* move to next one */\n    }\n};\n\nconst enterblock = function(fs, bl, isloop) {\n    bl.isloop = isloop;\n    bl.nactvar = fs.nactvar;\n    bl.firstlabel = fs.ls.dyd.label.n;\n    bl.firstgoto = fs.ls.dyd.gt.n;\n    bl.upval = 0;\n    bl.previous = fs.bl;\n    fs.bl = bl;\n    lua_assert(fs.freereg === fs.nactvar);\n};\n\n/*\n** create a label named 'break' to resolve break statements\n*/\nconst breaklabel = function(ls) {\n    let n = luaS_newliteral(ls.L, \"break\");\n    let l = newlabelentry(ls, ls.dyd.label, n, 0, ls.fs.pc);\n    findgotos(ls, ls.dyd.label.arr[l]);\n};\n\n/*\n** generates an error for an undefined 'goto'; choose appropriate\n** message when label name is a reserved word (which can only be 'break')\n*/\nconst undefgoto = function(ls, gt) {\n    let msg = llex.isreserved(gt.name)\n        ? \"<%s> at line %d not inside a loop\"\n        : \"no visible label '%s' for <goto> at line %d\";\n    msg = lobject.luaO_pushfstring(ls.L, to_luastring(msg), gt.name.getstr(), gt.line);\n    semerror(ls, msg);\n};\n\n/*\n** adds a new prototype into list of prototypes\n*/\nconst addprototype = function(ls) {\n    let L = ls.L;\n    let clp = new Proto(L);\n    let fs = ls.fs;\n    let f = fs.f;  /* prototype of current function */\n    f.p[fs.np++] = clp;\n    return clp;\n};\n\n/*\n** codes instruction to create new closure in parent function.\n*/\nconst codeclosure = function(ls, v) {\n    let fs = ls.fs.prev;\n    init_exp(v, expkind.VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs.np -1));\n    luaK_exp2nextreg(fs, v);  /* fix it at the last register */\n};\n\nconst open_func = function(ls, fs, bl) {\n    fs.prev = ls.fs;  /* linked list of funcstates */\n    fs.ls = ls;\n    ls.fs = fs;\n    fs.pc = 0;\n    fs.lasttarget = 0;\n    fs.jpc = NO_JUMP;\n    fs.freereg = 0;\n    fs.nk = 0;\n    fs.np = 0;\n    fs.nups = 0;\n    fs.nlocvars = 0;\n    fs.nactvar = 0;\n    fs.firstlocal = ls.dyd.actvar.n;\n    fs.bl = null;\n    let f = fs.f;\n    f.source = ls.source;\n    f.maxstacksize = 2;  /* registers 0/1 are always valid */\n    enterblock(fs, bl, false);\n};\n\nconst leaveblock = function(fs) {\n    let bl = fs.bl;\n    let ls = fs.ls;\n    if (bl.previous && bl.upval) {\n        /* create a 'jump to here' to close upvalues */\n        let j = luaK_jump(fs);\n        luaK_patchclose(fs, j , bl.nactvar);\n        luaK_patchtohere(fs, j);\n    }\n\n    if (bl.isloop)\n        breaklabel(ls);  /* close pending breaks */\n\n    fs.bl = bl.previous;\n    removevars(fs, bl.nactvar);\n    lua_assert(bl.nactvar === fs.nactvar);\n    fs.freereg = fs.nactvar;  /* free registers */\n    ls.dyd.label.n = bl.firstlabel;  /* remove local labels */\n    if (bl.previous)  /* inner block? */\n        movegotosout(fs, bl);  /* update pending gotos to outer block */\n    else if (bl.firstgoto < ls.dyd.gt.n)  /* pending gotos in outer block? */\n        undefgoto(ls, ls.dyd.gt.arr[bl.firstgoto]);  /* error */\n};\n\nconst close_func = function(ls) {\n    let fs = ls.fs;\n    luaK_ret(fs, 0, 0);  /* final return */\n    leaveblock(fs);\n    lua_assert(fs.bl === null);\n    ls.fs = fs.prev;\n};\n\n/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n\nconst block_follow = function(ls, withuntil) {\n    switch (ls.t.token) {\n        case R.TK_ELSE: case R.TK_ELSEIF:\n        case R.TK_END: case R.TK_EOS:\n            return true;\n        case R.TK_UNTIL: return withuntil;\n        default: return false;\n    }\n};\n\nconst statlist = function(ls) {\n    /* statlist -> { stat [';'] } */\n    while (!block_follow(ls, 1)) {\n        if (ls.t.token === R.TK_RETURN) {\n            statement(ls);\n            return;  /* 'return' must be last statement */\n        }\n        statement(ls);\n    }\n};\n\nconst fieldsel = function(ls, v) {\n    /* fieldsel -> ['.' | ':'] NAME */\n    let fs = ls.fs;\n    let key = new expdesc();\n    luaK_exp2anyregup(fs, v);\n    llex.luaX_next(ls);  /* skip the dot or colon */\n    checkname(ls, key);\n    luaK_indexed(fs, v, key);\n};\n\nconst yindex = function(ls, v) {\n    /* index -> '[' expr ']' */\n    llex.luaX_next(ls);  /* skip the '[' */\n    expr(ls, v);\n    luaK_exp2val(ls.fs, v);\n    checknext(ls, 93 /* (']').charCodeAt(0) */);\n};\n\n/*\n** {======================================================================\n** Rules for Constructors\n** =======================================================================\n*/\n\nclass ConsControl {\n    constructor() {\n        this.v = new expdesc(); /* last list item read */\n        this.t = new expdesc(); /* table descriptor */\n        this.nh = NaN;          /* total number of 'record' elements */\n        this.na = NaN;          /* total number of array elements */\n        this.tostore = NaN;     /* number of array elements pending to be stored */\n    }\n}\n\nconst recfield = function(ls, cc) {\n    /* recfield -> (NAME | '['exp1']') = exp1 */\n    let fs = ls.fs;\n    let reg = ls.fs.freereg;\n    let key = new expdesc();\n    let val = new expdesc();\n\n    if (ls.t.token === R.TK_NAME) {\n        checklimit(fs, cc.nh, MAX_INT, to_luastring(\"items in a constructor\", true));\n        checkname(ls, key);\n    } else  /* ls->t.token === '[' */\n        yindex(ls, key);\n    cc.nh++;\n    checknext(ls, 61 /* ('=').charCodeAt(0) */);\n    let rkkey = luaK_exp2RK(fs, key);\n    expr(ls, val);\n    luaK_codeABC(fs, OP_SETTABLE, cc.t.u.info, rkkey, luaK_exp2RK(fs, val));\n    fs.freereg = reg;  /* free registers */\n};\n\nconst closelistfield = function(fs, cc) {\n    if (cc.v.k === expkind.VVOID) return;  /* there is no list item */\n    luaK_exp2nextreg(fs, cc.v);\n    cc.v.k = expkind.VVOID;\n    if (cc.tostore === LFIELDS_PER_FLUSH) {\n        luaK_setlist(fs, cc.t.u.info, cc.na, cc.tostore);  /* flush */\n        cc.tostore = 0;  /* no more items pending */\n    }\n};\n\nconst lastlistfield = function(fs, cc) {\n    if (cc.tostore === 0) return;\n    if (hasmultret(cc.v.k)) {\n        luaK_setmultret(fs, cc.v);\n        luaK_setlist(fs, cc.t.u.info, cc.na, LUA_MULTRET);\n        cc.na--;  /* do not count last expression (unknown number of elements) */\n    } else {\n        if (cc.v.k !== expkind.VVOID)\n            luaK_exp2nextreg(fs, cc.v);\n        luaK_setlist(fs, cc.t.u.info, cc.na, cc.tostore);\n    }\n};\n\nconst listfield = function(ls, cc) {\n    /* listfield -> exp */\n    expr(ls, cc.v);\n    checklimit(ls.fs, cc.na, MAX_INT, to_luastring(\"items in a constructor\", true));\n    cc.na++;\n    cc.tostore++;\n};\n\nconst field = function(ls, cc) {\n    /* field -> listfield | recfield */\n    switch (ls.t.token) {\n        case R.TK_NAME: {  /* may be 'listfield' or 'recfield' */\n            if (llex.luaX_lookahead(ls) !== 61 /* ('=').charCodeAt(0) */)  /* expression? */\n                listfield(ls, cc);\n            else\n                recfield(ls, cc);\n            break;\n        }\n        case 91 /* ('[').charCodeAt(0) */: {\n            recfield(ls, cc);\n            break;\n        }\n        default: {\n            listfield(ls, cc);\n            break;\n        }\n    }\n};\n\nconst constructor = function(ls, t) {\n    /* constructor -> '{' [ field { sep field } [sep] ] '}'\n       sep -> ',' | ';' */\n    let fs = ls.fs;\n    let line = ls.linenumber;\n    let pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);\n    let cc = new ConsControl();\n    cc.na = cc.nh = cc.tostore = 0;\n    cc.t = t;\n    init_exp(t, expkind.VRELOCABLE, pc);\n    init_exp(cc.v, expkind.VVOID, 0);  /* no value (yet) */\n    luaK_exp2nextreg(ls.fs, t);  /* fix it at stack top */\n    checknext(ls, 123 /* ('{').charCodeAt(0) */);\n    do {\n        lua_assert(cc.v.k === expkind.VVOID || cc.tostore > 0);\n        if (ls.t.token === 125 /* ('}').charCodeAt(0) */) break;\n        closelistfield(fs, cc);\n        field(ls, cc);\n    } while (testnext(ls, 44 /* (',').charCodeAt(0) */) || testnext(ls, 59 /* (';').charCodeAt(0) */));\n    check_match(ls, 125 /* ('}').charCodeAt(0) */, 123 /* ('{').charCodeAt(0) */, line);\n    lastlistfield(fs, cc);\n    SETARG_B(fs.f.code[pc], lobject.luaO_int2fb(cc.na));  /* set initial array size */\n    SETARG_C(fs.f.code[pc], lobject.luaO_int2fb(cc.nh));  /* set initial table size */\n};\n\n/* }====================================================================== */\n\nconst parlist = function(ls) {\n    /* parlist -> [ param { ',' param } ] */\n    let fs = ls.fs;\n    let f = fs.f;\n    let nparams = 0;\n    f.is_vararg = false;\n    if (ls.t.token !== 41 /* (')').charCodeAt(0) */) {  /* is 'parlist' not empty? */\n        do {\n            switch (ls.t.token) {\n                case R.TK_NAME: {  /* param -> NAME */\n                    new_localvar(ls, str_checkname(ls));\n                    nparams++;\n                    break;\n                }\n                case R.TK_DOTS: {  /* param -> '...' */\n                    llex.luaX_next(ls);\n                    f.is_vararg = true;  /* declared vararg */\n                    break;\n                }\n                default: llex.luaX_syntaxerror(ls, to_luastring(\"<name> or '...' expected\", true));\n            }\n        } while(!f.is_vararg && testnext(ls, 44 /* (',').charCodeAt(0) */));\n    }\n    adjustlocalvars(ls, nparams);\n    f.numparams = fs.nactvar;\n    luaK_reserveregs(fs, fs.nactvar);  /* reserve register for parameters */\n};\n\nconst body = function(ls, e, ismethod, line) {\n    /* body ->  '(' parlist ')' block END */\n    let new_fs = new FuncState();\n    let bl = new BlockCnt();\n    new_fs.f = addprototype(ls);\n    new_fs.f.linedefined = line;\n    open_func(ls, new_fs, bl);\n    checknext(ls, 40 /* ('(').charCodeAt(0) */);\n    if (ismethod) {\n        new_localvarliteral(ls, \"self\");  /* create 'self' parameter */\n        adjustlocalvars(ls, 1);\n    }\n    parlist(ls);\n    checknext(ls, 41 /* (')').charCodeAt(0) */);\n    statlist(ls);\n    new_fs.f.lastlinedefined = ls.linenumber;\n    check_match(ls, R.TK_END, R.TK_FUNCTION, line);\n    codeclosure(ls, e);\n    close_func(ls);\n};\n\nconst explist = function(ls, v) {\n    /* explist -> expr { ',' expr } */\n    let n = 1;  /* at least one expression */\n    expr(ls, v);\n    while (testnext(ls, 44 /* (',').charCodeAt(0) */)) {\n        luaK_exp2nextreg(ls.fs, v);\n        expr(ls, v);\n        n++;\n    }\n    return n;\n};\n\nconst funcargs = function(ls, f, line) {\n    let fs = ls.fs;\n    let args = new expdesc();\n    switch (ls.t.token) {\n        case 40 /* ('(').charCodeAt(0) */: {  /* funcargs -> '(' [ explist ] ')' */\n            llex.luaX_next(ls);\n            if (ls.t.token === 41 /* (')').charCodeAt(0) */)  /* arg list is empty? */\n                args.k = expkind.VVOID;\n            else {\n                explist(ls, args);\n                luaK_setmultret(fs, args);\n            }\n            check_match(ls, 41 /* (')').charCodeAt(0) */, 40 /* ('(').charCodeAt(0) */, line);\n            break;\n        }\n        case 123 /* ('{').charCodeAt(0) */: {  /* funcargs -> constructor */\n            constructor(ls, args);\n            break;\n        }\n        case R.TK_STRING: {  /* funcargs -> STRING */\n            codestring(ls, args, ls.t.seminfo.ts);\n            llex.luaX_next(ls);  /* must use 'seminfo' before 'next' */\n            break;\n        }\n        default: {\n            llex.luaX_syntaxerror(ls, to_luastring(\"function arguments expected\", true));\n        }\n    }\n    lua_assert(f.k === expkind.VNONRELOC);\n    let nparams;\n    let base = f.u.info;  /* base register for call */\n    if (hasmultret(args.k))\n        nparams = LUA_MULTRET;  /* open call */\n    else {\n        if (args.k !== expkind.VVOID)\n            luaK_exp2nextreg(fs, args);  /* close last argument */\n        nparams = fs.freereg - (base+1);\n    }\n    init_exp(f, expkind.VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));\n    luaK_fixline(fs, line);\n    fs.freereg = base + 1; /* call remove function and arguments and leaves (unless changed) one result */\n};\n\n/*\n** {======================================================================\n** Expression parsing\n** =======================================================================\n*/\n\nconst primaryexp = function(ls, v) {\n    /* primaryexp -> NAME | '(' expr ')' */\n    switch (ls.t.token) {\n        case 40 /* ('(').charCodeAt(0) */: {\n            let line = ls.linenumber;\n            llex.luaX_next(ls);\n            expr(ls, v);\n            check_match(ls, 41 /* (')').charCodeAt(0) */, 40 /* ('(').charCodeAt(0) */, line);\n            luaK_dischargevars(ls.fs, v);\n            return;\n        }\n        case R.TK_NAME: {\n            singlevar(ls, v);\n            return;\n        }\n        default: {\n            llex.luaX_syntaxerror(ls, to_luastring(\"unexpected symbol\", true));\n        }\n    }\n};\n\nconst suffixedexp = function(ls, v) {\n    /* suffixedexp ->\n       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */\n    let fs = ls.fs;\n    let line = ls.linenumber;\n    primaryexp(ls, v);\n    for (;;) {\n        switch (ls.t.token) {\n            case 46 /* ('.').charCodeAt(0) */: {  /* fieldsel */\n                fieldsel(ls, v);\n                break;\n            }\n            case 91 /* ('[').charCodeAt(0) */: {  /* '[' exp1 ']' */\n                let key = new expdesc();\n                luaK_exp2anyregup(fs, v);\n                yindex(ls, key);\n                luaK_indexed(fs, v, key);\n                break;\n            }\n            case 58 /* (':').charCodeAt(0) */: {  /* ':' NAME funcargs */\n                let key = new expdesc();\n                llex.luaX_next(ls);\n                checkname(ls, key);\n                luaK_self(fs, v, key);\n                funcargs(ls, v, line);\n                break;\n            }\n            case 40 /* ('(').charCodeAt(0) */: case R.TK_STRING: case 123 /* ('{').charCodeAt(0) */: {  /* funcargs */\n                luaK_exp2nextreg(fs, v);\n                funcargs(ls, v, line);\n                break;\n            }\n            default: return;\n        }\n    }\n};\n\nconst simpleexp = function(ls, v) {\n    /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |\n       constructor | FUNCTION body | suffixedexp */\n    switch (ls.t.token) {\n        case R.TK_FLT: {\n            init_exp(v, expkind.VKFLT, 0);\n            v.u.nval = ls.t.seminfo.r;\n            break;\n        }\n        case R.TK_INT: {\n            init_exp(v, expkind.VKINT, 0);\n            v.u.ival = ls.t.seminfo.i;\n            break;\n        }\n        case R.TK_STRING: {\n            codestring(ls, v, ls.t.seminfo.ts);\n            break;\n        }\n        case R.TK_NIL: {\n            init_exp(v, expkind.VNIL, 0);\n            break;\n        }\n        case R.TK_TRUE: {\n            init_exp(v, expkind.VTRUE, 0);\n            break;\n        }\n        case R.TK_FALSE: {\n            init_exp(v, expkind.VFALSE, 0);\n            break;\n        }\n        case R.TK_DOTS: {  /* vararg */\n            let fs = ls.fs;\n            check_condition(ls, fs.f.is_vararg, to_luastring(\"cannot use '...' outside a vararg function\", true));\n            init_exp(v, expkind.VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));\n            break;\n        }\n        case 123 /* ('{').charCodeAt(0) */: {  /* constructor */\n            constructor(ls, v);\n            return;\n        }\n        case R.TK_FUNCTION: {\n            llex.luaX_next(ls);\n            body(ls, v, 0, ls.linenumber);\n            return;\n        }\n        default: {\n            suffixedexp(ls, v);\n            return;\n        }\n    }\n    llex.luaX_next(ls);\n};\n\nconst getunopr = function(op) {\n    switch (op) {\n        case R.TK_NOT: return OPR_NOT;\n        case 45 /* ('-').charCodeAt(0) */: return OPR_MINUS;\n        case 126 /* ('~').charCodeAt(0) */: return OPR_BNOT;\n        case 35 /* ('#').charCodeAt(0) */: return OPR_LEN;\n        default: return OPR_NOUNOPR;\n    }\n};\n\nconst getbinopr = function(op) {\n    switch (op) {\n        case 43 /* ('+').charCodeAt(0) */: return OPR_ADD;\n        case 45 /* ('-').charCodeAt(0) */: return OPR_SUB;\n        case 42 /* ('*').charCodeAt(0) */: return OPR_MUL;\n        case 37 /* ('%').charCodeAt(0) */: return OPR_MOD;\n        case 94 /* ('^').charCodeAt(0) */: return OPR_POW;\n        case 47 /* ('/').charCodeAt(0) */: return OPR_DIV;\n        case R.TK_IDIV:   return OPR_IDIV;\n        case 38 /* ('&').charCodeAt(0) */: return OPR_BAND;\n        case 124 /* ('|').charCodeAt(0) */: return OPR_BOR;\n        case 126 /* ('~').charCodeAt(0) */: return OPR_BXOR;\n        case R.TK_SHL:    return OPR_SHL;\n        case R.TK_SHR:    return OPR_SHR;\n        case R.TK_CONCAT: return OPR_CONCAT;\n        case R.TK_NE:     return OPR_NE;\n        case R.TK_EQ:     return OPR_EQ;\n        case 60 /* ('<').charCodeAt(0) */: return OPR_LT;\n        case R.TK_LE:     return OPR_LE;\n        case 62 /* ('>').charCodeAt(0) */: return OPR_GT;\n        case R.TK_GE:     return OPR_GE;\n        case R.TK_AND:    return OPR_AND;\n        case R.TK_OR:     return OPR_OR;\n        default:          return OPR_NOBINOPR;\n    }\n};\n\nconst priority = [  /* ORDER OPR */\n    {left: 10, right: 10}, {left: 10, right: 10},     /* '+' '-' */\n    {left: 11, right: 11}, {left: 11, right: 11},     /* '*' '%' */\n    {left: 14, right: 13},               /* '^' (right associative) */\n    {left: 11, right: 11}, {left: 11, right: 11},     /* '/' '//' */\n    {left: 6, right: 6}, {left: 4, right: 4}, {left: 5, right: 5}, /* '&' '|' '~' */\n    {left: 7, right: 7}, {left: 7, right: 7},         /* '<<' '>>' */\n    {left: 9, right: 8},                 /* '..' (right associative) */\n    {left: 3, right: 3}, {left: 3, right: 3}, {left: 3, right: 3}, /* ==, <, <= */\n    {left: 3, right: 3}, {left: 3, right: 3}, {left: 3, right: 3}, /* ~=, >, >= */\n    {left: 2, right: 2}, {left: 1, right: 1}          /* and, or */\n];\n\nconst UNARY_PRIORITY = 12;\n\n/*\n** subexpr -> (simpleexp | unop subexpr) { binop subexpr }\n** where 'binop' is any binary operator with a priority higher than 'limit'\n*/\nconst subexpr = function(ls, v, limit) {\n    enterlevel(ls);\n    let uop = getunopr(ls.t.token);\n    if (uop !== OPR_NOUNOPR) {\n        let line = ls.linenumber;\n        llex.luaX_next(ls);\n        subexpr(ls, v, UNARY_PRIORITY);\n        luaK_prefix(ls.fs, uop, v, line);\n    } else\n        simpleexp(ls, v);\n    /* expand while operators have priorities higher than 'limit' */\n    let op = getbinopr(ls.t.token);\n    while (op !== OPR_NOBINOPR && priority[op].left > limit) {\n        let v2 = new expdesc();\n        let line = ls.linenumber;\n        llex.luaX_next(ls);\n        luaK_infix(ls.fs, op, v);\n        /* read sub-expression with higher priority */\n        let nextop = subexpr(ls, v2, priority[op].right);\n        luaK_posfix(ls.fs, op, v, v2, line);\n        op = nextop;\n    }\n    leavelevel(ls);\n    return op;  /* return first untreated operator */\n};\n\nconst expr = function(ls, v) {\n    subexpr(ls, v, 0);\n};\n\n/* }==================================================================== */\n\n\n\n/*\n** {======================================================================\n** Rules for Statements\n** =======================================================================\n*/\n\nconst block = function(ls) {\n    /* block -> statlist */\n    let fs = ls.fs;\n    let bl = new BlockCnt();\n    enterblock(fs, bl, 0);\n    statlist(ls);\n    leaveblock(fs);\n};\n\n/*\n** structure to chain all variables in the left-hand side of an\n** assignment\n*/\nclass LHS_assign {\n    constructor() {\n        this.prev = null;\n        this.v = new expdesc();  /* variable (global, local, upvalue, or indexed) */\n    }\n}\n\n/*\n** check whether, in an assignment to an upvalue/local variable, the\n** upvalue/local variable is begin used in a previous assignment to a\n** table. If so, save original upvalue/local value in a safe place and\n** use this safe copy in the previous assignment.\n*/\nconst check_conflict = function(ls, lh, v) {\n    let fs = ls.fs;\n    let extra = fs.freereg;  /* eventual position to save local variable */\n    let conflict = false;\n    for (; lh; lh = lh.prev) {  /* check all previous assignments */\n        if (lh.v.k === expkind.VINDEXED) {  /* assigning to a table? */\n            /* table is the upvalue/local being assigned now? */\n            if (lh.v.u.ind.vt === v.k && lh.v.u.ind.t === v.u.info) {\n                conflict = true;\n                lh.v.u.ind.vt = expkind.VLOCAL;\n                lh.v.u.ind.t = extra;  /* previous assignment will use safe copy */\n            }\n            /* index is the local being assigned? (index cannot be upvalue) */\n            if (v.k === expkind.VLOCAL && lh.v.u.ind.idx === v.u.info) {\n                conflict = true;\n                lh.v.u.ind.idx = extra;  /* previous assignment will use safe copy */\n            }\n        }\n    }\n    if (conflict) {\n        /* copy upvalue/local value to a temporary (in position 'extra') */\n        let op = v.k === expkind.VLOCAL ? OP_MOVE : OP_GETUPVAL;\n        luaK_codeABC(fs, op, extra, v.u.info, 0);\n        luaK_reserveregs(fs, 1);\n    }\n};\n\nconst assignment = function(ls, lh, nvars) {\n    let e = new expdesc();\n    check_condition(ls, vkisvar(lh.v.k), to_luastring(\"syntax error\", true));\n    if (testnext(ls, 44 /* (',').charCodeAt(0) */)) {  /* assignment -> ',' suffixedexp assignment */\n        let nv = new LHS_assign();\n        nv.prev = lh;\n        suffixedexp(ls, nv.v);\n        if (nv.v.k !== expkind.VINDEXED)\n            check_conflict(ls, lh, nv.v);\n        checklimit(ls.fs, nvars + ls.L.nCcalls, LUAI_MAXCCALLS, to_luastring(\"JS levels\", true));\n        assignment(ls, nv, nvars + 1);\n    } else {  /* assignment -> '=' explist */\n        checknext(ls, 61 /* ('=').charCodeAt(0) */);\n        let nexps = explist(ls, e);\n        if (nexps !== nvars)\n            adjust_assign(ls, nvars, nexps, e);\n        else {\n            luaK_setoneret(ls.fs, e);  /* close last expression */\n            luaK_storevar(ls.fs, lh.v, e);\n            return;  /* avoid default */\n        }\n    }\n    init_exp(e, expkind.VNONRELOC, ls.fs.freereg-1);  /* default assignment */\n    luaK_storevar(ls.fs, lh.v, e);\n};\n\nconst cond = function(ls) {\n    /* cond -> exp */\n    let v = new expdesc();\n    expr(ls, v);  /* read condition */\n    if (v.k === expkind.VNIL) v.k = expkind.VFALSE;  /* 'falses' are all equal here */\n    luaK_goiftrue(ls.fs, v);\n    return v.f;\n};\n\nconst gotostat = function(ls, pc) {\n    let line = ls.linenumber;\n    let label;\n    if (testnext(ls, R.TK_GOTO))\n        label = str_checkname(ls);\n    else {\n        llex.luaX_next(ls);  /* skip break */\n        label = luaS_newliteral(ls.L, \"break\");\n    }\n    let g = newlabelentry(ls, ls.dyd.gt, label, line, pc);\n    findlabel(ls, g);  /* close it if label already defined */\n};\n\n/* check for repeated labels on the same block */\nconst checkrepeated = function(fs, ll, label) {\n    for (let i = fs.bl.firstlabel; i < ll.n; i++) {\n        if (eqstr(label, ll.arr[i].name)) {\n            let msg = lobject.luaO_pushfstring(fs.ls.L,\n                to_luastring(\"label '%s' already defined on line %d\", true),\n                label.getstr(), ll.arr[i].line);\n            semerror(fs.ls, msg);\n        }\n    }\n};\n\n/* skip no-op statements */\nconst skipnoopstat = function(ls) {\n    while (ls.t.token === 59 /* (';').charCodeAt(0) */ || ls.t.token === R.TK_DBCOLON)\n        statement(ls);\n};\n\nconst labelstat = function(ls, label, line) {\n    /* label -> '::' NAME '::' */\n    let fs = ls.fs;\n    let ll = ls.dyd.label;\n    let l;  /* index of new label being created */\n    checkrepeated(fs, ll, label);  /* check for repeated labels */\n    checknext(ls, R.TK_DBCOLON);  /* skip double colon */\n    /* create new entry for this label */\n    l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));\n    skipnoopstat(ls);  /* skip other no-op statements */\n    if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */\n        /* assume that locals are already out of scope */\n        ll.arr[l].nactvar = fs.bl.nactvar;\n    }\n    findgotos(ls, ll.arr[l]);\n};\n\nconst whilestat = function(ls, line) {\n    /* whilestat -> WHILE cond DO block END */\n    let fs = ls.fs;\n    let bl = new BlockCnt();\n    llex.luaX_next(ls);  /* skip WHILE */\n    let whileinit = luaK_getlabel(fs);\n    let condexit = cond(ls);\n    enterblock(fs, bl, 1);\n    checknext(ls, R.TK_DO);\n    block(ls);\n    luaK_jumpto(fs, whileinit);\n    check_match(ls, R.TK_END, R.TK_WHILE, line);\n    leaveblock(fs);\n    luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */\n};\n\nconst repeatstat = function(ls, line) {\n    /* repeatstat -> REPEAT block UNTIL cond */\n    let fs = ls.fs;\n    let repeat_init = luaK_getlabel(fs);\n    let bl1 = new BlockCnt();\n    let bl2 = new BlockCnt();\n    enterblock(fs, bl1, 1);  /* loop block */\n    enterblock(fs, bl2, 0);  /* scope block */\n    llex.luaX_next(ls);  /* skip REPEAT */\n    statlist(ls);\n    check_match(ls, R.TK_UNTIL, R.TK_REPEAT, line);\n    let condexit = cond(ls);  /* read condition (inside scope block) */\n    if (bl2.upval)  /* upvalues? */\n        luaK_patchclose(fs, condexit, bl2.nactvar);\n    leaveblock(fs);  /* finish scope */\n    luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */\n    leaveblock(fs);  /* finish loop */\n};\n\nconst exp1 = function(ls) {\n    let e = new expdesc();\n    expr(ls, e);\n    luaK_exp2nextreg(ls.fs, e);\n    lua_assert(e.k === expkind.VNONRELOC);\n    let reg = e.u.info;\n    return reg;\n};\n\nconst forbody = function(ls, base, line, nvars, isnum) {\n    /* forbody -> DO block */\n    let bl = new BlockCnt();\n    let fs = ls.fs;\n    let endfor;\n    adjustlocalvars(ls, 3);  /* control variables */\n    checknext(ls, R.TK_DO);\n    let prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);\n    enterblock(fs, bl, 0);  /* scope for declared variables */\n    adjustlocalvars(ls, nvars);\n    luaK_reserveregs(fs, nvars);\n    block(ls);\n    leaveblock(fs);  /* end of scope for declared variables */\n    luaK_patchtohere(fs, prep);\n    if (isnum)  /* end of scope for declared variables */\n        endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);\n    else {  /* generic for */\n        luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);\n        luaK_fixline(fs, line);\n        endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);\n    }\n    luaK_patchlist(fs, endfor, prep + 1);\n    luaK_fixline(fs, line);\n};\n\nconst fornum = function(ls, varname, line) {\n    /* fornum -> NAME = exp1,exp1[,exp1] forbody */\n    let fs = ls.fs;\n    let base = fs.freereg;\n    new_localvarliteral(ls, \"(for index)\");\n    new_localvarliteral(ls, \"(for limit)\");\n    new_localvarliteral(ls, \"(for step)\");\n    new_localvar(ls, varname);\n    checknext(ls, 61 /* ('=').charCodeAt(0) */);\n    exp1(ls);  /* initial value */\n    checknext(ls, 44 /* (',').charCodeAt(0) */);\n    exp1(ls);  /* limit */\n    if (testnext(ls, 44 /* (',').charCodeAt(0) */))\n        exp1(ls);  /* optional step */\n    else {  /* default step = 1 */\n        luaK_codek(fs, fs.freereg, luaK_intK(fs, 1));\n        luaK_reserveregs(fs, 1);\n    }\n    forbody(ls, base, line, 1, 1);\n};\n\nconst forlist = function(ls, indexname) {\n    /* forlist -> NAME {,NAME} IN explist forbody */\n    let fs = ls.fs;\n    let e = new expdesc();\n    let nvars = 4;  /* gen, state, control, plus at least one declared var */\n    let base = fs.freereg;\n    /* create control variables */\n    new_localvarliteral(ls, \"(for generator)\");\n    new_localvarliteral(ls, \"(for state)\");\n    new_localvarliteral(ls, \"(for control)\");\n    /* create declared variables */\n    new_localvar(ls, indexname);\n    while (testnext(ls, 44 /* (',').charCodeAt(0) */)) {\n        new_localvar(ls, str_checkname(ls));\n        nvars++;\n    }\n    checknext(ls, R.TK_IN);\n    let line = ls.linenumber;\n    adjust_assign(ls, 3, explist(ls, e), e);\n    luaK_checkstack(fs, 3);  /* extra space to call generator */\n    forbody(ls, base, line, nvars - 3, 0);\n};\n\nconst forstat = function(ls, line) {\n    /* forstat -> FOR (fornum | forlist) END */\n    let fs = ls.fs;\n    let bl = new BlockCnt();\n    enterblock(fs, bl, 1);  /* scope for loop and control variables */\n    llex.luaX_next(ls);  /* skip 'for' */\n    let varname = str_checkname(ls);  /* first variable name */\n    switch (ls.t.token) {\n        case 61 /* ('=').charCodeAt(0) */: fornum(ls, varname, line); break;\n        case 44 /* (',').charCodeAt(0) */: case R.TK_IN: forlist(ls, varname); break;\n        default: llex.luaX_syntaxerror(ls, to_luastring(\"'=' or 'in' expected\", true));\n    }\n    check_match(ls, R.TK_END, R.TK_FOR, line);\n    leaveblock(fs);  /* loop scope ('break' jumps to this point) */\n};\n\nconst test_then_block = function(ls, escapelist) {\n    /* test_then_block -> [IF | ELSEIF] cond THEN block */\n    let bl = new BlockCnt();\n    let fs = ls.fs;\n    let v = new expdesc();\n    let jf;  /* instruction to skip 'then' code (if condition is false) */\n\n    llex.luaX_next(ls);  /* skip IF or ELSEIF */\n    expr(ls, v);  /* read condition */\n    checknext(ls, R.TK_THEN);\n\n    if (ls.t.token === R.TK_GOTO || ls.t.token === R.TK_BREAK) {\n        luaK_goiffalse(ls.fs, v);  /* will jump to label if condition is true */\n        enterblock(fs, bl, false);  /* must enter block before 'goto' */\n        gotostat(ls, v.t);   /* handle goto/break */\n        while (testnext(ls, 59 /* (';').charCodeAt(0) */));  /* skip colons */\n        if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */\n            leaveblock(fs);\n            return escapelist;  /* and that is it */\n        } else  /* must skip over 'then' part if condition is false */\n            jf = luaK_jump(fs);\n    } else {  /* regular case (not goto/break) */\n        luaK_goiftrue(ls.fs, v);  /* skip over block if condition is false */\n        enterblock(fs, bl, false);\n        jf = v.f;\n    }\n\n    statlist(ls);  /* 'then' part */\n    leaveblock(fs);\n    if (ls.t.token === R.TK_ELSE || ls.t.token === R.TK_ELSEIF)  /* followed by 'else'/'elseif'? */\n        escapelist = luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */\n    luaK_patchtohere(fs, jf);\n\n    return escapelist;\n};\n\nconst ifstat = function(ls, line) {\n    /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */\n    let fs = ls.fs;\n    let escapelist = NO_JUMP;  /* exit list for finished parts */\n    escapelist = test_then_block(ls, escapelist);  /* IF cond THEN block */\n    while (ls.t.token === R.TK_ELSEIF)\n        escapelist = test_then_block(ls, escapelist);  /* ELSEIF cond THEN block */\n    if (testnext(ls, R.TK_ELSE))\n        block(ls);  /* 'else' part */\n    check_match(ls, R.TK_END, R.TK_IF, line);\n    luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */\n};\n\nconst localfunc = function(ls) {\n    let b = new expdesc();\n    let fs = ls.fs;\n    new_localvar(ls, str_checkname(ls));  /* new local variable */\n    adjustlocalvars(ls, 1);  /* enter its scope */\n    body(ls, b, 0, ls.linenumber);  /* function created in next register */\n    /* debug information will only see the variable after this point! */\n    getlocvar(fs, b.u.info).startpc = fs.pc;\n};\n\nconst localstat = function(ls) {\n    /* stat -> LOCAL NAME {',' NAME} ['=' explist] */\n    let nvars = 0;\n    let nexps;\n    let e = new expdesc();\n    do {\n        new_localvar(ls, str_checkname(ls));\n        nvars++;\n    } while (testnext(ls, 44 /* (',').charCodeAt(0) */));\n    if (testnext(ls, 61 /* ('=').charCodeAt(0) */))\n        nexps = explist(ls, e);\n    else {\n        e.k = expkind.VVOID;\n        nexps = 0;\n    }\n    adjust_assign(ls, nvars, nexps, e);\n    adjustlocalvars(ls, nvars);\n};\n\nconst funcname = function(ls, v) {\n    /* funcname -> NAME {fieldsel} [':' NAME] */\n    let ismethod = 0;\n    singlevar(ls, v);\n    while (ls.t.token === 46 /* ('.').charCodeAt(0) */)\n        fieldsel(ls, v);\n    if (ls.t.token === 58 /* (':').charCodeAt(0) */) {\n        ismethod = 1;\n        fieldsel(ls, v);\n    }\n    return ismethod;\n};\n\nconst funcstat = function(ls, line) {\n    /* funcstat -> FUNCTION funcname body */\n    let v = new expdesc();\n    let b = new expdesc();\n    llex.luaX_next(ls);  /* skip FUNCTION */\n    let ismethod = funcname(ls, v);\n    body(ls, b, ismethod, line);\n    luaK_storevar(ls.fs, v, b);\n    luaK_fixline(ls.fs, line);  /* definition \"happens\" in the first line */\n};\n\nconst exprstat= function(ls) {\n    /* stat -> func | assignment */\n    let fs = ls.fs;\n    let v = new LHS_assign();\n    suffixedexp(ls, v.v);\n    if (ls.t.token === 61 /* ('=').charCodeAt(0) */ || ls.t.token === 44 /* (',').charCodeAt(0) */) { /* stat . assignment ? */\n        v.prev = null;\n        assignment(ls, v, 1);\n    }\n    else {  /* stat -> func */\n        check_condition(ls, v.v.k === expkind.VCALL, to_luastring(\"syntax error\", true));\n        SETARG_C(getinstruction(fs, v.v), 1);  /* call statement uses no results */\n    }\n};\n\nconst retstat = function(ls) {\n    /* stat -> RETURN [explist] [';'] */\n    let fs = ls.fs;\n    let e = new expdesc();\n    let first, nret;  /* registers with returned values */\n    if (block_follow(ls, 1) || ls.t.token === 59 /* (';').charCodeAt(0) */)\n        first = nret = 0;  /* return no values */\n    else {\n        nret = explist(ls, e);  /* optional return values */\n        if (hasmultret(e.k)) {\n            luaK_setmultret(fs, e);\n            if (e.k === expkind.VCALL && nret === 1) {  /* tail call? */\n                SET_OPCODE(getinstruction(fs, e), OP_TAILCALL);\n                lua_assert(getinstruction(fs, e).A === fs.nactvar);\n            }\n            first = fs.nactvar;\n            nret = LUA_MULTRET;  /* return all values */\n        } else {\n            if (nret === 1)  /* only one single value? */\n                first = luaK_exp2anyreg(fs, e);\n            else {\n                luaK_exp2nextreg(fs, e);  /* values must go to the stack */\n                first = fs.nactvar;  /* return all active values */\n                lua_assert(nret === fs.freereg - first);\n            }\n        }\n    }\n    luaK_ret(fs, first, nret);\n    testnext(ls, 59 /* (';').charCodeAt(0) */);  /* skip optional semicolon */\n};\n\nconst statement = function(ls) {\n    let line = ls.linenumber;  /* may be needed for error messages */\n    enterlevel(ls);\n    switch(ls.t.token) {\n        case 59 /* (';').charCodeAt(0) */: {  /* stat -> ';' (empty statement) */\n            llex.luaX_next(ls);  /* skip ';' */\n            break;\n        }\n        case R.TK_IF: {  /* stat -> ifstat */\n            ifstat(ls, line);\n            break;\n        }\n        case R.TK_WHILE: {  /* stat -> whilestat */\n            whilestat(ls, line);\n            break;\n        }\n        case R.TK_DO: {  /* stat -> DO block END */\n            llex.luaX_next(ls);  /* skip DO */\n            block(ls);\n            check_match(ls, R.TK_END, R.TK_DO, line);\n            break;\n        }\n        case R.TK_FOR: {  /* stat -> forstat */\n            forstat(ls, line);\n            break;\n        }\n        case R.TK_REPEAT: {  /* stat -> repeatstat */\n            repeatstat(ls, line);\n            break;\n        }\n        case R.TK_FUNCTION: {  /* stat -> funcstat */\n            funcstat(ls, line);\n            break;\n        }\n        case R.TK_LOCAL: {  /* stat -> localstat */\n            llex.luaX_next(ls);  /* skip LOCAL */\n            if (testnext(ls, R.TK_FUNCTION))  /* local function? */\n                localfunc(ls);\n            else\n                localstat(ls);\n            break;\n        }\n        case R.TK_DBCOLON: {  /* stat -> label */\n            llex.luaX_next(ls);  /* skip double colon */\n            labelstat(ls, str_checkname(ls), line);\n            break;\n        }\n        case R.TK_RETURN: {  /* skip double colon */\n            llex.luaX_next(ls);  /* skip RETURN */\n            retstat(ls);\n            break;\n        }\n        case R.TK_BREAK:   /* stat -> breakstat */\n        case R.TK_GOTO: {  /* stat -> 'goto' NAME */\n            gotostat(ls, luaK_jump(ls.fs));\n            break;\n        }\n        default: {  /* stat -> func | assignment */\n            exprstat(ls);\n            break;\n        }\n    }\n    lua_assert(ls.fs.f.maxstacksize >= ls.fs.freereg && ls.fs.freereg >= ls.fs.nactvar);\n    ls.fs.freereg = ls.fs.nactvar;  /* free registers */\n    leavelevel(ls);\n};\n\n/*\n** compiles the main function, which is a regular vararg function with an\n** upvalue named LUA_ENV\n*/\nconst mainfunc = function(ls, fs) {\n    let bl = new BlockCnt();\n    let v = new expdesc();\n    open_func(ls, fs, bl);\n    fs.f.is_vararg = true;  /* main function is always declared vararg */\n    init_exp(v, expkind.VLOCAL, 0);  /* create and... */\n    newupvalue(fs, ls.envn, v);  /* ...set environment upvalue */\n    llex.luaX_next(ls);  /* read first token */\n    statlist(ls);  /* parse main body */\n    check(ls, R.TK_EOS);\n    close_func(ls);\n};\n\nconst luaY_parser = function(L, z, buff, dyd, name, firstchar) {\n    let lexstate = new llex.LexState();\n    let funcstate = new FuncState();\n    let cl = lfunc.luaF_newLclosure(L, 1);  /* create main closure */\n    ldo.luaD_inctop(L);\n    L.stack[L.top-1].setclLvalue(cl);\n    lexstate.h = ltable.luaH_new(L);  /* create table for scanner */\n    ldo.luaD_inctop(L);\n    L.stack[L.top-1].sethvalue(lexstate.h);\n    funcstate.f = cl.p = new Proto(L);\n    funcstate.f.source = luaS_new(L, name);\n    lexstate.buff = buff;\n    lexstate.dyd = dyd;\n    dyd.actvar.n = dyd.gt.n = dyd.label.n = 0;\n    llex.luaX_setinput(L, lexstate, z, funcstate.f.source, firstchar);\n    mainfunc(lexstate, funcstate);\n    lua_assert(!funcstate.prev && funcstate.nups === 1 && !lexstate.fs);\n    /* all scopes should be correctly finished */\n    lua_assert(dyd.actvar.n === 0 && dyd.gt.n === 0 && dyd.label.n === 0);\n    delete L.stack[--L.top];  /* remove scanner's table */\n    return cl;  /* closure is on the stack, too */\n};\n\n\nmodule.exports.Dyndata     = Dyndata;\nmodule.exports.expkind     = expkind;\nmodule.exports.expdesc     = expdesc;\nmodule.exports.luaY_parser = luaY_parser;\nmodule.exports.vkisinreg   = vkisinreg;\n","\"use strict\";\n\nconst {\n    LUA_MULTRET,\n    LUA_OK,\n    LUA_TFUNCTION,\n    LUA_TNIL,\n    LUA_TNONE,\n    LUA_TNUMBER,\n    LUA_TSTRING,\n    LUA_TTABLE,\n    LUA_VERSION,\n    LUA_YIELD,\n    lua_call,\n    lua_callk,\n    lua_concat,\n    lua_error,\n    lua_getglobal,\n    lua_geti,\n    lua_getmetatable,\n    lua_gettop,\n    lua_insert,\n    lua_isnil,\n    lua_isnone,\n    lua_isstring,\n    lua_load,\n    lua_next,\n    lua_pcallk,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushcfunction,\n    lua_pushglobaltable,\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_rawequal,\n    lua_rawget,\n    lua_rawlen,\n    lua_rawset,\n    lua_remove,\n    lua_replace,\n    lua_rotate,\n    lua_setfield,\n    lua_setmetatable,\n    lua_settop,\n    lua_setupvalue,\n    lua_stringtonumber,\n    lua_toboolean,\n    lua_tolstring,\n    lua_tostring,\n    lua_type,\n    lua_typename\n} = require('./lua.js');\nconst {\n    luaL_argcheck,\n    luaL_checkany,\n    luaL_checkinteger,\n    luaL_checkoption,\n    luaL_checkstack,\n    luaL_checktype,\n    luaL_error,\n    luaL_getmetafield,\n    luaL_loadbufferx,\n    luaL_loadfile,\n    luaL_loadfilex,\n    luaL_optinteger,\n    luaL_optstring,\n    luaL_setfuncs,\n    luaL_tolstring,\n    luaL_where\n} = require('./lauxlib.js');\nconst {\n    to_jsstring,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\nlet lua_writestring;\nlet lua_writeline;\nif (typeof process === \"undefined\") {\n    if (typeof TextDecoder === \"function\") { /* Older browsers don't have TextDecoder */\n        let buff = \"\";\n        let decoder = new TextDecoder(\"utf-8\");\n        lua_writestring = function(s) {\n            buff += decoder.decode(s, {stream: true});\n        };\n        let empty = new Uint8Array(0);\n        lua_writeline = function() {\n            buff += decoder.decode(empty);\n            console.log(buff);\n            buff = \"\";\n        };\n    } else {\n        let buff = [];\n        lua_writestring = function(s) {\n            try {\n                /* If the string is valid utf8, then we can use to_jsstring */\n                s = to_jsstring(s);\n            } catch(e) {\n                /* otherwise push copy of raw array */\n                let copy = new Uint8Array(s.length);\n                copy.set(s);\n                s = copy;\n            }\n            buff.push(s);\n        };\n        lua_writeline = function() {\n            console.log.apply(console.log, buff);\n            buff = [];\n        };\n    }\n} else {\n    lua_writestring = function(s) {\n        process.stdout.write(Buffer.from(s));\n    };\n    lua_writeline = function() {\n        process.stdout.write(\"\\n\");\n    };\n}\nconst luaB_print = function(L) {\n    let n = lua_gettop(L); /* number of arguments */\n    lua_getglobal(L, to_luastring(\"tostring\", true));\n    for (let i = 1; i <= n; i++) {\n        lua_pushvalue(L, -1);  /* function to be called */\n        lua_pushvalue(L, i);  /* value to print */\n        lua_call(L, 1, 1);\n        let s = lua_tolstring(L, -1);\n        if (s === null)\n            return luaL_error(L, to_luastring(\"'tostring' must return a string to 'print'\"));\n        if (i > 1) lua_writestring(to_luastring(\"\\t\"));\n        lua_writestring(s);\n        lua_pop(L, 1);\n    }\n    lua_writeline();\n    return 0;\n};\n\nconst luaB_tostring = function(L) {\n    luaL_checkany(L, 1);\n    luaL_tolstring(L, 1);\n\n    return 1;\n};\n\nconst luaB_getmetatable = function(L) {\n    luaL_checkany(L, 1);\n    if (!lua_getmetatable(L, 1)) {\n        lua_pushnil(L);\n        return 1;  /* no metatable */\n    }\n    luaL_getmetafield(L, 1, to_luastring(\"__metatable\", true));\n    return 1;  /* returns either __metatable field (if present) or metatable */\n};\n\nconst luaB_setmetatable = function(L) {\n    let t = lua_type(L, 2);\n    luaL_checktype(L, 1, LUA_TTABLE);\n    luaL_argcheck(L, t === LUA_TNIL || t === LUA_TTABLE, 2, \"nil or table expected\");\n    if (luaL_getmetafield(L, 1, to_luastring(\"__metatable\", true)) !== LUA_TNIL)\n        return luaL_error(L, to_luastring(\"cannot change a protected metatable\"));\n    lua_settop(L, 2);\n    lua_setmetatable(L, 1);\n    return 1;\n};\n\nconst luaB_rawequal = function(L) {\n    luaL_checkany(L, 1);\n    luaL_checkany(L, 2);\n    lua_pushboolean(L, lua_rawequal(L, 1, 2));\n    return 1;\n};\n\nconst luaB_rawlen = function(L) {\n    let t = lua_type(L, 1);\n    luaL_argcheck(L, t === LUA_TTABLE || t === LUA_TSTRING, 1, \"table or string expected\");\n    lua_pushinteger(L, lua_rawlen(L, 1));\n    return 1;\n};\n\nconst luaB_rawget = function(L) {\n    luaL_checktype(L, 1, LUA_TTABLE);\n    luaL_checkany(L, 2);\n    lua_settop(L, 2);\n    lua_rawget(L, 1);\n    return 1;\n};\n\nconst luaB_rawset = function(L) {\n    luaL_checktype(L, 1, LUA_TTABLE);\n    luaL_checkany(L, 2);\n    luaL_checkany(L, 3);\n    lua_settop(L, 3);\n    lua_rawset(L, 1);\n    return 1;\n};\n\nconst opts = [\n    \"stop\", \"restart\", \"collect\",\n    \"count\", \"step\", \"setpause\", \"setstepmul\",\n    \"isrunning\"\n].map((e) => to_luastring(e));\nconst luaB_collectgarbage = function(L) {\n    luaL_checkoption(L, 1, \"collect\", opts);\n    luaL_optinteger(L, 2, 0);\n    luaL_error(L, to_luastring(\"lua_gc not implemented\"));\n};\n\nconst luaB_type = function(L) {\n    let t = lua_type(L, 1);\n    luaL_argcheck(L, t !== LUA_TNONE, 1, \"value expected\");\n    lua_pushstring(L, lua_typename(L, t));\n    return 1;\n};\n\nconst pairsmeta = function(L, method, iszero, iter) {\n    luaL_checkany(L, 1);\n    if (luaL_getmetafield(L, 1, method) === LUA_TNIL) {  /* no metamethod? */\n        lua_pushcfunction(L, iter);  /* will return generator, */\n        lua_pushvalue(L, 1);  /* state, */\n        if (iszero) lua_pushinteger(L, 0);  /* and initial value */\n        else lua_pushnil(L);\n    } else {\n        lua_pushvalue(L, 1);  /* argument 'self' to metamethod */\n        lua_call(L, 1, 3);  /* get 3 values from metamethod */\n    }\n    return 3;\n};\n\nconst luaB_next = function(L) {\n    luaL_checktype(L, 1, LUA_TTABLE);\n    lua_settop(L, 2);  /* create a 2nd argument if there isn't one */\n    if (lua_next(L, 1))\n        return 2;\n    else {\n        lua_pushnil(L);\n        return 1;\n    }\n};\n\nconst luaB_pairs = function(L) {\n    return pairsmeta(L, to_luastring(\"__pairs\", true), 0, luaB_next);\n};\n\n/*\n** Traversal function for 'ipairs'\n*/\nconst ipairsaux = function(L) {\n    let i = luaL_checkinteger(L, 2) + 1;\n    lua_pushinteger(L, i);\n    return lua_geti(L, 1, i) === LUA_TNIL ? 1 : 2;\n};\n\n/*\n** 'ipairs' function. Returns 'ipairsaux', given \"table\", 0.\n** (The given \"table\" may not be a table.)\n*/\nconst luaB_ipairs = function(L) {\n    // Lua 5.2\n    // return pairsmeta(L, \"__ipairs\", 1, ipairsaux);\n\n    luaL_checkany(L, 1);\n    lua_pushcfunction(L, ipairsaux);  /* iteration function */\n    lua_pushvalue(L, 1);  /* state */\n    lua_pushinteger(L, 0);  /* initial value */\n    return 3;\n};\n\nconst b_str2int = function(s, base) {\n    try {\n        s = to_jsstring(s);\n    } catch (e) {\n        return null;\n    }\n    let r = /^[\\t\\v\\f \\n\\r]*([+-]?)0*([0-9A-Za-z]+)[\\t\\v\\f \\n\\r]*$/.exec(s);\n    if (!r) return null;\n    let v = parseInt(r[1]+r[2], base);\n    if (isNaN(v)) return null;\n    return v|0;\n};\n\nconst luaB_tonumber = function(L) {\n    if (lua_type(L, 2) <= 0) {  /* standard conversion? */\n        luaL_checkany(L, 1);\n        if (lua_type(L, 1) === LUA_TNUMBER) {  /* already a number? */\n            lua_settop(L, 1);\n            return 1;\n        } else {\n            let s = lua_tostring(L, 1);\n            if (s !== null && lua_stringtonumber(L, s) === s.length+1)\n                return 1;  /* successful conversion to number */\n        }\n    } else {\n        let base = luaL_checkinteger(L, 2);\n        luaL_checktype(L, 1, LUA_TSTRING);  /* no numbers as strings */\n        let s = lua_tostring(L, 1);\n        luaL_argcheck(L, 2 <= base && base <= 36, 2, \"base out of range\");\n        let n = b_str2int(s, base);\n        if (n !== null) {\n            lua_pushinteger(L, n);\n            return 1;\n        }\n    }\n\n    lua_pushnil(L);\n    return 1;\n};\n\nconst luaB_error = function(L) {\n    let level = luaL_optinteger(L, 2, 1);\n    lua_settop(L, 1);\n    if (lua_type(L, 1) === LUA_TSTRING && level > 0) {\n        luaL_where(L, level);  /* add extra information */\n        lua_pushvalue(L, 1);\n        lua_concat(L, 2);\n    }\n    return lua_error(L);\n};\n\nconst luaB_assert = function(L) {\n    if (lua_toboolean(L, 1))  /* condition is true? */\n        return lua_gettop(L);  /* return all arguments */\n    else {\n        luaL_checkany(L, 1);  /* there must be a condition */\n        lua_remove(L, 1);  /* remove it */\n        lua_pushliteral(L, \"assertion failed!\");  /* default message */\n        lua_settop(L, 1);  /* leave only message (default if no other one) */\n        return luaB_error(L);  /* call 'error' */\n    }\n};\n\nconst luaB_select = function(L) {\n    let n = lua_gettop(L);\n    if (lua_type(L, 1) === LUA_TSTRING && lua_tostring(L, 1)[0] === 35 /* '#'.charCodeAt(0) */) {\n        lua_pushinteger(L, n - 1);\n        return 1;\n    } else {\n        let i = luaL_checkinteger(L, 1);\n        if (i < 0) i = n + i;\n        else if (i > n) i = n;\n        luaL_argcheck(L, 1 <= i, 1, \"index out of range\");\n        return n - i;\n    }\n};\n\n/*\n** Continuation function for 'pcall' and 'xpcall'. Both functions\n** already pushed a 'true' before doing the call, so in case of success\n** 'finishpcall' only has to return everything in the stack minus\n** 'extra' values (where 'extra' is exactly the number of items to be\n** ignored).\n*/\nconst finishpcall = function(L, status, extra) {\n    if (status !== LUA_OK && status !== LUA_YIELD) {  /* error? */\n        lua_pushboolean(L, 0);  /* first result (false) */\n        lua_pushvalue(L, -2);  /* error message */\n        return 2;  /* return false, msg */\n    } else\n        return lua_gettop(L) - extra;\n};\n\nconst luaB_pcall = function(L) {\n    luaL_checkany(L, 1);\n    lua_pushboolean(L, 1);  /* first result if no errors */\n    lua_insert(L, 1);  /* put it in place */\n    let status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);\n    return finishpcall(L, status, 0);\n};\n\n/*\n** Do a protected call with error handling. After 'lua_rotate', the\n** stack will have <f, err, true, f, [args...]>; so, the function passes\n** 2 to 'finishpcall' to skip the 2 first values when returning results.\n*/\nconst luaB_xpcall = function(L) {\n    let n = lua_gettop(L);\n    luaL_checktype(L, 2, LUA_TFUNCTION);  /* check error function */\n    lua_pushboolean(L, 1);  /* first result */\n    lua_pushvalue(L, 1);  /* function */\n    lua_rotate(L, 3, 2);  /* move them below function's arguments */\n    let status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);\n    return finishpcall(L, status, 2);\n};\n\nconst load_aux = function(L, status, envidx) {\n    if (status === LUA_OK) {\n        if (envidx !== 0) {  /* 'env' parameter? */\n            lua_pushvalue(L, envidx);  /* environment for loaded function */\n            if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */\n                lua_pop(L, 1);  /* remove 'env' if not used by previous call */\n        }\n        return 1;\n    } else {  /* error (message is on top of the stack) */\n        lua_pushnil(L);\n        lua_insert(L, -2);  /* put before error message */\n        return 2;  /* return nil plus error message */\n    }\n};\n\n/*\n** reserved slot, above all arguments, to hold a copy of the returned\n** string to avoid it being collected while parsed. 'load' has four\n** optional arguments (chunk, source name, mode, and environment).\n*/\nconst RESERVEDSLOT = 5;\n\n/*\n** Reader for generic 'load' function: 'lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\nconst generic_reader = function(L, ud) {\n    luaL_checkstack(L, 2, \"too many nested functions\");\n    lua_pushvalue(L, 1);  /* get function */\n    lua_call(L, 0, 1);  /* call it */\n    if (lua_isnil(L, -1)) {\n        lua_pop(L, 1);  /* pop result */\n        return null;\n    } else if (!lua_isstring(L, -1))\n        luaL_error(L, to_luastring(\"reader function must return a string\"));\n    lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */\n    return lua_tostring(L, RESERVEDSLOT);\n};\n\nconst luaB_load = function(L) {\n    let s = lua_tostring(L, 1);\n    let mode = luaL_optstring(L, 3, \"bt\");\n    let env = !lua_isnone(L, 4) ? 4 : 0;  /* 'env' index or 0 if no 'env' */\n    let status;\n    if (s !== null) {  /* loading a string? */\n        let chunkname = luaL_optstring(L, 2, s);\n        status = luaL_loadbufferx(L, s, s.length, chunkname, mode);\n    } else {  /* loading from a reader function */\n        let chunkname = luaL_optstring(L, 2, \"=(load)\");\n        luaL_checktype(L, 1, LUA_TFUNCTION);\n        lua_settop(L, RESERVEDSLOT);  /* create reserved slot */\n        status = lua_load(L, generic_reader, null, chunkname, mode);\n    }\n    return load_aux(L, status, env);\n};\n\nconst luaB_loadfile = function(L) {\n    let fname = luaL_optstring(L, 1, null);\n    let mode = luaL_optstring(L, 2, null);\n    let env = !lua_isnone(L, 3) ? 3 : 0;  /* 'env' index or 0 if no 'env' */\n    let status = luaL_loadfilex(L, fname, mode);\n    return load_aux(L, status, env);\n};\n\nconst dofilecont = function(L, d1, d2) {\n    return lua_gettop(L) - 1;\n};\n\nconst luaB_dofile = function(L) {\n    let fname = luaL_optstring(L, 1, null);\n    lua_settop(L, 1);\n    if (luaL_loadfile(L, fname) !== LUA_OK)\n        return lua_error(L);\n    lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);\n    return dofilecont(L, 0, 0);\n};\n\nconst base_funcs = {\n    \"assert\":         luaB_assert,\n    \"collectgarbage\": luaB_collectgarbage,\n    \"dofile\":         luaB_dofile,\n    \"error\":          luaB_error,\n    \"getmetatable\":   luaB_getmetatable,\n    \"ipairs\":         luaB_ipairs,\n    \"load\":           luaB_load,\n    \"loadfile\":       luaB_loadfile,\n    \"next\":           luaB_next,\n    \"pairs\":          luaB_pairs,\n    \"pcall\":          luaB_pcall,\n    \"print\":          luaB_print,\n    \"rawequal\":       luaB_rawequal,\n    \"rawget\":         luaB_rawget,\n    \"rawlen\":         luaB_rawlen,\n    \"rawset\":         luaB_rawset,\n    \"select\":         luaB_select,\n    \"setmetatable\":   luaB_setmetatable,\n    \"tonumber\":       luaB_tonumber,\n    \"tostring\":       luaB_tostring,\n    \"type\":           luaB_type,\n    \"xpcall\":         luaB_xpcall\n};\n\nconst luaopen_base = function(L) {\n    /* open lib into global table */\n    lua_pushglobaltable(L);\n    luaL_setfuncs(L, base_funcs, 0);\n    /* set global _G */\n    lua_pushvalue(L, -1);\n    lua_setfield(L, -2, to_luastring(\"_G\"));\n    /* set global _VERSION */\n    lua_pushliteral(L, LUA_VERSION);\n    lua_setfield(L, -2, to_luastring(\"_VERSION\"));\n    return 1;\n};\n\nmodule.exports.luaopen_base = luaopen_base;\n","\"use strict\";\n\nconst {\n    LUA_OK,\n    LUA_TFUNCTION,\n    LUA_TSTRING,\n    LUA_YIELD,\n    lua_Debug,\n    lua_checkstack,\n    lua_concat,\n    lua_error,\n    lua_getstack,\n    lua_gettop,\n    lua_insert,\n    lua_isyieldable,\n    lua_newthread,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushcclosure,\n    lua_pushliteral,\n    lua_pushthread,\n    lua_pushvalue,\n    lua_resume,\n    lua_status,\n    lua_tothread,\n    lua_type,\n    lua_upvalueindex,\n    lua_xmove,\n    lua_yield\n} = require('./lua.js');\nconst {\n    luaL_argcheck,\n    luaL_checktype,\n    luaL_newlib,\n    luaL_where\n} = require('./lauxlib.js');\n\nconst getco = function(L) {\n    let co = lua_tothread(L, 1);\n    luaL_argcheck(L, co, 1, \"thread expected\");\n    return co;\n};\n\nconst auxresume = function(L, co, narg) {\n    if (!lua_checkstack(co, narg)) {\n        lua_pushliteral(L, \"too many arguments to resume\");\n        return -1;  /* error flag */\n    }\n\n    if (lua_status(co) === LUA_OK && lua_gettop(co) === 0) {\n        lua_pushliteral(L, \"cannot resume dead coroutine\");\n        return -1;  /* error flag */\n    }\n\n    lua_xmove(L, co, narg);\n    let status = lua_resume(co, L, narg);\n    if (status === LUA_OK || status === LUA_YIELD) {\n        let nres = lua_gettop(co);\n        if (!lua_checkstack(L, nres + 1)) {\n            lua_pop(co, nres);  /* remove results anyway */\n            lua_pushliteral(L, \"too many results to resume\");\n            return -1;  /* error flag */\n        }\n\n        lua_xmove(co,  L, nres);  /* move yielded values */\n        return nres;\n    } else {\n        lua_xmove(co, L, 1);  /* move error message */\n        return -1;  /* error flag */\n    }\n};\n\nconst luaB_coresume = function(L) {\n    let co = getco(L);\n    let r = auxresume(L, co, lua_gettop(L) - 1);\n    if (r < 0) {\n        lua_pushboolean(L, 0);\n        lua_insert(L, -2);\n        return 2;  /* return false + error message */\n    } else {\n        lua_pushboolean(L, 1);\n        lua_insert(L, -(r + 1));\n        return r + 1;  /* return true + 'resume' returns */\n    }\n};\n\nconst luaB_auxwrap = function(L) {\n    let co = lua_tothread(L, lua_upvalueindex(1));\n    let r = auxresume(L, co, lua_gettop(L));\n    if (r < 0) {\n        if (lua_type(L, -1) === LUA_TSTRING) {  /* error object is a string? */\n            luaL_where(L, 1);  /* add extra info */\n            lua_insert(L, -2);\n            lua_concat(L, 2);\n        }\n\n        return lua_error(L);  /* propagate error */\n    }\n\n    return r;\n};\n\nconst luaB_cocreate = function(L) {\n    luaL_checktype(L, 1, LUA_TFUNCTION);\n    let NL = lua_newthread(L);\n    lua_pushvalue(L, 1);  /* move function to top */\n    lua_xmove(L, NL, 1);  /* move function from L to NL */\n    return 1;\n};\n\nconst luaB_cowrap = function(L) {\n    luaB_cocreate(L);\n    lua_pushcclosure(L, luaB_auxwrap, 1);\n    return 1;\n};\n\nconst luaB_yield = function(L) {\n    return lua_yield(L, lua_gettop(L));\n};\n\nconst luaB_costatus = function(L) {\n    let co = getco(L);\n    if (L === co) lua_pushliteral(L, \"running\");\n    else {\n        switch (lua_status(co)) {\n            case LUA_YIELD:\n                lua_pushliteral(L, \"suspended\");\n                break;\n            case LUA_OK: {\n                let ar = new lua_Debug();\n                if (lua_getstack(co, 0, ar) > 0)  /* does it have frames? */\n                    lua_pushliteral(L, \"normal\");  /* it is running */\n                else if (lua_gettop(co) === 0)\n                    lua_pushliteral(L, \"dead\");\n                else\n                    lua_pushliteral(L, \"suspended\");  /* initial state */\n                break;\n            }\n            default:  /* some error occurred */\n                lua_pushliteral(L, \"dead\");\n                break;\n        }\n    }\n\n    return 1;\n};\n\nconst luaB_yieldable = function(L) {\n    lua_pushboolean(L, lua_isyieldable(L));\n    return 1;\n};\n\nconst luaB_corunning = function(L) {\n    lua_pushboolean(L, lua_pushthread(L));\n    return 2;\n};\n\nconst co_funcs = {\n    \"create\":      luaB_cocreate,\n    \"isyieldable\": luaB_yieldable,\n    \"resume\":      luaB_coresume,\n    \"running\":     luaB_corunning,\n    \"status\":      luaB_costatus,\n    \"wrap\":        luaB_cowrap,\n    \"yield\":       luaB_yield\n};\n\nconst luaopen_coroutine = function(L) {\n    luaL_newlib(L, co_funcs);\n    return 1;\n};\n\nmodule.exports.luaopen_coroutine = luaopen_coroutine;\n","\"use strict\";\n\nconst { LUA_MAXINTEGER } = require('./luaconf.js');\nconst {\n    LUA_OPEQ,\n    LUA_OPLT,\n    LUA_TFUNCTION,\n    LUA_TNIL,\n    LUA_TTABLE,\n    lua_call,\n    lua_checkstack,\n    lua_compare,\n    lua_createtable,\n    lua_geti,\n    lua_getmetatable,\n    lua_gettop,\n    lua_insert,\n    lua_isnil,\n    lua_isnoneornil,\n    lua_isstring,\n    lua_pop,\n    lua_pushinteger,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_rawget,\n    lua_setfield,\n    lua_seti,\n    lua_settop,\n    lua_toboolean,\n    lua_type\n} = require('./lua.js');\nconst {\n    luaL_Buffer,\n    luaL_addlstring,\n    luaL_addvalue,\n    luaL_argcheck,\n    luaL_buffinit,\n    luaL_checkinteger,\n    luaL_checktype,\n    luaL_error,\n    luaL_len,\n    luaL_newlib,\n    luaL_opt,\n    luaL_optinteger,\n    luaL_optlstring,\n    luaL_pushresult,\n    luaL_typename\n} = require('./lauxlib.js');\nconst lualib = require('./lualib.js');\nconst { to_luastring } = require(\"./fengaricore.js\");\n\n/*\n** Operations that an object must define to mimic a table\n** (some functions only need some of them)\n*/\nconst TAB_R  = 1;               /* read */\nconst TAB_W  = 2;               /* write */\nconst TAB_L  = 4;               /* length */\nconst TAB_RW = (TAB_R | TAB_W); /* read/write */\n\nconst checkfield = function(L, key, n) {\n    lua_pushstring(L, key);\n    return lua_rawget(L, -n) !== LUA_TNIL;\n};\n\n/*\n** Check that 'arg' either is a table or can behave like one (that is,\n** has a metatable with the required metamethods)\n*/\nconst checktab = function(L, arg, what) {\n    if (lua_type(L, arg) !== LUA_TTABLE) {  /* is it not a table? */\n        let n = 1;\n        if (lua_getmetatable(L, arg) &&  /* must have metatable */\n            (!(what & TAB_R) || checkfield(L, to_luastring(\"__index\", true), ++n)) &&\n            (!(what & TAB_W) || checkfield(L, to_luastring(\"__newindex\", true), ++n)) &&\n            (!(what & TAB_L) || checkfield(L, to_luastring(\"__len\", true), ++n))) {\n            lua_pop(L, n);  /* pop metatable and tested metamethods */\n        }\n        else\n            luaL_checktype(L, arg, LUA_TTABLE);  /* force an error */\n    }\n};\n\nconst aux_getn = function(L, n, w) {\n    checktab(L, n, w | TAB_L);\n    return luaL_len(L, n);\n};\n\nconst addfield = function(L, b, i) {\n    lua_geti(L, 1, i);\n    if (!lua_isstring(L, -1))\n        luaL_error(L, to_luastring(\"invalid value (%s) at index %d in table for 'concat'\"),\n            luaL_typename(L, -1), i);\n\n    luaL_addvalue(b);\n};\n\nconst tinsert = function(L) {\n    let e = aux_getn(L, 1, TAB_RW) + 1;  /* first empty element */\n    let pos;\n    switch (lua_gettop(L)) {\n        case 2:\n            pos = e;\n            break;\n        case 3: {\n            pos = luaL_checkinteger(L, 2);  /* 2nd argument is the position */\n            luaL_argcheck(L, 1 <= pos && pos <= e, 2, \"position out of bounds\");\n            for (let i = e; i > pos; i--) {  /* move up elements */\n                lua_geti(L, 1, i - 1);\n                lua_seti(L, 1, i);  /* t[i] = t[i - 1] */\n            }\n            break;\n        }\n        default: {\n            return luaL_error(L, \"wrong number of arguments to 'insert'\");\n        }\n    }\n\n    lua_seti(L, 1, pos);  /* t[pos] = v */\n    return 0;\n};\n\nconst tremove = function(L) {\n    let size = aux_getn(L, 1, TAB_RW);\n    let pos = luaL_optinteger(L, 2, size);\n    if (pos !== size)  /* validate 'pos' if given */\n        luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, \"position out of bounds\");\n    lua_geti(L, 1, pos);  /* result = t[pos] */\n    for (; pos < size; pos++) {\n        lua_geti(L, 1, pos + 1);\n        lua_seti(L, 1, pos);  /* t[pos] = t[pos + 1] */\n    }\n    lua_pushnil(L);\n    lua_seti(L, 1, pos);  /* t[pos] = nil */\n    return 1;\n};\n\n/*\n** Copy elements (1[f], ..., 1[e]) into (tt[t], tt[t+1], ...). Whenever\n** possible, copy in increasing order, which is better for rehashing.\n** \"possible\" means destination after original range, or smaller\n** than origin, or copying to another table.\n*/\nconst tmove = function(L) {\n    let f = luaL_checkinteger(L, 2);\n    let e = luaL_checkinteger(L, 3);\n    let t = luaL_checkinteger(L, 4);\n    let tt = !lua_isnoneornil(L, 5) ? 5 : 1;  /* destination table */\n    checktab(L, 1, TAB_R);\n    checktab(L, tt, TAB_W);\n    if (e >= f) {  /* otherwise, nothing to move */\n        luaL_argcheck(L, f > 0 || e < LUA_MAXINTEGER + f, 3, \"too many elements to move\");\n        let n = e - f + 1;  /* number of elements to move */\n        luaL_argcheck(L, t <= LUA_MAXINTEGER - n + 1, 4, \"destination wrap around\");\n\n        if (t > e || t <= f || (tt !== 1 && lua_compare(L, 1, tt, LUA_OPEQ) !== 1)) {\n            for (let i = 0; i < n; i++) {\n                lua_geti(L, 1, f + i);\n                lua_seti(L, tt, t + i);\n            }\n        } else {\n            for (let i = n - 1; i >= 0; i--) {\n                lua_geti(L, 1, f + i);\n                lua_seti(L, tt, t + i);\n            }\n        }\n    }\n\n    lua_pushvalue(L, tt);  /* return destination table */\n    return 1;\n};\n\nconst tconcat = function(L) {\n    let last = aux_getn(L, 1, TAB_R);\n    let sep = luaL_optlstring(L, 2, \"\");\n    let lsep = sep.length;\n    let i = luaL_optinteger(L, 3, 1);\n    last = luaL_optinteger(L, 4, last);\n\n    let b = new luaL_Buffer();\n    luaL_buffinit(L, b);\n\n    for (; i < last; i++) {\n        addfield(L, b, i);\n        luaL_addlstring(b, sep, lsep);\n    }\n\n    if (i === last)\n        addfield(L, b, i);\n\n    luaL_pushresult(b);\n\n    return 1;\n};\n\nconst pack = function(L) {\n    let n = lua_gettop(L);  /* number of elements to pack */\n    lua_createtable(L, n, 1);  /* create result table */\n    lua_insert(L, 1);  /* put it at index 1 */\n    for (let i = n; i >= 1; i--)  /* assign elements */\n        lua_seti(L, 1, i);\n    lua_pushinteger(L, n);\n    lua_setfield(L, 1, to_luastring(\"n\"));  /* t.n = number of elements */\n    return 1;  /* return table */\n};\n\nconst unpack = function(L) {\n    let i = luaL_optinteger(L, 2, 1);\n    let e = luaL_opt(L, luaL_checkinteger, 3, luaL_len(L, 1));\n    if (i > e) return 0;  /* empty range */\n    let n = e - i;  /* number of elements minus 1 (avoid overflows) */\n    if (n >= Number.MAX_SAFE_INTEGER || !lua_checkstack(L, ++n))\n        return luaL_error(L, to_luastring(\"too many results to unpack\"));\n    for (; i < e; i++)  /* push arg[i..e - 1] (to avoid overflows) */\n        lua_geti(L, 1, i);\n    lua_geti(L, 1, e);  /* push last element */\n    return n;\n};\n\nconst l_randomizePivot = function() {\n    return Math.floor(Math.random()*0x100000000);\n};\n\nconst RANLIMIT = 100;\n\nconst set2 = function(L, i, j) {\n    lua_seti(L, 1, i);\n    lua_seti(L, 1, j);\n};\n\nconst sort_comp = function(L, a, b) {\n    if (lua_isnil(L, 2))  /* no function? */\n        return lua_compare(L, a, b, LUA_OPLT);  /* a < b */\n    else {  /* function */\n        lua_pushvalue(L, 2);    /* push function */\n        lua_pushvalue(L, a-1);  /* -1 to compensate function */\n        lua_pushvalue(L, b-2);  /* -2 to compensate function and 'a' */\n        lua_call(L, 2, 1);      /* call function */\n        let res = lua_toboolean(L, -1);  /* get result */\n        lua_pop(L, 1);          /* pop result */\n        return res;\n    }\n};\n\nconst partition = function(L, lo, up) {\n    let i = lo;  /* will be incremented before first use */\n    let j = up - 1;  /* will be decremented before first use */\n    /* loop invariant: a[lo .. i] <= P <= a[j .. up] */\n    for (;;) {\n        /* next loop: repeat ++i while a[i] < P */\n        while (lua_geti(L, 1, ++i), sort_comp(L, -1, -2)) {\n            if (i == up - 1)  /* a[i] < P  but a[up - 1] == P  ?? */\n                luaL_error(L, to_luastring(\"invalid order function for sorting\"));\n            lua_pop(L, 1);  /* remove a[i] */\n        }\n        /* after the loop, a[i] >= P and a[lo .. i - 1] < P */\n        /* next loop: repeat --j while P < a[j] */\n        while (lua_geti(L, 1, --j), sort_comp(L, -3, -1)) {\n            if (j < i)  /* j < i  but  a[j] > P ?? */\n                luaL_error(L, to_luastring(\"invalid order function for sorting\"));\n            lua_pop(L, 1);  /* remove a[j] */\n        }\n        /* after the loop, a[j] <= P and a[j + 1 .. up] >= P */\n        if (j < i) {  /* no elements out of place? */\n            /* a[lo .. i - 1] <= P <= a[j + 1 .. i .. up] */\n            lua_pop(L, 1);  /* pop a[j] */\n            /* swap pivot (a[up - 1]) with a[i] to satisfy pos-condition */\n            set2(L, up - 1, i);\n            return i;\n        }\n        /* otherwise, swap a[i] - a[j] to restore invariant and repeat */\n        set2(L, i, j);\n    }\n};\n\nconst choosePivot = function(lo, up, rnd) {\n    let r4 = Math.floor((up - lo) / 4);  /* range/4 */\n    let p = rnd % (r4 * 2) + (lo + r4);\n    lualib.lua_assert(lo + r4 <= p && p <= up - r4);\n    return p;\n};\n\nconst auxsort = function(L, lo, up, rnd) {\n    while (lo < up) {  /* loop for tail recursion */\n        /* sort elements 'lo', 'p', and 'up' */\n        lua_geti(L, 1, lo);\n        lua_geti(L, 1, up);\n        if (sort_comp(L, -1, -2))  /* a[up] < a[lo]? */\n            set2(L, lo, up);  /* swap a[lo] - a[up] */\n        else\n            lua_pop(L, 2);  /* remove both values */\n        if (up - lo == 1)  /* only 2 elements? */\n            return;  /* already sorted */\n        let p;  /* Pivot index */\n        if (up - lo < RANLIMIT || rnd === 0)  /* small interval or no randomize? */\n            p = Math.floor((lo + up)/2);  /* middle element is a good pivot */\n        else  /* for larger intervals, it is worth a random pivot */\n            p = choosePivot(lo, up, rnd);\n        lua_geti(L, 1, p);\n        lua_geti(L, 1, lo);\n        if (sort_comp(L, -2, -1))  /* a[p] < a[lo]? */\n            set2(L, p, lo);  /* swap a[p] - a[lo] */\n        else {\n            lua_pop(L, 1);  /* remove a[lo] */\n            lua_geti(L, 1, up);\n            if (sort_comp(L, -1, -2))  /* a[up] < a[p]? */\n                set2(L, p, up);  /* swap a[up] - a[p] */\n            else\n                lua_pop(L, 2);\n        }\n        if (up - lo == 2)  /* only 3 elements? */\n            return;  /* already sorted */\n        lua_geti(L, 1, p);  /* get middle element (Pivot) */\n        lua_pushvalue(L, -1);  /* push Pivot */\n        lua_geti(L, 1, up - 1);  /* push a[up - 1] */\n        set2(L, p, up - 1);  /* swap Pivot (a[p]) with a[up - 1] */\n        p = partition(L, lo, up);\n        let n;\n        /* a[lo .. p - 1] <= a[p] == P <= a[p + 1 .. up] */\n        if (p - lo < up - p) {  /* lower interval is smaller? */\n            auxsort(L, lo, p - 1, rnd);  /* call recursively for lower interval */\n            n = p - lo;  /* size of smaller interval */\n            lo = p + 1;  /* tail call for [p + 1 .. up] (upper interval) */\n        } else {\n            auxsort(L, p + 1, up, rnd);  /* call recursively for upper interval */\n            n = up - p;  /* size of smaller interval */\n            up = p - 1;  /* tail call for [lo .. p - 1]  (lower interval) */\n        }\n        if ((up - lo) / 128 > n) /* partition too imbalanced? */\n            rnd = l_randomizePivot();  /* try a new randomization */\n    }  /* tail call auxsort(L, lo, up, rnd) */\n};\n\nconst sort = function(L) {\n    let n = aux_getn(L, 1, TAB_RW);\n    if (n > 1) {  /* non-trivial interval? */\n        luaL_argcheck(L, n < LUA_MAXINTEGER, 1, \"array too big\");\n        if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */\n            luaL_checktype(L, 2, LUA_TFUNCTION);  /* must be a function */\n        lua_settop(L, 2);  /* make sure there are two arguments */\n        auxsort(L, 1, n, 0);\n    }\n    return 0;\n};\n\nconst tab_funcs = {\n    \"concat\": tconcat,\n    \"insert\": tinsert,\n    \"move\":   tmove,\n    \"pack\":   pack,\n    \"remove\": tremove,\n    \"sort\":   sort,\n    \"unpack\": unpack\n};\n\nconst luaopen_table = function(L) {\n    luaL_newlib(L, tab_funcs);\n    return 1;\n};\n\nmodule.exports.luaopen_table = luaopen_table;\n","\"use strict\";\n\nconst {\n    LUA_TNIL,\n    LUA_TTABLE,\n    lua_close,\n    lua_createtable,\n    lua_getfield,\n    lua_isboolean,\n    lua_isnoneornil,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushfstring,\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_pushnil,\n    lua_pushnumber,\n    lua_pushstring,\n    lua_setfield,\n    lua_settop,\n    lua_toboolean,\n    lua_tointegerx\n} = require('./lua.js');\nconst {\n    luaL_Buffer,\n    luaL_addchar,\n    luaL_addstring,\n    // luaL_argcheck,\n    luaL_argerror,\n    luaL_buffinit,\n    luaL_checkinteger,\n    luaL_checkstring,\n    luaL_checktype,\n    luaL_error,\n    luaL_execresult,\n    luaL_fileresult,\n    luaL_newlib,\n    luaL_optinteger,\n    luaL_optlstring,\n    luaL_optstring,\n    luaL_pushresult\n} = require('./lauxlib.js');\nconst {\n    luastring_eq,\n    to_jsstring,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\n/* options for ANSI C 89 (only 1-char options) */\n// const L_STRFTIMEC89 = to_luastring(\"aAbBcdHIjmMpSUwWxXyYZ%\");\n// const LUA_STRFTIMEOPTIONS = L_STRFTIMEC89;\n\n/* options for ISO C 99 and POSIX */\n// const L_STRFTIMEC99 = to_luastring(\"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%||EcECExEXEyEYOdOeOHOIOmOMOSOuOUOVOwOWOy\");  /* two-char options */\n// const LUA_STRFTIMEOPTIONS = L_STRFTIMEC99;\n\n/* options for Windows */\n// const L_STRFTIMEWIN = to_luastring(\"aAbBcdHIjmMpSUwWxXyYzZ%||#c#x#d#H#I#j#m#M#S#U#w#W#y#Y\");  /* two-char options */\n// const LUA_STRFTIMEOPTIONS = L_STRFTIMEWIN;\n\n/* options for our own strftime implementation\n  - should be superset of C89 options for compat\n  - missing from C99:\n      - ISO 8601 week specifiers: gGV\n      - > single char specifiers\n  - beyond C99:\n      - %k: TZ extension: space-padded 24-hour\n      - %l: TZ extension: space-padded 12-hour\n      - %P: GNU extension: lower-case am/pm\n*/\nconst LUA_STRFTIMEOPTIONS = to_luastring(\"aAbBcCdDeFhHIjklmMnpPrRStTuUwWxXyYzZ%\");\n\n\nconst setfield = function(L, key, value) {\n    lua_pushinteger(L, value);\n    lua_setfield(L, -2, to_luastring(key, true));\n};\n\nconst setallfields = function(L, time, utc) {\n    setfield(L, \"sec\",   utc ? time.getUTCSeconds()  : time.getSeconds());\n    setfield(L, \"min\",   utc ? time.getUTCMinutes()  : time.getMinutes());\n    setfield(L, \"hour\",  utc ? time.getUTCHours()    : time.getHours());\n    setfield(L, \"day\",   utc ? time.getUTCDate()     : time.getDate());\n    setfield(L, \"month\", (utc ? time.getUTCMonth()   : time.getMonth()) + 1);\n    setfield(L, \"year\",  utc ? time.getUTCFullYear() : time.getFullYear());\n    setfield(L, \"wday\",  (utc ? time.getUTCDay()     : time.getDay()) + 1);\n    setfield(L, \"yday\", Math.floor((time - (new Date(time.getFullYear(), 0, 0 /* shortcut to correct day by one */))) / 86400000));\n    // setboolfield(L, \"isdst\", time.get);\n};\n\nconst L_MAXDATEFIELD = (Number.MAX_SAFE_INTEGER / 2);\n\nconst getfield = function(L, key, d, delta) {\n    let t = lua_getfield(L, -1, to_luastring(key, true));  /* get field and its type */\n    let res = lua_tointegerx(L, -1);\n    if (res === false) {  /* field is not an integer? */\n        if (t !== LUA_TNIL)  /* some other value? */\n            return luaL_error(L, to_luastring(\"field '%s' is not an integer\"), key);\n        else if (d < 0)  /* absent field; no default? */\n            return luaL_error(L, to_luastring(\"field '%s' missing in date table\"), key);\n        res = d;\n    }\n    else {\n        if (!(-L_MAXDATEFIELD <= res && res <= L_MAXDATEFIELD))\n            return luaL_error(L, to_luastring(\"field '%s' is out-of-bound\"), key);\n        res -= delta;\n    }\n    lua_pop(L, 1);\n    return res;\n};\n\n\nconst locale = {\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ].map((s) => to_luastring(s)),\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"].map((s) => to_luastring(s)),\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"].map((s) => to_luastring(s)),\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"].map((s) => to_luastring(s)),\n    AM: to_luastring(\"AM\"),\n    PM: to_luastring(\"PM\"),\n    am: to_luastring(\"am\"),\n    pm: to_luastring(\"pm\"),\n    formats: {\n        c: to_luastring(\"%a %b %e %H:%M:%S %Y\"),\n        D: to_luastring(\"%m/%d/%y\"),\n        F: to_luastring(\"%Y-%m-%d\"),\n        R: to_luastring(\"%H:%M\"),\n        r: to_luastring(\"%I:%M:%S %p\"),\n        T: to_luastring(\"%H:%M:%S\"),\n        X: to_luastring(\"%T\"),\n        x: to_luastring(\"%D\")\n    }\n};\n\nconst week_number = function(date, start_of_week) {\n    // This works by shifting the weekday back by one day if we\n    // are treating Monday as the first day of the week.\n    let weekday = date.getDay();\n    if (start_of_week === 'monday') {\n        if (weekday === 0) // Sunday\n            weekday = 6;\n        else\n            weekday--;\n    }\n    let yday = (date - new Date(date.getFullYear(), 0, 1)) / 86400000;\n    return Math.floor((yday + 7 - weekday) / 7);\n};\n\nconst push_pad_2 = function(b, n, pad) {\n    if (n < 10)\n        luaL_addchar(b, pad);\n    luaL_addstring(b, to_luastring(String(n)));\n};\n\nconst strftime = function(L, b, s, date) {\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] !== 37 /* % */) {  /* not a conversion specifier? */\n            luaL_addchar(b, s[i++]);\n        } else {\n            i++;  /* skip '%' */\n            let len = checkoption(L, s, i);\n            /* each `case` has an example output above it for the UTC epoch */\n            switch(s[i]) {\n                // '%'\n                case 37 /* % */:\n                    luaL_addchar(b, 37);\n                    break;\n\n                // 'Thursday'\n                case 65 /* A */:\n                    luaL_addstring(b, locale.days[date.getDay()]);\n                    break;\n\n                // 'January'\n                case 66 /* B */:\n                    luaL_addstring(b, locale.months[date.getMonth()]);\n                    break;\n\n                // '19'\n                case 67 /* C */:\n                    push_pad_2(b, Math.floor(date.getFullYear() / 100), 48 /* 0 */);\n                    break;\n\n                // '01/01/70'\n                case 68 /* D */:\n                    strftime(L, b, locale.formats.D, date);\n                    break;\n\n                // '1970-01-01'\n                case 70 /* F */:\n                    strftime(L, b, locale.formats.F, date);\n                    break;\n\n                // '00'\n                case 72 /* H */:\n                    push_pad_2(b, date.getHours(), 48 /* 0 */);\n                    break;\n\n                // '12'\n                case 73 /* I */:\n                    push_pad_2(b, (date.getHours() + 11) % 12 + 1, 48 /* 0 */);\n                    break;\n\n                // '00'\n                case 77 /* M */:\n                    push_pad_2(b, date.getMinutes(), 48 /* 0 */);\n                    break;\n\n                // 'am'\n                case 80 /* P */:\n                    luaL_addstring(b, date.getHours() < 12 ? locale.am : locale.pm);\n                    break;\n\n                // '00:00'\n                case 82 /* R */:\n                    strftime(L, b, locale.formats.R, date);\n                    break;\n\n                // '00'\n                case 83 /* S */:\n                    push_pad_2(b, date.getSeconds(), 48 /* 0 */);\n                    break;\n\n                // '00:00:00'\n                case 84 /* T */:\n                    strftime(L, b, locale.formats.T, date);\n                    break;\n\n                // '00'\n                case 85 /* U */:\n                    push_pad_2(b, week_number(date, \"sunday\"), 48 /* 0 */);\n                    break;\n\n                // '00'\n                case 87 /* W */:\n                    push_pad_2(b, week_number(date, \"monday\"), 48 /* 0 */);\n                    break;\n\n                // '16:00:00'\n                case 88 /* X */:\n                    strftime(L, b, locale.formats.X, date);\n                    break;\n\n                // '1970'\n                case 89 /* Y */:\n                    luaL_addstring(b, to_luastring(String(date.getFullYear())));\n                    break;\n\n                // 'GMT'\n                case 90 /* Z */: {\n                    let tzString = date.toString().match(/\\(([\\w\\s]+)\\)/);\n                    if (tzString)\n                        luaL_addstring(b, to_luastring(tzString[1]));\n                    break;\n                }\n\n                // 'Thu'\n                case 97 /* a */:\n                    luaL_addstring(b, locale.shortDays[date.getDay()]);\n                    break;\n\n                // 'Jan'\n                case 98 /* b */:\n                case 104 /* h */:\n                    luaL_addstring(b, locale.shortMonths[date.getMonth()]);\n                    break;\n\n                // ''\n                case 99 /* c */:\n                    strftime(L, b, locale.formats.c, date);\n                    break;\n\n                // '01'\n                case 100 /* d */:\n                    push_pad_2(b, date.getDate(), 48 /* 0 */);\n                    break;\n\n                // ' 1'\n                case 101 /* e */:\n                    push_pad_2(b, date.getDate(), 32 /* space */);\n                    break;\n\n                // '000'\n                case 106 /* j */: {\n                    let yday = Math.floor((date - new Date(date.getFullYear(), 0, 1)) / 86400000);\n                    if (yday < 100) {\n                        if (yday < 10)\n                            luaL_addchar(b, 48 /* 0 */);\n                        luaL_addchar(b, 48 /* 0 */);\n                    }\n                    luaL_addstring(b, to_luastring(String(yday)));\n                    break;\n                }\n\n                // ' 0'\n                case 107 /* k */:\n                    push_pad_2(b, date.getHours(), 32 /* space */);\n                    break;\n\n                // '12'\n                case 108 /* l */:\n                    push_pad_2(b, (date.getHours() + 11) % 12 + 1, 32 /* space */);\n                    break;\n\n                // '01'\n                case 109 /* m */:\n                    push_pad_2(b, date.getMonth() + 1, 48 /* 0 */);\n                    break;\n\n                // '\\n'\n                case 110 /* n */:\n                    luaL_addchar(b, 10);\n                    break;\n\n                // 'AM'\n                case 112 /* p */:\n                    luaL_addstring(b, date.getHours() < 12 ? locale.AM : locale.PM);\n                    break;\n\n                // '12:00:00 AM'\n                case 114 /* r */:\n                    strftime(L, b, locale.formats.r, date);\n                    break;\n\n                // '0'\n                case 115 /* s */:\n                    luaL_addstring(b, to_luastring(String(Math.floor(date / 1000))));\n                    break;\n\n                // '\\t'\n                case 116 /* t */:\n                    luaL_addchar(b, 8);\n                    break;\n\n                // '4'\n                case 117 /* u */: {\n                    let day = date.getDay();\n                    luaL_addstring(b, to_luastring(String(day === 0 ? 7 : day)));\n                    break;\n                }\n\n                // '4'\n                case 119 /* w */:\n                    luaL_addstring(b, to_luastring(String(date.getDay())));\n                    break;\n\n                // '12/31/69'\n                case 120 /* x */:\n                    strftime(L, b, locale.formats.x, date);\n                    break;\n\n                // '70'\n                case 121 /* y */:\n                    push_pad_2(b, date.getFullYear() % 100, 48 /* 0 */);\n                    break;\n\n                // '+0000'\n                case 122 /* z */: {\n                    let off = date.getTimezoneOffset();\n                    if (off > 0) {\n                        luaL_addchar(b, 45 /* - */);\n                    } else {\n                        off = -off;\n                        luaL_addchar(b, 43 /* + */);\n                    }\n                    push_pad_2(b, Math.floor(off/60), 48 /* 0 */);\n                    push_pad_2(b, off % 60, 48 /* 0 */);\n                    break;\n                }\n            }\n            i += len;\n        }\n    }\n};\n\n\nconst checkoption = function(L, conv, i) {\n    let option = LUA_STRFTIMEOPTIONS;\n    let o = 0;\n    let oplen = 1;  /* length of options being checked */\n    for (; o < option.length && oplen <= (conv.length - i); o += oplen) {\n        if (option[o] === '|'.charCodeAt(0))  /* next block? */\n            oplen++;  /* will check options with next length (+1) */\n        else if (luastring_eq(conv.subarray(i, i+oplen), option.subarray(o, o+oplen))) {  /* match? */\n            return oplen;  /* return length */\n        }\n    }\n    luaL_argerror(L, 1,\n        lua_pushfstring(L, to_luastring(\"invalid conversion specifier '%%%s'\"), conv));\n};\n\n/* maximum size for an individual 'strftime' item */\n// const SIZETIMEFMT = 250;\n\n\nconst os_date = function(L) {\n    let s = luaL_optlstring(L, 1, \"%c\");\n    let stm = lua_isnoneornil(L, 2) ? new Date() : new Date(l_checktime(L, 2) * 1000);\n    let utc = false;\n    let i = 0;\n    if (s[i] === '!'.charCodeAt(0)) {  /* UTC? */\n        utc = true;\n        i++;  /* skip '!' */\n    }\n    if (s[i] === \"*\".charCodeAt(0) && s[i+1] === \"t\".charCodeAt(0)) {\n        lua_createtable(L, 0, 9);  /* 9 = number of fields */\n        setallfields(L, stm, utc);\n    } else {\n        let cc = new Uint8Array(4);\n        cc[0] = \"%\".charCodeAt(0);\n        let b = new luaL_Buffer();\n        luaL_buffinit(L, b);\n        strftime(L, b, s, stm);\n        luaL_pushresult(b);\n    }\n    return 1;\n};\n\nconst os_time = function(L) {\n    let t;\n    if (lua_isnoneornil(L, 1))  /* called without args? */\n        t = new Date();  /* get current time */\n    else {\n        luaL_checktype(L, 1, LUA_TTABLE);\n        lua_settop(L, 1);  /* make sure table is at the top */\n        t = new Date(\n            getfield(L, \"year\", -1, 0),\n            getfield(L, \"month\", -1, 1),\n            getfield(L, \"day\", -1, 0),\n            getfield(L, \"hour\", 12, 0),\n            getfield(L, \"min\", 0, 0),\n            getfield(L, \"sec\", 0, 0)\n        );\n        setallfields(L, t);\n    }\n\n    lua_pushinteger(L, Math.floor(t / 1000));\n    return 1;\n};\n\nconst l_checktime = function(L, arg) {\n    let t = luaL_checkinteger(L, arg);\n    // luaL_argcheck(L, t, arg, \"time out-of-bounds\");\n    return t;\n};\n\nconst os_difftime = function(L) {\n    let t1 = l_checktime(L, 1);\n    let t2 = l_checktime(L, 2);\n    lua_pushnumber(L, t1 - t2);\n    return 1;\n};\n\nconst syslib = {\n    \"date\": os_date,\n    \"difftime\": os_difftime,\n    \"time\": os_time\n};\n\nif (typeof process === \"undefined\") {\n    syslib.clock = function(L) {\n        lua_pushnumber(L, performance.now()/1000);\n        return 1;\n    };\n} else {\n    /* Only with Node */\n    const fs = require('fs');\n    const tmp = require('tmp');\n    const child_process = require('child_process');\n\n    syslib.exit = function(L) {\n        let status;\n        if (lua_isboolean(L, 1))\n            status = (lua_toboolean(L, 1) ? 0 : 1);\n        else\n            status = luaL_optinteger(L, 1, 0);\n        if (lua_toboolean(L, 2))\n            lua_close(L);\n        if (L) process.exit(status);  /* 'if' to avoid warnings for unreachable 'return' */\n        return 0;\n    };\n\n    syslib.getenv = function(L) {\n        let key = luaL_checkstring(L, 1);\n        key = to_jsstring(key); /* https://github.com/nodejs/node/issues/16961 */\n        if (Object.prototype.hasOwnProperty.call(process.env, key)) {\n            lua_pushliteral(L, process.env[key]);\n        } else {\n            lua_pushnil(L);\n        }\n        return 1;\n    };\n\n    syslib.clock = function(L) {\n        lua_pushnumber(L, process.uptime());\n        return 1;\n    };\n\n    const lua_tmpname = function() {\n        return tmp.tmpNameSync();\n    };\n\n    syslib.remove = function(L) {\n        let filename = luaL_checkstring(L, 1);\n        try {\n            fs.unlinkSync(filename);\n        } catch (e) {\n            if (e.code === 'EISDIR') {\n                try {\n                    fs.rmdirSync(filename);\n                } catch (e) {\n                    return luaL_fileresult(L, false, filename, e);\n                }\n            } else {\n                return luaL_fileresult(L, false, filename, e);\n            }\n        }\n        return luaL_fileresult(L, true);\n    };\n\n    syslib.rename = function(L) {\n        let fromname = luaL_checkstring(L, 1);\n        let toname = luaL_checkstring(L, 2);\n        try {\n            fs.renameSync(fromname, toname);\n        } catch (e) {\n            return luaL_fileresult(L, false, false, e);\n        }\n        return luaL_fileresult(L, true);\n    };\n\n    syslib.tmpname = function(L) {\n        let name = lua_tmpname();\n        if (!name)\n            return luaL_error(L, to_luastring(\"unable to generate a unique filename\"));\n        lua_pushstring(L, to_luastring(name));\n        return 1;\n    };\n\n    syslib.execute = function(L) {\n        let cmd = luaL_optstring(L, 1, null);\n        if (cmd !== null) {\n            try {\n                child_process.execSync(\n                    cmd,\n                    {\n                        stdio: [process.stdin, process.stdout, process.stderr]\n                    }\n                );\n            } catch (e) {\n                return luaL_execresult(L, e);\n            }\n\n            return luaL_execresult(L, null);\n        } else {\n            /* Assume a shell is available.\n               If it's good enough for musl it's good enough for us.\n               http://git.musl-libc.org/cgit/musl/tree/src/process/system.c?id=ac45692a53a1b8d2ede329d91652d43c1fb5dc8d#n22\n            */\n            lua_pushboolean(L, 1);\n            return 1;\n        }\n    };\n}\n\nconst luaopen_os = function(L) {\n    luaL_newlib(L, syslib);\n    return 1;\n};\n\nmodule.exports.luaopen_os = luaopen_os;\n","\"use strict\";\n\nconst { sprintf } = require('sprintf-js');\n\nconst {\n    LUA_INTEGER_FMT,\n    LUA_INTEGER_FRMLEN,\n    LUA_MININTEGER,\n    LUA_NUMBER_FMT,\n    LUA_NUMBER_FRMLEN,\n    frexp,\n    lua_getlocaledecpoint\n} = require('./luaconf.js');\nconst {\n    LUA_TBOOLEAN,\n    LUA_TFUNCTION,\n    LUA_TNIL,\n    LUA_TNUMBER,\n    LUA_TSTRING,\n    LUA_TTABLE,\n    lua_call,\n    lua_createtable,\n    lua_dump,\n    lua_gettable,\n    lua_gettop,\n    lua_isinteger,\n    lua_isstring,\n    lua_pop,\n    lua_pushcclosure,\n    lua_pushinteger,\n    lua_pushlightuserdata,\n    lua_pushliteral,\n    lua_pushlstring,\n    lua_pushnil,\n    lua_pushnumber,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_remove,\n    lua_setfield,\n    lua_setmetatable,\n    lua_settop,\n    lua_toboolean,\n    lua_tointeger,\n    lua_tonumber,\n    lua_tostring,\n    lua_touserdata,\n    lua_type,\n    lua_upvalueindex\n} = require('./lua.js');\nconst {\n    luaL_Buffer,\n    luaL_addchar,\n    luaL_addlstring,\n    luaL_addsize,\n    luaL_addstring,\n    luaL_addvalue,\n    luaL_argcheck,\n    luaL_argerror,\n    luaL_buffinit,\n    luaL_buffinitsize,\n    luaL_checkinteger,\n    luaL_checknumber,\n    luaL_checkstack,\n    luaL_checkstring,\n    luaL_checktype,\n    luaL_error,\n    luaL_newlib,\n    luaL_optinteger,\n    luaL_optstring,\n    luaL_prepbuffsize,\n    luaL_pushresult,\n    luaL_pushresultsize,\n    luaL_tolstring,\n    luaL_typename\n} = require('./lauxlib.js');\nconst lualib = require('./lualib.js');\nconst {\n    luastring_eq,\n    luastring_indexOf,\n    to_jsstring,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\nconst sL_ESC  = '%';\nconst L_ESC   = sL_ESC.charCodeAt(0);\n\n/*\n** maximum number of captures that a pattern can do during\n** pattern-matching. This limit is arbitrary, but must fit in\n** an unsigned char.\n*/\nconst LUA_MAXCAPTURES = 32;\n\n// (sizeof(size_t) < sizeof(int) ? MAX_SIZET : (size_t)(INT_MAX))\nconst MAXSIZE = 2147483647;\n\n/* Give natural (i.e. strings end at the first \\0) length of a string represented by an array of bytes */\nconst strlen = function(s) {\n    let len = luastring_indexOf(s, 0);\n    return len > -1 ? len : s.length;\n};\n\n/* translate a relative string position: negative means back from end */\nconst posrelat = function(pos, len) {\n    if (pos >= 0) return pos;\n    else if (0 - pos > len) return 0;\n    else return len + pos + 1;\n};\n\nconst str_sub = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let start = posrelat(luaL_checkinteger(L, 2), l);\n    let end = posrelat(luaL_optinteger(L, 3, -1), l);\n    if (start < 1) start = 1;\n    if (end > l) end = l;\n    if (start <= end)\n        lua_pushstring(L, s.subarray(start - 1, (start - 1) + (end - start + 1)));\n    else lua_pushliteral(L, \"\");\n    return 1;\n};\n\nconst str_len = function(L) {\n    lua_pushinteger(L, luaL_checkstring(L, 1).length);\n    return 1;\n};\n\nconst str_char = function(L) {\n    let n = lua_gettop(L);  /* number of arguments */\n    let b = new luaL_Buffer();\n    let p = luaL_buffinitsize(L, b, n);\n    for (let i = 1; i <= n; i++) {\n        let c = luaL_checkinteger(L, i);\n        luaL_argcheck(L, c >= 0 && c <= 255, \"value out of range\"); // Strings are 8-bit clean\n        p[i-1] = c;\n    }\n    luaL_pushresultsize(b, n);\n    return 1;\n};\n\nconst writer = function(L, b, size, B) {\n    luaL_addlstring(B, b, size);\n    return 0;\n};\n\nconst str_dump = function(L) {\n    let b = new luaL_Buffer();\n    let strip = lua_toboolean(L, 2);\n    luaL_checktype(L, 1, LUA_TFUNCTION);\n    lua_settop(L, 1);\n    luaL_buffinit(L, b);\n    if (lua_dump(L, writer, b, strip) !== 0)\n        return luaL_error(L, to_luastring(\"unable to dump given function\"));\n    luaL_pushresult(b);\n    return 1;\n};\n\nconst SIZELENMOD = LUA_NUMBER_FRMLEN.length + 1;\n\nconst L_NBFD = 1;\n\nconst num2straux = function(x) {\n    /* if 'inf' or 'NaN', format it like '%g' */\n    if (Object.is(x, Infinity))\n        return to_luastring('inf');\n    else if (Object.is(x, -Infinity))\n        return to_luastring('-inf');\n    else if (Number.isNaN(x))\n        return to_luastring('nan');\n    else if (x === 0) {  /* can be -0... */\n        /* create \"0\" or \"-0\" followed by exponent */\n        let zero = sprintf(LUA_NUMBER_FMT + \"x0p+0\", x);\n        if (Object.is(x, -0))\n            zero = \"-\" + zero;\n        return to_luastring(zero);\n    } else {\n        let buff = \"\";\n        let fe = frexp(x);  /* 'x' fraction and exponent */\n        let m = fe[0];\n        let e = fe[1];\n        if (m < 0) {  /* is number negative? */\n            buff += '-';  /* add signal */\n            m = -m;  /* make it positive */\n        }\n        buff += \"0x\";  /* add \"0x\" */\n        buff += (m * (1<<L_NBFD)).toString(16);\n        e -= L_NBFD;  /* this digit goes before the radix point */\n        buff += sprintf(\"p%+d\", e);  /* add exponent */\n        return to_luastring(buff);\n    }\n};\n\nconst lua_number2strx = function(L, fmt, x) {\n    let buff = num2straux(x);\n    if (fmt[SIZELENMOD] === 65 /* 'A'.charCodeAt(0) */) {\n        for (let i = 0; i < buff.length; i++) {\n            let c = buff[i];\n            if (c >= 97) /* toupper */\n                buff[i] = c & 0xdf;\n        }\n    } else if (fmt[SIZELENMOD] !== 97 /* 'a'.charCodeAt(0) */)\n        luaL_error(L, to_luastring(\"modifiers for format '%%a'/'%%A' not implemented\"));\n    return buff;\n};\n\n/*\n** Maximum size of each formatted item. This maximum size is produced\n** by format('%.99f', -maxfloat), and is equal to 99 + 3 ('-', '.',\n** and '\\0') + number of decimal digits to represent maxfloat (which\n** is maximum exponent + 1). (99+3+1 then rounded to 120 for \"extra\n** expenses\", such as locale-dependent stuff)\n*/\n// const MAX_ITEM   = 120;// TODO: + l_mathlim(MAX_10_EXP);\n\n\n/* valid flags in a format specification */\nconst FLAGS = to_luastring(\"-+ #0\");\n\n/*\n** maximum size of each format specification (such as \"%-099.99d\")\n*/\n// const MAX_FORMAT = 32;\n\nconst isalpha = e => (97 <= e && e <= 122) || (65 <= e && e <= 90);\nconst isdigit = e => 48 <= e && e <= 57;\nconst iscntrl = e => (0x00 <= e && e <= 0x1f) || e === 0x7f;\nconst isgraph = e => 33 <= e && e <= 126;\nconst islower = e => 97 <= e && e <= 122;\nconst isupper = e => 65 <= e && e <= 90;\nconst isalnum = e => (97 <= e && e <= 122) || (65 <= e && e <= 90) || (48 <= e && e <= 57);\nconst ispunct = e => isgraph(e) && !isalnum(e);\nconst isspace = e => e === 32 || (e >= 9 && e <= 13);\nconst isxdigit = e => (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102);\n\nconst addquoted = function(b, s, len) {\n    luaL_addchar(b, 34 /* '\"'.charCodeAt(0) */);\n    let i = 0;\n    while (len--) {\n        if (s[i] === 34 /* '\"'.charCodeAt(0) */ ||\n            s[i] === 92 /* '\\\\'.charCodeAt(0) */ ||\n            s[i] === 10 /* '\\n'.charCodeAt(0) */) {\n            luaL_addchar(b, 92 /* '\\\\'.charCodeAt(0) */);\n            luaL_addchar(b, s[i]);\n        } else if (iscntrl(s[i])) {\n            let buff = ''+s[i];\n            if (isdigit(s[i+1]))\n                buff = '0'.repeat(3-buff.length) + buff; /* pad to 3 '0's */\n            luaL_addstring(b, to_luastring(\"\\\\\" + buff));\n        } else\n            luaL_addchar(b, s[i]);\n        i++;\n    }\n    luaL_addchar(b, 34 /* '\"'.charCodeAt(0) */);\n};\n\n/*\n** Ensures the 'buff' string uses a dot as the radix character.\n*/\nconst checkdp = function(buff) {\n    if (luastring_indexOf(buff, 46 /* ('.').charCodeAt(0) */) < 0) {  /* no dot? */\n        let point = lua_getlocaledecpoint();  /* try locale point */\n        let ppoint = luastring_indexOf(buff, point);\n        if (ppoint) buff[ppoint] = 46 /* ('.').charCodeAt(0) */;  /* change it to a dot */\n    }\n};\n\nconst addliteral = function(L, b, arg) {\n    switch(lua_type(L, arg)) {\n        case LUA_TSTRING: {\n            let s = lua_tostring(L, arg);\n            addquoted(b, s, s.length);\n            break;\n        }\n        case LUA_TNUMBER: {\n            let buff;\n            if (!lua_isinteger(L, arg)) {  /* float? */\n                let n = lua_tonumber(L, arg);  /* write as hexa ('%a') */\n                buff = lua_number2strx(L, to_luastring(`%${LUA_INTEGER_FRMLEN}a`), n);\n                checkdp(buff);  /* ensure it uses a dot */\n            } else {  /* integers */\n                let n = lua_tointeger(L, arg);\n                let format = (n === LUA_MININTEGER)  /* corner case? */\n                    ? \"0x%\" + LUA_INTEGER_FRMLEN + \"x\"  /* use hexa */\n                    : LUA_INTEGER_FMT;  /* else use default format */\n                buff = to_luastring(sprintf(format, n));\n            }\n            luaL_addstring(b, buff);\n            break;\n        }\n        case LUA_TNIL: case LUA_TBOOLEAN: {\n            luaL_tolstring(L, arg);\n            luaL_addvalue(b);\n            break;\n        }\n        default: {\n            luaL_argerror(L, arg, to_luastring(\"value has no literal form\"));\n        }\n    }\n};\n\nconst scanformat = function(L, strfrmt, i, form) {\n    let p = i;\n    while (strfrmt[p] !== 0 && luastring_indexOf(FLAGS, strfrmt[p]) >= 0) p++;  /* skip flags */\n    if (p - i >= FLAGS.length)\n        luaL_error(L, to_luastring(\"invalid format (repeated flags)\"));\n    if (isdigit(strfrmt[p])) p++;  /* skip width */\n    if (isdigit(strfrmt[p])) p++;  /* (2 digits at most) */\n    if (strfrmt[p] === 46 /* '.'.charCodeAt(0) */) {\n        p++;\n        if (isdigit(strfrmt[p])) p++;  /* skip precision */\n        if (isdigit(strfrmt[p])) p++;  /* (2 digits at most) */\n    }\n    if (isdigit(strfrmt[p]))\n        luaL_error(L, to_luastring(\"invalid format (width or precision too long)\"));\n    form[0] = 37 /* \"%\".charCodeAt(0) */;\n    for (let j = 0; j < p - i + 1; j++)\n        form[j+1] = strfrmt[i+j];\n    return p;\n};\n\n/*\n** add length modifier into formats\n*/\nconst addlenmod = function(form, lenmod) {\n    let l = form.length;\n    let lm = lenmod.length;\n    let spec = form[l - 1];\n    for (let i = 0; i < lm; i++)\n        form[i + l - 1] = lenmod[i];\n    form[l + lm - 1] = spec;\n    // form[l + lm] = 0;\n};\n\nconst str_format = function(L) {\n    let top = lua_gettop(L);\n    let arg = 1;\n    let strfrmt = luaL_checkstring(L, arg);\n    let i = 0;\n    let b = new luaL_Buffer();\n    luaL_buffinit(L, b);\n    while (i < strfrmt.length) {\n        if (strfrmt[i] !== L_ESC) {\n            luaL_addchar(b, strfrmt[i++]);\n        } else if (strfrmt[++i] === L_ESC) {\n            luaL_addchar(b, strfrmt[i++]); /* %% */\n        } else { /* format item */\n            let form = [];  /* to store the format ('%...') */\n            if (++arg > top)\n                luaL_argerror(L, arg, to_luastring(\"no value\"));\n            i = scanformat(L, strfrmt, i, form);\n            switch (String.fromCharCode(strfrmt[i++])) {\n                case 'c': {\n                    // sprintf(String.fromCharCode(...form), luaL_checkinteger(L, arg));\n                    luaL_addchar(b, luaL_checkinteger(L, arg));\n                    break;\n                }\n                case 'd': case 'i':\n                case 'o': case 'u': case 'x': case 'X': {\n                    let n = luaL_checkinteger(L, arg);\n                    addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));\n                    luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), n)));\n                    break;\n                }\n                case 'a': case 'A': {\n                    addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));\n                    luaL_addstring(b, lua_number2strx(L, form, luaL_checknumber(L, arg)));\n                    break;\n                }\n                case 'e': case 'E': case 'f':\n                case 'g': case 'G': {\n                    let n = luaL_checknumber(L, arg);\n                    addlenmod(form, to_luastring(LUA_INTEGER_FRMLEN, true));\n                    luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), n)));\n                    break;\n                }\n                case 'q': {\n                    addliteral(L, b, arg);\n                    break;\n                }\n                case 's': {\n                    let s = luaL_tolstring(L, arg);\n                    if (form.length <= 2 || form[2] === 0) {  /* no modifiers? */\n                        luaL_addvalue(b);  /* keep entire string */\n                    } else {\n                        luaL_argcheck(L, s.length === strlen(s), arg, \"string contains zeros\");\n                        if (luastring_indexOf(form, 46 /* '.'.charCodeAt(0) */) < 0 && s.length >= 100) {\n                            /* no precision and string is too long to be formatted */\n                            luaL_addvalue(b);  /* keep entire string */\n                        } else {  /* format the string into 'buff' */\n                            // TODO: will fail if s is not valid UTF-8\n                            luaL_addstring(b, to_luastring(sprintf(String.fromCharCode(...form), to_jsstring(s))));\n                            lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */\n                        }\n                    }\n                    break;\n                }\n                default: {  /* also treat cases 'pnLlh' */\n                    return luaL_error(L, to_luastring(\"invalid option '%%%c' to 'format'\"), strfrmt[i-1]);\n                }\n            }\n        }\n    }\n    luaL_pushresult(b);\n    return 1;\n};\n\n/* value used for padding */\nconst LUAL_PACKPADBYTE = 0x00;\n\n/* maximum size for the binary representation of an integer */\nconst MAXINTSIZE = 16;\n\nconst SZINT = 4; // Size of lua_Integer\n\n/* number of bits in a character */\nconst NB = 8;\n\n/* mask for one character (NB 1's) */\nconst MC = ((1 << NB) - 1);\n\nconst MAXALIGN = 8;\n\n/*\n** information to pack/unpack stuff\n*/\nclass Header {\n    constructor(L) {\n        this.L = L;\n        this.islittle = true;\n        this.maxalign = 1;\n    }\n}\n\n/*\n** options for pack/unpack\n*/\nconst Kint       = 0; /* signed integers */\nconst Kuint      = 1; /* unsigned integers */\nconst Kfloat     = 2; /* floating-point numbers */\nconst Kchar      = 3; /* fixed-length strings */\nconst Kstring    = 4; /* strings with prefixed length */\nconst Kzstr      = 5; /* zero-terminated strings */\nconst Kpadding   = 6; /* padding */\nconst Kpaddalign = 7; /* padding for alignment */\nconst Knop       = 8; /* no-op (configuration or spaces) */\n\nconst digit = isdigit;\n\nconst getnum = function(fmt, df) {\n    if (fmt.off >= fmt.s.length || !digit(fmt.s[fmt.off]))  /* no number? */\n        return df;  /* return default value */\n    else {\n        let a = 0;\n        do {\n            a = a * 10 + (fmt.s[fmt.off++] - 48 /* '0'.charCodeAt(0) */);\n        } while (fmt.off < fmt.s.length && digit(fmt.s[fmt.off]) && a <= (MAXSIZE - 9)/10);\n        return a;\n    }\n};\n\n/*\n** Read an integer numeral and raises an error if it is larger\n** than the maximum size for integers.\n*/\nconst getnumlimit = function(h, fmt, df) {\n    let sz = getnum(fmt, df);\n    if (sz > MAXINTSIZE || sz <= 0)\n        luaL_error(h.L, to_luastring(\"integral size (%d) out of limits [1,%d]\"), sz, MAXINTSIZE);\n    return sz;\n};\n\n/*\n** Read and classify next option. 'size' is filled with option's size.\n*/\nconst getoption = function(h, fmt) {\n    let r = {\n        opt: fmt.s[fmt.off++],\n        size: 0  /* default */\n    };\n    switch (r.opt) {\n        case 98  /*'b'*/: r.size = 1; r.opt = Kint;   return r; // sizeof(char): 1\n        case 66  /*'B'*/: r.size = 1; r.opt = Kuint;  return r;\n        case 104 /*'h'*/: r.size = 2; r.opt = Kint;   return r; // sizeof(short): 2\n        case 72  /*'H'*/: r.size = 2; r.opt = Kuint;  return r;\n        case 108 /*'l'*/: r.size = 4; r.opt = Kint;   return r; // sizeof(long): 4\n        case 76  /*'L'*/: r.size = 4; r.opt = Kuint;  return r;\n        case 106 /*'j'*/: r.size = 4; r.opt = Kint;   return r; // sizeof(lua_Integer): 4\n        case 74  /*'J'*/: r.size = 4; r.opt = Kuint;  return r;\n        case 84  /*'T'*/: r.size = 4; r.opt = Kuint;  return r; // sizeof(size_t): 4\n        case 102 /*'f'*/: r.size = 4; r.opt = Kfloat; return r; // sizeof(float): 4\n        case 100 /*'d'*/: r.size = 8; r.opt = Kfloat; return r; // sizeof(double): 8\n        case 110 /*'n'*/: r.size = 8; r.opt = Kfloat; return r; // sizeof(lua_Number): 8\n        case 105 /*'i'*/: r.size = getnumlimit(h, fmt, 4); r.opt = Kint;    return r; // sizeof(int): 4\n        case 73  /*'I'*/: r.size = getnumlimit(h, fmt, 4); r.opt = Kuint;   return r;\n        case 115 /*'s'*/: r.size = getnumlimit(h, fmt, 4); r.opt = Kstring; return r;\n        case 99  /*'c'*/: {\n            r.size = getnum(fmt, -1);\n            if (r.size === -1)\n                luaL_error(h.L, to_luastring(\"missing size for format option 'c'\"));\n            r.opt = Kchar;\n            return r;\n        }\n        case 122 /*'z'*/:             r.opt = Kzstr;      return r;\n        case 120 /*'x'*/: r.size = 1; r.opt = Kpadding;   return r;\n        case 88  /*'X'*/:             r.opt = Kpaddalign; return r;\n        case 32  /*' '*/: break;\n        case 60  /*'<'*/: h.islittle = true; break;\n        case 62  /*'>'*/: h.islittle = false; break;\n        case 61  /*'='*/: h.islittle = true; break;\n        case 33  /*'!'*/: h.maxalign = getnumlimit(h, fmt, MAXALIGN); break;\n        default: luaL_error(h.L, to_luastring(\"invalid format option '%c'\"), r.opt);\n    }\n    r.opt = Knop;\n    return r;\n};\n\n/*\n** Read, classify, and fill other details about the next option.\n** 'psize' is filled with option's size, 'notoalign' with its\n** alignment requirements.\n** Local variable 'size' gets the size to be aligned. (Kpadal option\n** always gets its full alignment, other options are limited by\n** the maximum alignment ('maxalign'). Kchar option needs no alignment\n** despite its size.\n*/\nconst getdetails = function(h, totalsize, fmt) {\n    let r = {\n        opt: NaN,\n        size: NaN,\n        ntoalign: NaN\n    };\n\n    let opt = getoption(h, fmt);\n    r.size = opt.size;\n    r.opt = opt.opt;\n    let align = r.size;  /* usually, alignment follows size */\n    if (r.opt === Kpaddalign) {  /* 'X' gets alignment from following option */\n        if (fmt.off >= fmt.s.length || fmt.s[fmt.off] === 0)\n            luaL_argerror(h.L, 1, to_luastring(\"invalid next option for option 'X'\"));\n        else {\n            let o = getoption(h, fmt);\n            align = o.size;\n            o = o.opt;\n            if (o === Kchar || align === 0)\n                luaL_argerror(h.L, 1, to_luastring(\"invalid next option for option 'X'\"));\n        }\n    }\n    if (align <= 1 || r.opt === Kchar)  /* need no alignment? */\n        r.ntoalign = 0;\n    else {\n        if (align > h.maxalign)  /* enforce maximum alignment */\n            align = h.maxalign;\n        if ((align & (align -1)) !== 0)  /* is 'align' not a power of 2? */\n            luaL_argerror(h.L, 1, to_luastring(\"format asks for alignment not power of 2\"));\n        r.ntoalign = (align - (totalsize & (align - 1))) & (align - 1);\n    }\n    return r;\n};\n\n/*\n** Pack integer 'n' with 'size' bytes and 'islittle' endianness.\n** The final 'if' handles the case when 'size' is larger than\n** the size of a Lua integer, correcting the extra sign-extension\n** bytes if necessary (by default they would be zeros).\n*/\nconst packint = function(b, n, islittle, size, neg) {\n    let buff = luaL_prepbuffsize(b, size);\n    buff[islittle ? 0 : size - 1] = n & MC;  /* first byte */\n    for (let i = 1; i < size; i++) {\n        n >>= NB;\n        buff[islittle ? i : size - 1 - i] = n & MC;\n    }\n    if (neg && size > SZINT) {  /* negative number need sign extension? */\n        for (let i = SZINT; i < size; i++)  /* correct extra bytes */\n            buff[islittle ? i : size - 1 - i] = MC;\n    }\n    luaL_addsize(b, size);  /* add result to buffer */\n};\n\nconst str_pack = function(L) {\n    let b = new luaL_Buffer();\n    let h = new Header(L);\n    let fmt = {\n        s: luaL_checkstring(L, 1),  /* format string */\n        off: 0\n    };\n    let arg = 1;  /* current argument to pack */\n    let totalsize = 0;  /* accumulate total size of result */\n    lua_pushnil(L);  /* mark to separate arguments from string buffer */\n    luaL_buffinit(L, b);\n    while (fmt.off < fmt.s.length) {\n        let details = getdetails(h, totalsize, fmt);\n        let opt = details.opt;\n        let size = details.size;\n        let ntoalign = details.ntoalign;\n        totalsize += ntoalign + size;\n        while (ntoalign-- > 0)\n            luaL_addchar(b, LUAL_PACKPADBYTE);  /* fill alignment */\n        arg++;\n        switch (opt) {\n            case Kint: {  /* signed integers */\n                let n = luaL_checkinteger(L, arg);\n                if (size < SZINT) {  /* need overflow check? */\n                    let lim = 1 << (size * 8) - 1;\n                    luaL_argcheck(L, -lim <= n && n < lim, arg, \"integer overflow\");\n                }\n                packint(b, n, h.islittle, size, n < 0);\n                break;\n            }\n            case Kuint: {  /* unsigned integers */\n                let n = luaL_checkinteger(L, arg);\n                if (size < SZINT)\n                    luaL_argcheck(L, (n>>>0) < (1 << (size * NB)), arg, \"unsigned overflow\");\n                packint(b, n>>>0, h.islittle, size, false);\n                break;\n            }\n            case Kfloat: {  /* floating-point options */\n                let buff = luaL_prepbuffsize(b, size);\n                let n = luaL_checknumber(L, arg);  /* get argument */\n                let dv = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n                if (size === 4) dv.setFloat32(0, n, h.islittle);\n                else dv.setFloat64(0, n, h.islittle);\n                luaL_addsize(b, size);\n                break;\n            }\n            case Kchar: {  /* fixed-size string */\n                let s = luaL_checkstring(L, arg);\n                let len = s.length;\n                luaL_argcheck(L, len <= size, arg, \"string longer than given size\");\n                luaL_addlstring(b, s, len);  /* add string */\n                while (len++ < size)  /* pad extra space */\n                    luaL_addchar(b, LUAL_PACKPADBYTE);\n                break;\n            }\n            case Kstring: {  /* strings with length count */\n                let s = luaL_checkstring(L, arg);\n                let len = s.length;\n                luaL_argcheck(L,\n                    size >= 4 /* sizeof(size_t) */ || len < (1 << (size * NB)),\n                    arg, \"string length does not fit in given size\");\n                packint(b, len, h.islittle, size, 0);  /* pack length */\n                luaL_addlstring(b, s, len);\n                totalsize += len;\n                break;\n            }\n            case Kzstr: {  /* zero-terminated string */\n                let s = luaL_checkstring(L, arg);\n                let len = s.length;\n                luaL_argcheck(L, luastring_indexOf(s, 0) < 0, arg, \"strings contains zeros\");\n                luaL_addlstring(b, s, len);\n                luaL_addchar(b, 0);  /* add zero at the end */\n                totalsize += len + 1;\n                break;\n            }\n            case Kpadding: luaL_addchar(b, LUAL_PACKPADBYTE); /* fall through */\n            case Kpaddalign: case Knop:\n                arg--;  /* undo increment */\n                break;\n        }\n    }\n    luaL_pushresult(b);\n    return 1;\n};\n\nconst str_reverse = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let r = new Uint8Array(l);\n    for (let i=0; i<l; i++)\n        r[i] = s[l-1-i];\n    lua_pushstring(L, r);\n    return 1;\n};\n\nconst str_lower = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let r = new Uint8Array(l);\n    for (let i=0; i<l; i++) {\n        let c = s[i];\n        if (isupper(c))\n            c = c | 0x20;\n        r[i] = c;\n    }\n    lua_pushstring(L, r);\n    return 1;\n};\n\nconst str_upper = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let r = new Uint8Array(l);\n    for (let i=0; i<l; i++) {\n        let c = s[i];\n        if (islower(c))\n            c = c & 0xdf;\n        r[i] = c;\n    }\n    lua_pushstring(L, r);\n    return 1;\n};\n\nconst str_rep = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let n = luaL_checkinteger(L, 2);\n    let sep = luaL_optstring(L, 3, \"\");\n    let lsep = sep.length;\n    if (n <= 0) lua_pushliteral(L, \"\");\n    else if (l + lsep < l || l + lsep > MAXSIZE / n)  /* may overflow? */\n        return luaL_error(L, to_luastring(\"resulting string too large\"));\n    else {\n        let totallen = n * l + (n - 1) * lsep;\n        let b = new luaL_Buffer();\n        let p = luaL_buffinitsize(L, b, totallen);\n        let pi = 0;\n        while (n-- > 1) {  /* first n-1 copies (followed by separator) */\n            p.set(s, pi);\n            pi += l;\n            if (lsep > 0) {  /* empty 'memcpy' is not that cheap */\n                p.set(sep, pi);\n                pi += lsep;\n            }\n        }\n        p.set(s, pi);  /* last copy (not followed by separator) */\n        luaL_pushresultsize(b, totallen);\n    }\n    return 1;\n};\n\nconst str_byte = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let l = s.length;\n    let posi = posrelat(luaL_optinteger(L, 2, 1), l);\n    let pose = posrelat(luaL_optinteger(L, 3, posi), l);\n\n    if (posi < 1) posi = 1;\n    if (pose > l) pose = l;\n    if (posi > pose) return 0;  /* empty interval; return no values */\n    if (pose - posi >= Number.MAX_SAFE_INTEGER)  /* arithmetic overflow? */\n        return luaL_error(L, \"string slice too long\");\n\n    let n = (pose - posi) + 1;\n    luaL_checkstack(L, n, \"string slice too long\");\n    for (let i = 0; i < n; i++)\n        lua_pushinteger(L, s[posi + i - 1]);\n    return n;\n};\n\nconst str_packsize = function(L) {\n    let h = new Header(L);\n    let fmt = {\n        s: luaL_checkstring(L, 1),\n        off: 0\n    };\n    let totalsize = 0;  /* accumulate total size of result */\n    while (fmt.off < fmt.s.length) {\n        let details = getdetails(h, totalsize, fmt);\n        let opt = details.opt;\n        let size = details.size;\n        let ntoalign = details.ntoalign;\n        size += ntoalign;  /* total space used by option */\n        luaL_argcheck(L, totalsize <= MAXSIZE - size, 1, \"format result too large\");\n        totalsize += size;\n        switch (opt) {\n            case Kstring:  /* strings with length count */\n            case Kzstr:    /* zero-terminated string */\n                luaL_argerror(L, 1, \"variable-length format\");\n                /* call never return, but to avoid warnings: *//* fall through */\n            default:  break;\n        }\n    }\n    lua_pushinteger(L, totalsize);\n    return 1;\n};\n\n/*\n** Unpack an integer with 'size' bytes and 'islittle' endianness.\n** If size is smaller than the size of a Lua integer and integer\n** is signed, must do sign extension (propagating the sign to the\n** higher bits); if size is larger than the size of a Lua integer,\n** it must check the unread bytes to see whether they do not cause an\n** overflow.\n*/\nconst unpackint = function(L, str, islittle, size, issigned) {\n    let res = 0;\n    let limit = size <= SZINT ? size : SZINT;\n    for (let i = limit - 1; i >= 0; i--) {\n        res <<= NB;\n        res |= str[islittle ? i : size - 1 - i];\n    }\n    if (size < SZINT) {  /* real size smaller than lua_Integer? */\n        if (issigned) {  /* needs sign extension? */\n            let mask = 1 << (size * NB - 1);\n            res = ((res ^ mask) - mask);  /* do sign extension */\n        }\n    } else if (size > SZINT) {  /* must check unread bytes */\n        let mask = !issigned || res >= 0 ? 0 : MC;\n        for (let i = limit; i < size; i++) {\n            if (str[islittle ? i : size - 1 - i] !== mask)\n                luaL_error(L, to_luastring(\"%d-byte integer does not fit into Lua Integer\"), size);\n        }\n    }\n    return res;\n};\n\nconst unpacknum = function(L, b, islittle, size) {\n    lualib.lua_assert(b.length >= size);\n\n    let dv = new DataView(new ArrayBuffer(size));\n    for (let i = 0; i < size; i++)\n        dv.setUint8(i, b[i], islittle);\n\n    if (size == 4) return dv.getFloat32(0, islittle);\n    else return dv.getFloat64(0, islittle);\n};\n\nconst str_unpack = function(L) {\n    let h = new Header(L);\n    let fmt = {\n        s: luaL_checkstring(L, 1),\n        off: 0\n    };\n    let data = luaL_checkstring(L, 2);\n    let ld = data.length;\n    let pos = posrelat(luaL_optinteger(L, 3, 1), ld) - 1;\n    let n = 0;  /* number of results */\n    luaL_argcheck(L, pos <= ld && pos >= 0, 3, \"initial position out of string\");\n    while (fmt.off < fmt.s.length) {\n        let details = getdetails(h, pos, fmt);\n        let opt = details.opt;\n        let size = details.size;\n        let ntoalign = details.ntoalign;\n        if (/*ntoalign + size > ~pos ||*/ pos + ntoalign + size > ld)\n            luaL_argerror(L, 2, to_luastring(\"data string too short\"));\n        pos += ntoalign;  /* skip alignment */\n        /* stack space for item + next position */\n        luaL_checkstack(L, 2, \"too many results\");\n        n++;\n        switch (opt) {\n            case Kint:\n            case Kuint: {\n                let res = unpackint(L, data.subarray(pos), h.islittle, size, opt === Kint);\n                lua_pushinteger(L, res);\n                break;\n            }\n            case Kfloat: {\n                let res = unpacknum(L, data.subarray(pos), h.islittle, size);\n                lua_pushnumber(L, res);\n                break;\n            }\n            case Kchar: {\n                lua_pushstring(L, data.subarray(pos, pos + size));\n                break;\n            }\n            case Kstring: {\n                let len = unpackint(L, data.subarray(pos), h.islittle, size, 0);\n                luaL_argcheck(L, pos + len + size <= ld, 2, \"data string too short\");\n                lua_pushstring(L, data.subarray(pos + size, pos + size + len));\n                pos += len;  /* skip string */\n                break;\n            }\n            case Kzstr: {\n                let e = luastring_indexOf(data, 0, pos);\n                if (e === -1) e = data.length - pos;\n                lua_pushstring(L, data.subarray(pos, e));\n                pos = e + 1;  /* skip string plus final '\\0' */\n                break;\n            }\n            case Kpaddalign: case Kpadding: case Knop:\n                n--;  /* undo increment */\n                break;\n        }\n        pos += size;\n    }\n    lua_pushinteger(L, pos + 1);  /* next position */\n    return n + 1;\n};\n\nconst CAP_UNFINISHED = -1;\nconst CAP_POSITION   = -2;\nconst MAXCCALLS      = 200;\nconst SPECIALS       = to_luastring(\"^$*+?.([%-\");\n\nclass MatchState {\n    constructor(L) {\n        this.src = null;  /* unmodified source string */\n        this.src_init = null;  /* init of source string */\n        this.src_end = null;  /* end ('\\0') of source string */\n        this.p = null;  /* unmodified pattern string */\n        this.p_end = null;  /* end ('\\0') of pattern */\n        this.L = L;\n        this.matchdepth = NaN;  /* control for recursive depth */\n        this.level = NaN;  /* total number of captures (finished or unfinished) */\n        this.capture = [];\n    }\n}\n\nconst check_capture = function(ms, l) {\n    l = l - 49 /* '1'.charCodeAt(0) */;\n    if (l < 0 || l >= ms.level || ms.capture[l].len === CAP_UNFINISHED)\n        return luaL_error(ms.L, to_luastring(\"invalid capture index %%%d\"), l + 1);\n    return l;\n};\n\nconst capture_to_close = function(ms) {\n    let level = ms.level;\n    for (level--; level >= 0; level--)\n        if (ms.capture[level].len === CAP_UNFINISHED) return level;\n    return luaL_error(ms.L, to_luastring(\"invalid pattern capture\"));\n};\n\nconst classend = function(ms, p) {\n    switch(ms.p[p++]) {\n        case L_ESC: {\n            if (p === ms.p_end)\n                luaL_error(ms.L, to_luastring(\"malformed pattern (ends with '%%')\"));\n            return p + 1;\n        }\n        case 91 /* '['.charCodeAt(0) */: {\n            if (ms.p[p] === 94 /* '^'.charCodeAt(0) */) p++;\n            do {  /* look for a ']' */\n                if (p === ms.p_end)\n                    luaL_error(ms.L, to_luastring(\"malformed pattern (missing ']')\"));\n                if (ms.p[p++] === L_ESC && p < ms.p_end)\n                    p++;  /* skip escapes (e.g. '%]') */\n            } while (ms.p[p] !== 93 /* ']'.charCodeAt(0) */);\n            return p + 1;\n        }\n        default: {\n            return p;\n        }\n    }\n};\n\nconst match_class = function(c, cl) {\n    switch (cl) {\n        case 97  /* 'a'.charCodeAt(0) */: return  isalpha(c);\n        case 65  /* 'A'.charCodeAt(0) */: return !isalpha(c);\n        case 99  /* 'c'.charCodeAt(0) */: return  iscntrl(c);\n        case 67  /* 'C'.charCodeAt(0) */: return !iscntrl(c);\n        case 100 /* 'd'.charCodeAt(0) */: return  isdigit(c);\n        case 68  /* 'D'.charCodeAt(0) */: return !isdigit(c);\n        case 103 /* 'g'.charCodeAt(0) */: return  isgraph(c);\n        case 71  /* 'G'.charCodeAt(0) */: return !isgraph(c);\n        case 108 /* 'l'.charCodeAt(0) */: return  islower(c);\n        case 76  /* 'L'.charCodeAt(0) */: return !islower(c);\n        case 112 /* 'p'.charCodeAt(0) */: return  ispunct(c);\n        case 80  /* 'P'.charCodeAt(0) */: return !ispunct(c);\n        case 115 /* 's'.charCodeAt(0) */: return  isspace(c);\n        case 83  /* 'S'.charCodeAt(0) */: return !isspace(c);\n        case 117 /* 'u'.charCodeAt(0) */: return  isupper(c);\n        case 85  /* 'U'.charCodeAt(0) */: return !isupper(c);\n        case 119 /* 'w'.charCodeAt(0) */: return  isalnum(c);\n        case 87  /* 'W'.charCodeAt(0) */: return !isalnum(c);\n        case 120 /* 'x'.charCodeAt(0) */: return  isxdigit(c);\n        case 88  /* 'X'.charCodeAt(0) */: return !isxdigit(c);\n        case 122 /* 'z'.charCodeAt(0) */: return (c === 0);  /* deprecated option */\n        case 90  /* 'z'.charCodeAt(0) */: return (c !== 0);  /* deprecated option */\n        default: return (cl === c);\n    }\n};\n\nconst matchbracketclass = function(ms, c, p, ec) {\n    let sig = true;\n    if (ms.p[p + 1] === 94 /* '^'.charCodeAt(0) */) {\n        sig = false;\n        p++;  /* skip the '^' */\n    }\n    while (++p < ec) {\n        if (ms.p[p] === L_ESC) {\n            p++;\n            if (match_class(c, ms.p[p]))\n                return sig;\n        } else if (ms.p[p + 1] === 45 /* '-'.charCodeAt(0) */ && p + 2 < ec) {\n            p += 2;\n            if (ms.p[p - 2] <= c && c <= ms.p[p])\n                return sig;\n        } else if (ms.p[p] === c) return sig;\n    }\n    return !sig;\n};\n\nconst singlematch = function(ms, s, p, ep) {\n    if (s >= ms.src_end)\n        return false;\n    else {\n        let c = ms.src[s];\n        switch (ms.p[p]) {\n            case 46 /* '.'.charCodeAt(0) */: return true;  /* matches any char */\n            case L_ESC: return match_class(c, ms.p[p + 1]);\n            case 91 /* '['.charCodeAt(0) */: return matchbracketclass(ms, c, p, ep - 1);\n            default: return ms.p[p] === c;\n        }\n    }\n};\n\nconst matchbalance = function(ms, s, p) {\n    if (p >= ms.p_end - 1)\n        luaL_error(ms.L, to_luastring(\"malformed pattern (missing arguments to '%%b'\"));\n    if (ms.src[s] !== ms.p[p])\n        return null;\n    else {\n        let b = ms.p[p];\n        let e = ms.p[p + 1];\n        let cont = 1;\n        while (++s < ms.src_end) {\n            if (ms.src[s] === e) {\n                if (--cont === 0) return s + 1;\n            }\n            else if (ms.src[s] === b) cont++;\n        }\n    }\n    return null;  /* string ends out of balance */\n};\n\nconst max_expand = function(ms, s, p, ep) {\n    let i = 0;  /* counts maximum expand for item */\n    while (singlematch(ms, s + i, p, ep))\n        i++;\n    /* keeps trying to match with the maximum repetitions */\n    while (i >= 0) {\n        let res = match(ms, s + i, ep + 1);\n        if (res) return res;\n        i--;  /* else didn't match; reduce 1 repetition to try again */\n    }\n    return null;\n};\n\nconst min_expand = function(ms, s, p, ep) {\n    for (;;) {\n        let res = match(ms, s, ep + 1);\n        if (res !== null)\n            return res;\n        else if (singlematch(ms, s, p, ep))\n            s++;  /* try with one more repetition */\n        else return null;\n    }\n};\n\nconst start_capture = function(ms, s, p, what) {\n    let level = ms.level;\n    if (level >= LUA_MAXCAPTURES) luaL_error(ms.L, to_luastring(\"too many captures\"));\n    ms.capture[level] = ms.capture[level] ? ms.capture[level] : {};\n    ms.capture[level].init = s;\n    ms.capture[level].len = what;\n    ms.level = level + 1;\n    let res;\n    if ((res = match(ms, s, p)) === null)  /* match failed? */\n        ms.level--;  /* undo capture */\n    return res;\n};\n\nconst end_capture = function(ms, s, p) {\n    let l = capture_to_close(ms);\n    ms.capture[l].len = s - ms.capture[l].init;  /* close capture */\n    let res;\n    if ((res = match(ms, s, p)) === null)  /* match failed? */\n        ms.capture[l].len = CAP_UNFINISHED;  /* undo capture */\n    return res;\n};\n\n/* Compare the elements of arrays 'a' and 'b' to see if they contain the same elements */\nconst array_cmp = function(a, ai, b, bi, len) {\n    return luastring_eq(a.subarray(ai, ai+len), b.subarray(bi, bi+len));\n};\n\nconst match_capture = function(ms, s, l) {\n    l = check_capture(ms, l);\n    let len = ms.capture[l].len;\n    if ((ms.src_end-s) >= len && array_cmp(ms.src, ms.capture[l].init, ms.src, s, len))\n        return s+len;\n    else return null;\n};\n\nconst match = function(ms, s, p) {\n    let gotodefault = false;\n    let gotoinit = true;\n\n    if (ms.matchdepth-- === 0)\n        luaL_error(ms.L, to_luastring(\"pattern too complex\"));\n\n    while (gotoinit || gotodefault) {\n        gotoinit = false;\n        if (p !== ms.p_end) {  /* end of pattern? */\n            switch (gotodefault ? void 0 : ms.p[p]) {\n                case 40 /* '('.charCodeAt(0) */: {  /* start capture */\n                    if (ms.p[p + 1] === 41 /* ')'.charCodeAt(0) */)  /* position capture? */\n                        s = start_capture(ms, s, p + 2, CAP_POSITION);\n                    else\n                        s = start_capture(ms, s, p + 1, CAP_UNFINISHED);\n                    break;\n                }\n                case 41 /* ')'.charCodeAt(0) */: {  /* end capture */\n                    s = end_capture(ms, s, p + 1);\n                    break;\n                }\n                case 36 /* '$'.charCodeAt(0) */: {\n                    if (p + 1 !== ms.p_end) {  /* is the '$' the last char in pattern? */\n                        gotodefault = true;  /* no; go to default */\n                        break;\n                    }\n                    s = (ms.src.length - s) === 0 ? s : null;  /* check end of string */\n                    break;\n                }\n                case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */\n                    switch (ms.p[p + 1]) {\n                        case 98 /* 'b'.charCodeAt(0) */: {  /* balanced string? */\n                            s = matchbalance(ms, s, p + 2);\n                            if (s !== null) {\n                                p += 4;\n                                gotoinit = true;\n                            }\n                            break;\n                        }\n                        case 102 /* 'f'.charCodeAt(0) */: {  /* frontier? */\n                            p += 2;\n                            if (ms.p[p] !== 91 /* '['.charCodeAt(0) */)\n                                luaL_error(ms.L, to_luastring(\"missing '[' after '%%f' in pattern\"));\n                            let ep = classend(ms, p);  /* points to what is next */\n                            let previous = s === ms.src_init ? 0 : ms.src[s-1];\n                            if (!matchbracketclass(ms, previous, p, ep - 1) && matchbracketclass(ms, (s===ms.src_end)?0:ms.src[s], p, ep - 1)) {\n                                p = ep; gotoinit = true; break;\n                            }\n                            s = null;  /* match failed */\n                            break;\n                        }\n                        case 48: case 49: case 50: case 51: case 52:\n                        case 53: case 54: case 55: case 56: case 57: {  /* capture results (%0-%9)? */\n                            s = match_capture(ms, s, ms.p[p + 1]);\n                            if (s !== null) {\n                                p += 2; gotoinit = true;\n                            }\n                            break;\n                        }\n                        default: gotodefault = true;\n                    }\n                    break;\n                }\n                default: {  /* pattern class plus optional suffix */\n                    gotodefault = false;\n                    let ep = classend(ms, p);  /* points to optional suffix */\n                    /* does not match at least once? */\n                    if (!singlematch(ms, s, p, ep)) {\n                        if (ms.p[ep] === 42 /* '*'.charCodeAt(0) */ ||\n                            ms.p[ep] === 63 /* '?'.charCodeAt(0) */ ||\n                            ms.p[ep] === 45 /* '-'.charCodeAt(0) */\n                        ) {  /* accept empty? */\n                            p = ep + 1; gotoinit = true; break;\n                        } else  /* '+' or no suffix */\n                            s = null;  /* fail */\n                    } else {  /* matched once */\n                        switch (ms.p[ep]) {  /* handle optional suffix */\n                            case 63 /* '?'.charCodeAt(0) */: {  /* optional */\n                                let res;\n                                if ((res = match(ms, s + 1, ep + 1)) !== null)\n                                    s = res;\n                                else {\n                                    p = ep + 1; gotoinit = true;\n                                }\n                                break;\n                            }\n                            case 43 /* '+'.charCodeAt(0) */:  /* 1 or more repetitions */\n                                s++;  /* 1 match already done */\n                                /* fall through */\n                            case 42 /* '*'.charCodeAt(0) */:  /* 0 or more repetitions */\n                                s = max_expand(ms, s, p, ep);\n                                break;\n                            case 45 /* '-'.charCodeAt(0) */:  /* 0 or more repetitions (minimum) */\n                                s = min_expand(ms, s, p, ep);\n                                break;\n                            default:  /* no suffix */\n                                s++; p = ep; gotoinit = true;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    ms.matchdepth++;\n    return s;\n};\n\nconst push_onecapture = function(ms, i, s, e) {\n    if (i >= ms.level) {\n        if (i === 0)\n            lua_pushlstring(ms.L, ms.src.subarray(s, e), e - s);  /* add whole match */\n        else\n            luaL_error(ms.L, to_luastring(\"invalid capture index %%%d\"), i + 1);\n    } else {\n        let l = ms.capture[i].len;\n        if (l === CAP_UNFINISHED) luaL_error(ms.L, to_luastring(\"unfinished capture\"));\n        if (l === CAP_POSITION)\n            lua_pushinteger(ms.L, ms.capture[i].init - ms.src_init + 1);\n        else\n            lua_pushlstring(ms.L, ms.src.subarray(ms.capture[i].init), l);\n    }\n};\n\nconst push_captures = function(ms, s, e) {\n    let nlevels = ms.level === 0 && ms.src.subarray(s) ? 1 : ms.level;\n    luaL_checkstack(ms.L, nlevels, \"too many captures\");\n    for (let i = 0; i < nlevels; i++)\n        push_onecapture(ms, i, s, e);\n    return nlevels;  /* number of strings pushed */\n};\n\nconst nospecials = function(p, l) {\n    for (let i=0; i<l; i++) {\n        if (luastring_indexOf(SPECIALS, p[i]) !== -1)\n            return false;\n    }\n    return true;\n};\n\nconst prepstate = function(ms, L, s, ls, p, lp) {\n    ms.L = L;\n    ms.matchdepth = MAXCCALLS;\n    ms.src = s;\n    ms.src_init = 0;\n    ms.src_end = ls;\n    ms.p = p;\n    ms.p_end = lp;\n};\n\nconst reprepstate = function(ms) {\n    ms.level = 0;\n    lualib.lua_assert(ms.matchdepth === MAXCCALLS);\n};\n\nconst find_subarray = function(arr, subarr, from_index) {\n    var i = from_index >>> 0,\n        sl = subarr.length;\n\n    if (sl === 0)\n        return i;\n\n    for (; (i = arr.indexOf(subarr[0], i)) !== -1; i++) {\n        if (luastring_eq(arr.subarray(i, i+sl), subarr))\n            return i;\n    }\n\n    return -1;\n};\n\nconst str_find_aux = function(L, find) {\n    let s = luaL_checkstring(L, 1);\n    let p = luaL_checkstring(L, 2);\n    let ls = s.length;\n    let lp = p.length;\n    let init = posrelat(luaL_optinteger(L, 3, 1), ls);\n    if (init < 1) init = 1;\n    else if (init > ls + 1) {  /* start after string's end? */\n        lua_pushnil(L);  /* cannot find anything */\n        return 1;\n    }\n    /* explicit request or no special characters? */\n    if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {\n        /* do a plain search */\n        let f = find_subarray(s.subarray(init - 1), p, 0);\n        if (f > -1) {\n            lua_pushinteger(L, init + f);\n            lua_pushinteger(L, init + f + lp - 1);\n            return 2;\n        }\n    } else {\n        let ms = new MatchState(L);\n        let s1 = init - 1;\n        let anchor = p[0] === 94 /* '^'.charCodeAt(0) */;\n        if (anchor) {\n            p = p.subarray(1); lp--;  /* skip anchor character */\n        }\n        prepstate(ms, L, s, ls, p, lp);\n        do {\n            let res;\n            reprepstate(ms);\n            if ((res = match(ms, s1, 0)) !== null) {\n                if (find) {\n                    lua_pushinteger(L, s1 + 1);  /* start */\n                    lua_pushinteger(L, res);   /* end */\n                    return push_captures(ms, null, 0) + 2;\n                } else\n                    return push_captures(ms, s1, res);\n            }\n        } while (s1++ < ms.src_end && !anchor);\n    }\n    lua_pushnil(L);  /* not found */\n    return 1;\n};\n\nconst str_find = function(L) {\n    return str_find_aux(L, 1);\n};\n\nconst str_match = function(L) {\n    return str_find_aux(L, 0);\n};\n\n/* state for 'gmatch' */\nclass GMatchState {\n    constructor() {\n        this.src = NaN;  /* current position */\n        this.p = NaN;  /* pattern */\n        this.lastmatch = NaN;  /* end of last match */\n        this.ms = new MatchState();  /* match state */\n    }\n}\n\nconst gmatch_aux = function(L) {\n    let gm = lua_touserdata(L, lua_upvalueindex(3));\n    gm.ms.L = L;\n    for (let src = gm.src; src <= gm.ms.src_end; src++) {\n        reprepstate(gm.ms);\n        let e;\n        if ((e = match(gm.ms, src, gm.p)) !== null && e !== gm.lastmatch) {\n            gm.src = gm.lastmatch = e;\n            return push_captures(gm.ms, src, e);\n        }\n    }\n    return 0;  /* not found */\n};\n\nconst str_gmatch = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let p = luaL_checkstring(L, 2);\n    let ls = s.length;\n    let lp = p.length;\n    lua_settop(L, 2);  /* keep them on closure to avoid being collected */\n    let gm = new GMatchState();\n    lua_pushlightuserdata(L, gm);\n    prepstate(gm.ms, L, s, ls, p, lp);\n    gm.src = 0;\n    gm.p = 0;\n    gm.lastmatch = null;\n    lua_pushcclosure(L, gmatch_aux, 3);\n    return 1;\n};\n\nconst add_s = function(ms, b, s, e) {\n    let L = ms.L;\n    let news = lua_tostring(L, 3);\n    let l = news.length;\n    for (let i = 0; i < l; i++) {\n        if (news[i] !== L_ESC)\n            luaL_addchar(b, news[i]);\n        else {\n            i++;  /* skip ESC */\n            if (!isdigit(news[i])) {\n                if (news[i] !== L_ESC)\n                    luaL_error(L, to_luastring(\"invalid use of '%c' in replacement string\"), L_ESC);\n                luaL_addchar(b, news[i]);\n            } else if (news[i] === 48 /* '0'.charCodeAt(0) */)\n                luaL_addlstring(b, ms.src.subarray(s, e), e - s);\n            else {\n                push_onecapture(ms, news[i] - 49 /* '1'.charCodeAt(0) */, s, e);\n                luaL_tolstring(L, -1);\n                lua_remove(L, -2);  /* remove original value */\n                luaL_addvalue(b);  /* add capture to accumulated result */\n            }\n        }\n    }\n};\n\nconst add_value = function(ms, b, s, e, tr) {\n    let L = ms.L;\n    switch (tr) {\n        case LUA_TFUNCTION: {\n            lua_pushvalue(L, 3);\n            let n = push_captures(ms, s, e);\n            lua_call(L, n, 1);\n            break;\n        }\n        case LUA_TTABLE: {\n            push_onecapture(ms, 0, s, e);\n            lua_gettable(L, 3);\n            break;\n        }\n        default: {  /* LUA_TNUMBER or LUA_TSTRING */\n            add_s(ms, b, s, e);\n            return;\n        }\n    }\n    if (!lua_toboolean(L, -1)) {  /* nil or false? */\n        lua_pop(L, 1);\n        lua_pushlstring(L, ms.src.subarray(s, e), e - s);  /* keep original text */\n    } else if (!lua_isstring(L, -1))\n        luaL_error(L, to_luastring(\"invalid replacement value (a %s)\"), luaL_typename(L, -1));\n    luaL_addvalue(b);  /* add result to accumulator */\n};\n\nconst str_gsub = function(L) {\n    let src = luaL_checkstring(L, 1);  /* subject */\n    let srcl = src.length;\n    let p = luaL_checkstring(L, 2);  /* pattern */\n    let lp = p.length;\n    let lastmatch = null;  /* end of last match */\n    let tr = lua_type(L, 3);  /* replacement type */\n    let max_s = luaL_optinteger(L, 4, srcl + 1);  /* max replacements */\n    let anchor = p[0] === 94 /* '^'.charCodeAt(0) */;\n    let n = 0;  /* replacement count */\n    let ms = new MatchState(L);\n    let b = new luaL_Buffer();\n    luaL_argcheck(L, tr === LUA_TNUMBER || tr === LUA_TSTRING || tr === LUA_TFUNCTION || tr === LUA_TTABLE, 3,\n        \"string/function/table expected\");\n    luaL_buffinit(L, b);\n    if (anchor) {\n        p = p.subarray(1); lp--;  /* skip anchor character */\n    }\n    prepstate(ms, L, src, srcl, p, lp);\n    src = 0; p = 0;\n    while (n < max_s) {\n        let e;\n        reprepstate(ms);\n        if ((e = match(ms, src, p)) !== null && e !== lastmatch) {  /* match? */\n            n++;\n            add_value(ms, b, src, e, tr);  /* add replacement to buffer */\n            src = lastmatch = e;\n        } else if (src < ms.src_end)  /* otherwise, skip one character */\n            luaL_addchar(b, ms.src[src++]);\n        else break;  /* end of subject */\n        if (anchor) break;\n    }\n    luaL_addlstring(b, ms.src.subarray(src, ms.src_end), ms.src_end - src);\n    luaL_pushresult(b);\n    lua_pushinteger(L, n);  /* number of substitutions */\n    return 2;\n};\n\nconst strlib = {\n    \"byte\":     str_byte,\n    \"char\":     str_char,\n    \"dump\":     str_dump,\n    \"find\":     str_find,\n    \"format\":   str_format,\n    \"gmatch\":   str_gmatch,\n    \"gsub\":     str_gsub,\n    \"len\":      str_len,\n    \"lower\":    str_lower,\n    \"match\":    str_match,\n    \"pack\":     str_pack,\n    \"packsize\": str_packsize,\n    \"rep\":      str_rep,\n    \"reverse\":  str_reverse,\n    \"sub\":      str_sub,\n    \"unpack\":   str_unpack,\n    \"upper\":    str_upper\n};\n\nconst createmetatable = function(L) {\n    lua_createtable(L, 0, 1);  /* table to be metatable for strings */\n    lua_pushliteral(L, \"\");  /* dummy string */\n    lua_pushvalue(L, -2);  /* copy table */\n    lua_setmetatable(L, -2);  /* set table as metatable for strings */\n    lua_pop(L, 1);  /* pop dummy string */\n    lua_pushvalue(L, -2);  /* get string library */\n    lua_setfield(L, -2, to_luastring(\"__index\", true));  /* metatable.__index = string */\n    lua_pop(L, 1);  /* pop metatable */\n};\n\nconst luaopen_string = function(L) {\n    luaL_newlib(L, strlib);\n    createmetatable(L);\n    return 1;\n};\n\nmodule.exports.luaopen_string = luaopen_string;\n","\"use strict\";\n\nconst {\n    lua_gettop,\n    lua_pushcfunction,\n    lua_pushfstring,\n    lua_pushinteger,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_setfield,\n    lua_tointeger\n} = require('./lua.js');\nconst {\n    luaL_Buffer,\n    luaL_addvalue,\n    luaL_argcheck,\n    luaL_buffinit,\n    luaL_checkinteger,\n    luaL_checkstack,\n    luaL_checkstring,\n    luaL_error,\n    luaL_newlib,\n    luaL_optinteger,\n    luaL_pushresult\n} = require('./lauxlib.js');\nconst {\n    luastring_of,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\nconst MAXUNICODE = 0x10FFFF;\n\nconst iscont = function(p) {\n    let c = p & 0xC0;\n    return c === 0x80;\n};\n\n/* translate a relative string position: negative means back from end */\nconst u_posrelat = function(pos, len) {\n    if (pos >= 0) return pos;\n    else if (0 - pos > len) return 0;\n    else return len + pos + 1;\n};\n\n/*\n** Decode one UTF-8 sequence, returning NULL if byte sequence is invalid.\n*/\nconst limits = [0xFF, 0x7F, 0x7FF, 0xFFFF];\nconst utf8_decode = function(s, pos) {\n    let c = s[pos];\n    let res = 0;  /* final result */\n    if (c < 0x80)  /* ascii? */\n        res = c;\n    else {\n        let count = 0;  /* to count number of continuation bytes */\n        while (c & 0x40) {  /* still have continuation bytes? */\n            let cc = s[pos + (++count)];  /* read next byte */\n            if ((cc & 0xC0) !== 0x80)  /* not a continuation byte? */\n                return null;  /* invalid byte sequence */\n            res = (res << 6) | (cc & 0x3F);  /* add lower 6 bits from cont. byte */\n            c <<= 1;  /* to test next bit */\n        }\n        res |= ((c & 0x7F) << (count * 5));  /* add first byte */\n        if (count > 3 || res > MAXUNICODE || res <= limits[count])\n            return null;  /* invalid byte sequence */\n        pos += count;  /* skip continuation bytes read */\n    }\n\n    return {\n        code: res,\n        pos: pos + 1\n    };\n};\n\n/*\n** utf8len(s [, i [, j]]) --> number of characters that start in the\n** range [i,j], or nil + current position if 's' is not well formed in\n** that interval\n*/\nconst utflen = function(L) {\n    let n = 0;\n    let s = luaL_checkstring(L, 1);\n    let len = s.length;\n    let posi = u_posrelat(luaL_optinteger(L, 2, 1), len);\n    let posj = u_posrelat(luaL_optinteger(L, 3, -1), len);\n\n    luaL_argcheck(L, 1 <= posi && --posi <= len, 2, \"initial position out of string\");\n    luaL_argcheck(L, --posj < len, 3, \"final position out of string\");\n\n    while (posi <= posj) {\n        let dec = utf8_decode(s, posi);\n        if (dec === null) { /* conversion error? */\n            lua_pushnil(L);  /* return nil ... */\n            lua_pushinteger(L, posi + 1);  /* ... and current position */\n            return 2;\n        }\n        posi = dec.pos;\n        n++;\n    }\n    lua_pushinteger(L, n);\n    return 1;\n};\n\nconst p_U = to_luastring(\"%U\");\nconst pushutfchar = function(L, arg) {\n    let code = luaL_checkinteger(L, arg);\n    luaL_argcheck(L, 0 <= code && code <= MAXUNICODE, arg, \"value out of range\");\n    lua_pushfstring(L, p_U, code);\n};\n\n/*\n** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...\n*/\nconst utfchar = function(L) {\n    let n = lua_gettop(L);  /* number of arguments */\n    if (n === 1)  /* optimize common case of single char */\n        pushutfchar(L, 1);\n    else {\n        let b = new luaL_Buffer();\n        luaL_buffinit(L, b);\n        for (let i = 1; i <= n; i++) {\n            pushutfchar(L, i);\n            luaL_addvalue(b);\n        }\n        luaL_pushresult(b);\n    }\n    return 1;\n};\n\n/*\n** offset(s, n, [i])  -> index where n-th character counting from\n**   position 'i' starts; 0 means character at 'i'.\n*/\nconst byteoffset = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let n = luaL_checkinteger(L, 2);\n    let posi = n >= 0 ? 1 : s.length + 1;\n    posi = u_posrelat(luaL_optinteger(L, 3, posi), s.length);\n\n    luaL_argcheck(L, 1 <= posi && --posi <= s.length, 3, \"position out of range\");\n\n    if (n === 0) {\n        /* find beginning of current byte sequence */\n        while (posi > 0 && iscont(s[posi])) posi--;\n    } else {\n        if (iscont(s[posi]))\n            luaL_error(L, \"initial position is a continuation byte\");\n\n        if (n < 0) {\n            while (n < 0 && posi > 0) {  /* move back */\n                do {  /* find beginning of previous character */\n                    posi--;\n                } while (posi > 0 && iscont(s[posi]));\n                n++;\n            }\n        } else {\n            n--;  /* do not move for 1st character */\n            while (n > 0 && posi < s.length) {\n                do {  /* find beginning of next character */\n                    posi++;\n                } while (iscont(s[posi]));  /* (cannot pass final '\\0') */\n                n--;\n            }\n        }\n    }\n\n    if (n === 0)  /* did it find given character? */\n        lua_pushinteger(L, posi + 1);\n    else  /* no such character */\n        lua_pushnil(L);\n\n    return 1;\n};\n\n/*\n** codepoint(s, [i, [j]])  -> returns codepoints for all characters\n** that start in the range [i,j]\n*/\nconst codepoint = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let posi = u_posrelat(luaL_optinteger(L, 2, 1), s.length);\n    let pose = u_posrelat(luaL_optinteger(L, 3, posi), s.length);\n\n    luaL_argcheck(L, posi >= 1, 2, \"out of range\");\n    luaL_argcheck(L, pose <= s.length, 3, \"out of range\");\n\n    if (posi > pose) return 0;  /* empty interval; return no values */\n    if (pose - posi >= Number.MAX_SAFE_INTEGER)\n        return luaL_error(L, \"string slice too long\");\n    let n = (pose - posi) + 1;\n    luaL_checkstack(L, n, \"string slice too long\");\n    n = 0;\n    for (posi -= 1; posi < pose;) {\n        let dec = utf8_decode(s, posi);\n        if (dec === null)\n            return luaL_error(L, \"invalid UTF-8 code\");\n        lua_pushinteger(L, dec.code);\n        posi = dec.pos;\n        n++;\n    }\n    return n;\n};\n\nconst iter_aux = function(L) {\n    let s = luaL_checkstring(L, 1);\n    let len = s.length;\n    let n = lua_tointeger(L, 2) - 1;\n\n    if (n < 0)  /* first iteration? */\n        n = 0;  /* start from here */\n    else if (n < len) {\n        n++;  /* skip current byte */\n        while (iscont(s[n])) n++;  /* and its continuations */\n    }\n\n    if (n >= len)\n        return 0;  /* no more codepoints */\n    else {\n        let dec = utf8_decode(s, n);\n        if (dec === null || iscont(s[dec.pos]))\n            return luaL_error(L, to_luastring(\"invalid UTF-8 code\"));\n        lua_pushinteger(L, n + 1);\n        lua_pushinteger(L, dec.code);\n        return 2;\n    }\n};\n\nconst iter_codes = function(L) {\n    luaL_checkstring(L, 1);\n    lua_pushcfunction(L, iter_aux);\n    lua_pushvalue(L, 1);\n    lua_pushinteger(L, 0);\n    return 3;\n};\n\nconst funcs = {\n    \"char\":      utfchar,\n    \"codepoint\": codepoint,\n    \"codes\":     iter_codes,\n    \"len\":       utflen,\n    \"offset\":    byteoffset\n};\n\n/* pattern to match a single UTF-8 character */\nconst UTF8PATT = luastring_of(91, 0, 45, 127, 194, 45, 244, 93, 91, 128, 45, 191, 93, 42);\n\nconst luaopen_utf8 = function(L) {\n    luaL_newlib(L, funcs);\n    lua_pushstring(L, UTF8PATT);\n    lua_setfield(L, -2, to_luastring(\"charpattern\", true));\n    return 1;\n};\n\nmodule.exports.luaopen_utf8 = luaopen_utf8;\n","\"use strict\";\n\nconst {\n    LUA_OPLT,\n    LUA_TNUMBER,\n    lua_compare,\n    lua_gettop,\n    lua_isinteger,\n    lua_isnoneornil,\n    lua_pushboolean,\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_pushnil,\n    lua_pushnumber,\n    lua_pushvalue,\n    lua_setfield,\n    lua_settop,\n    lua_tointeger,\n    lua_tointegerx,\n    lua_type\n} = require('./lua.js');\nconst {\n    luaL_argcheck,\n    luaL_argerror,\n    luaL_checkany,\n    luaL_checkinteger,\n    luaL_checknumber,\n    luaL_error,\n    luaL_newlib,\n    luaL_optnumber\n} = require('./lauxlib.js');\nconst {\n    LUA_MAXINTEGER,\n    LUA_MININTEGER,\n    lua_numbertointeger\n} = require('./luaconf.js');\nconst { to_luastring } = require(\"./fengaricore.js\");\n\nlet rand_state;\n/* use same parameters as glibc LCG */\nconst l_rand = function() {\n    rand_state = (1103515245 * rand_state + 12345) & 0x7fffffff;\n    return rand_state;\n};\nconst l_srand = function(x) {\n    rand_state = x|0;\n    if (rand_state === 0)\n        rand_state = 1;\n};\n\nconst math_random = function(L) {\n    let low, up;\n    /* use Math.random until randomseed is called */\n    let r = (rand_state === void 0)?Math.random():(l_rand() / 0x80000000);\n    switch (lua_gettop(L)) {  /* check number of arguments */\n        case 0:\n            lua_pushnumber(L, r);  /* Number between 0 and 1 */\n            return 1;\n        case 1: {\n            low = 1;\n            up = luaL_checkinteger(L, 1);\n            break;\n        }\n        case 2: {\n            low = luaL_checkinteger(L, 1);\n            up = luaL_checkinteger(L, 2);\n            break;\n        }\n        default: return luaL_error(L, \"wrong number of arguments\");\n    }\n\n    /* random integer in the interval [low, up] */\n    luaL_argcheck(L, low <= up, 1, \"interval is empty\");\n    luaL_argcheck(L, low >= 0 || up <= LUA_MAXINTEGER + low, 1,\n        \"interval too large\");\n\n    r *= (up - low) + 1;\n    lua_pushinteger(L, Math.floor(r) + low);\n    return 1;\n};\n\nconst math_randomseed = function(L) {\n    l_srand(luaL_checknumber(L, 1));\n    l_rand(); /* discard first value to avoid undesirable correlations */\n    return 0;\n};\n\nconst math_abs = function(L) {\n    if (lua_isinteger(L, 1)) {\n        let n = lua_tointeger(L, 1);\n        if (n < 0) n = (-n)|0;\n        lua_pushinteger(L, n);\n    }\n    else\n        lua_pushnumber(L, Math.abs(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_sin = function(L) {\n    lua_pushnumber(L, Math.sin(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_cos = function(L) {\n    lua_pushnumber(L, Math.cos(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_tan = function(L) {\n    lua_pushnumber(L, Math.tan(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_asin = function(L) {\n    lua_pushnumber(L, Math.asin(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_acos = function(L) {\n    lua_pushnumber(L, Math.acos(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_atan = function(L) {\n    let y = luaL_checknumber(L, 1);\n    let x = luaL_optnumber(L, 2, 1);\n    lua_pushnumber(L, Math.atan2(y, x));\n    return 1;\n};\n\nconst math_toint = function(L) {\n    let n = lua_tointegerx(L, 1);\n    if (n !== false)\n        lua_pushinteger(L, n);\n    else {\n        luaL_checkany(L, 1);\n        lua_pushnil(L);  /* value is not convertible to integer */\n    }\n    return 1;\n};\n\nconst pushnumint = function(L, d) {\n    let n = lua_numbertointeger(d);\n    if (n !== false)  /* does 'd' fit in an integer? */\n        lua_pushinteger(L, n);  /* result is integer */\n    else\n        lua_pushnumber(L, d);  /* result is float */\n};\n\nconst math_floor = function(L) {\n    if (lua_isinteger(L, 1))\n        lua_settop(L, 1);\n    else\n        pushnumint(L, Math.floor(luaL_checknumber(L, 1)));\n\n    return 1;\n};\n\nconst math_ceil = function(L) {\n    if (lua_isinteger(L, 1))\n        lua_settop(L, 1);\n    else\n        pushnumint(L, Math.ceil(luaL_checknumber(L, 1)));\n\n    return 1;\n};\n\nconst math_sqrt = function(L) {\n    lua_pushnumber(L, Math.sqrt(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_ult = function(L) {\n    let a = luaL_checkinteger(L, 1);\n    let b = luaL_checkinteger(L, 2);\n    lua_pushboolean(L, (a >= 0)?(b<0 || a<b):(b<0 && a<b));\n    return 1;\n};\n\nconst math_log = function(L) {\n    let x = luaL_checknumber(L, 1);\n    let res;\n    if (lua_isnoneornil(L, 2))\n        res = Math.log(x);\n    else {\n        let base = luaL_checknumber(L, 2);\n        if (base === 2)\n            res = Math.log2(x);\n        else if (base === 10)\n            res = Math.log10(x);\n        else\n            res = Math.log(x)/Math.log(base);\n    }\n    lua_pushnumber(L, res);\n    return 1;\n};\n\nconst math_exp = function(L) {\n    lua_pushnumber(L, Math.exp(luaL_checknumber(L, 1)));\n    return 1;\n};\n\nconst math_deg = function(L) {\n    lua_pushnumber(L, luaL_checknumber(L, 1) * (180 / Math.PI));\n    return 1;\n};\n\nconst math_rad = function(L) {\n    lua_pushnumber(L, luaL_checknumber(L, 1) * (Math.PI / 180));\n    return 1;\n};\n\nconst math_min = function(L) {\n    let n = lua_gettop(L);  /* number of arguments */\n    let imin = 1;  /* index of current minimum value */\n    luaL_argcheck(L, n >= 1, 1, \"value expected\");\n    for (let i = 2; i <= n; i++){\n        if (lua_compare(L, i, imin, LUA_OPLT))\n            imin = i;\n    }\n    lua_pushvalue(L, imin);\n    return 1;\n};\n\nconst math_max = function(L) {\n    let n = lua_gettop(L);  /* number of arguments */\n    let imax = 1;  /* index of current minimum value */\n    luaL_argcheck(L, n >= 1, 1, \"value expected\");\n    for (let i = 2; i <= n; i++){\n        if (lua_compare(L, imax, i, LUA_OPLT))\n            imax = i;\n    }\n    lua_pushvalue(L, imax);\n    return 1;\n};\n\nconst math_type = function(L) {\n    if (lua_type(L, 1) === LUA_TNUMBER) {\n        if (lua_isinteger(L, 1))\n            lua_pushliteral(L, \"integer\");\n        else\n            lua_pushliteral(L, \"float\");\n    } else {\n        luaL_checkany(L, 1);\n        lua_pushnil(L);\n    }\n    return 1;\n};\n\nconst math_fmod = function(L) {\n    if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {\n        let d = lua_tointeger(L, 2);\n        /* no special case needed for -1 in javascript */\n        if (d === 0) {\n            luaL_argerror(L, 2, \"zero\");\n        } else\n            lua_pushinteger(L, (lua_tointeger(L, 1) % d)|0);\n    } else {\n        let a = luaL_checknumber(L, 1);\n        let b = luaL_checknumber(L, 2);\n        lua_pushnumber(L, a%b);\n    }\n    return 1;\n};\n\nconst math_modf = function(L) {\n    if (lua_isinteger(L, 1)) {\n        lua_settop(L, 1);  /* number is its own integer part */\n        lua_pushnumber(L, 0);  /* no fractional part */\n    } else {\n        let n = luaL_checknumber(L, 1);\n        let ip = n < 0 ? Math.ceil(n) : Math.floor(n);\n        pushnumint(L, ip);\n        lua_pushnumber(L, n === ip ? 0 : n - ip);\n    }\n    return 2;\n};\n\nconst mathlib = {\n    \"abs\":        math_abs,\n    \"acos\":       math_acos,\n    \"asin\":       math_asin,\n    \"atan\":       math_atan,\n    \"ceil\":       math_ceil,\n    \"cos\":        math_cos,\n    \"deg\":        math_deg,\n    \"exp\":        math_exp,\n    \"floor\":      math_floor,\n    \"fmod\":       math_fmod,\n    \"log\":        math_log,\n    \"max\":        math_max,\n    \"min\":        math_min,\n    \"modf\":       math_modf,\n    \"rad\":        math_rad,\n    \"random\":     math_random,\n    \"randomseed\": math_randomseed,\n    \"sin\":        math_sin,\n    \"sqrt\":       math_sqrt,\n    \"tan\":        math_tan,\n    \"tointeger\":  math_toint,\n    \"type\":       math_type,\n    \"ult\":        math_ult\n};\n\nconst luaopen_math = function(L) {\n    luaL_newlib(L, mathlib);\n    lua_pushnumber(L, Math.PI);\n    lua_setfield(L, -2, to_luastring(\"pi\", true));\n    lua_pushnumber(L, Infinity);\n    lua_setfield(L, -2, to_luastring(\"huge\", true));\n    lua_pushinteger(L, LUA_MAXINTEGER);\n    lua_setfield(L, -2, to_luastring(\"maxinteger\", true));\n    lua_pushinteger(L, LUA_MININTEGER);\n    lua_setfield(L, -2, to_luastring(\"mininteger\", true));\n    return 1;\n};\n\nmodule.exports.luaopen_math = luaopen_math;\n","\"use strict\";\n\nconst {\n    LUA_MASKCALL,\n    LUA_MASKCOUNT,\n    LUA_MASKLINE,\n    LUA_MASKRET,\n    LUA_REGISTRYINDEX,\n    LUA_TFUNCTION,\n    LUA_TNIL,\n    LUA_TTABLE,\n    LUA_TUSERDATA,\n    lua_Debug,\n    lua_call,\n    lua_checkstack,\n    lua_gethook,\n    lua_gethookcount,\n    lua_gethookmask,\n    lua_getinfo,\n    lua_getlocal,\n    lua_getmetatable,\n    lua_getstack,\n    lua_getupvalue,\n    lua_getuservalue,\n    lua_insert,\n    lua_iscfunction,\n    lua_isfunction,\n    lua_isnoneornil,\n    lua_isthread,\n    lua_newtable,\n    lua_pcall,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushfstring,\n    lua_pushinteger,\n    lua_pushlightuserdata,\n    lua_pushliteral,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_rawgetp,\n    lua_rawsetp,\n    lua_rotate,\n    lua_setfield,\n    lua_sethook,\n    lua_setlocal,\n    lua_setmetatable,\n    lua_settop,\n    lua_setupvalue,\n    lua_setuservalue,\n    lua_tojsstring,\n    lua_toproxy,\n    lua_tostring,\n    lua_tothread,\n    lua_touserdata,\n    lua_type,\n    lua_upvalueid,\n    lua_upvaluejoin,\n    lua_xmove\n} = require('./lua.js');\nconst {\n    luaL_argcheck,\n    luaL_argerror,\n    luaL_checkany,\n    luaL_checkinteger,\n    luaL_checkstring,\n    luaL_checktype,\n    luaL_error,\n    luaL_loadbuffer,\n    luaL_newlib,\n    luaL_optinteger,\n    luaL_optstring,\n    luaL_traceback,\n    lua_writestringerror\n} = require('./lauxlib.js');\nconst lualib = require('./lualib.js');\nconst {\n    luastring_indexOf,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\n/*\n** If L1 != L, L1 can be in any state, and therefore there are no\n** guarantees about its stack space; any push in L1 must be\n** checked.\n*/\nconst checkstack = function(L, L1, n) {\n    if (L !== L1 && !lua_checkstack(L1, n))\n        luaL_error(L, to_luastring(\"stack overflow\", true));\n};\n\nconst db_getregistry = function(L) {\n    lua_pushvalue(L, LUA_REGISTRYINDEX);\n    return 1;\n};\n\nconst db_getmetatable = function(L) {\n    luaL_checkany(L, 1);\n    if (!lua_getmetatable(L, 1)) {\n        lua_pushnil(L);  /* no metatable */\n    }\n    return 1;\n};\n\nconst db_setmetatable = function(L) {\n    const t = lua_type(L, 2);\n    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2, \"nil or table expected\");\n    lua_settop(L, 2);\n    lua_setmetatable(L, 1);\n    return 1;  /* return 1st argument */\n};\n\nconst db_getuservalue = function(L) {\n    if (lua_type(L, 1) !== LUA_TUSERDATA)\n        lua_pushnil(L);\n    else\n        lua_getuservalue(L, 1);\n    return 1;\n};\n\n\nconst db_setuservalue = function(L) {\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    luaL_checkany(L, 2);\n    lua_settop(L, 2);\n    lua_setuservalue(L, 1);\n    return 1;\n};\n\n/*\n** Auxiliary function used by several library functions: check for\n** an optional thread as function's first argument and set 'arg' with\n** 1 if this argument is present (so that functions can skip it to\n** access their other arguments)\n*/\nconst getthread = function(L) {\n    if (lua_isthread(L, 1)) {\n        return {\n            arg: 1,\n            thread: lua_tothread(L, 1)\n        };\n    } else {\n        return {\n            arg: 0,\n            thread: L\n        };  /* function will operate over current thread */\n    }\n};\n\n/*\n** Variations of 'lua_settable', used by 'db_getinfo' to put results\n** from 'lua_getinfo' into result table. Key is always a string;\n** value can be a string, an int, or a boolean.\n*/\nconst settabss = function(L, k, v) {\n    lua_pushstring(L, v);\n    lua_setfield(L, -2, k);\n};\n\nconst settabsi = function(L, k, v) {\n    lua_pushinteger(L, v);\n    lua_setfield(L, -2, k);\n};\n\nconst settabsb = function(L, k, v) {\n    lua_pushboolean(L, v);\n    lua_setfield(L, -2, k);\n};\n\n\n/*\n** In function 'db_getinfo', the call to 'lua_getinfo' may push\n** results on the stack; later it creates the result table to put\n** these objects. Function 'treatstackoption' puts the result from\n** 'lua_getinfo' on top of the result table so that it can call\n** 'lua_setfield'.\n*/\nconst treatstackoption = function(L, L1, fname) {\n    if (L == L1)\n        lua_rotate(L, -2, 1);  /* exchange object and table */\n    else\n        lua_xmove(L1, L, 1);  /* move object to the \"main\" stack */\n    lua_setfield(L, -2, fname);  /* put object into table */\n};\n\n/*\n** Calls 'lua_getinfo' and collects all results in a new table.\n** L1 needs stack space for an optional input (function) plus\n** two optional outputs (function and line table) from function\n** 'lua_getinfo'.\n*/\nconst db_getinfo = function(L) {\n    let ar = new lua_Debug();\n    let thread = getthread(L);\n    let arg = thread.arg;\n    let L1 = thread.thread;\n    let options = luaL_optstring(L, arg + 2, \"flnStu\");\n    checkstack(L, L1, 3);\n    if (lua_isfunction(L, arg + 1)) {  /* info about a function? */\n        options = lua_pushfstring(L, to_luastring(\">%s\"), options);  /* add '>' to 'options' */\n        lua_pushvalue(L, arg + 1);  /* move function to 'L1' stack */\n        lua_xmove(L, L1, 1);\n    } else {  /* stack level */\n        if (!lua_getstack(L1, luaL_checkinteger(L, arg + 1), ar)) {\n            lua_pushnil(L);  /* level out of range */\n            return 1;\n        }\n    }\n\n    if (!lua_getinfo(L1, options, ar))\n        luaL_argerror(L, arg + 2, \"invalid option\");\n    lua_newtable(L);  /* table to collect results */\n    if (luastring_indexOf(options, 83 /* 'S'.charCodeAt(0) */) > -1) {\n        settabss(L, to_luastring(\"source\", true), ar.source);\n        settabss(L, to_luastring(\"short_src\", true), ar.short_src);\n        settabsi(L, to_luastring(\"linedefined\", true), ar.linedefined);\n        settabsi(L, to_luastring(\"lastlinedefined\", true), ar.lastlinedefined);\n        settabss(L, to_luastring(\"what\", true), ar.what);\n    }\n    if (luastring_indexOf(options, 108 /* 'l'.charCodeAt(0) */) > -1)\n        settabsi(L, to_luastring(\"currentline\", true), ar.currentline);\n    if (luastring_indexOf(options, 117 /* 'u'.charCodeAt(0) */) > -1) {\n        settabsi(L, to_luastring(\"nups\", true), ar.nups);\n        settabsi(L, to_luastring(\"nparams\", true), ar.nparams);\n        settabsb(L, to_luastring(\"isvararg\", true), ar.isvararg);\n    }\n    if (luastring_indexOf(options, 110 /* 'n'.charCodeAt(0) */) > -1) {\n        settabss(L, to_luastring(\"name\", true), ar.name);\n        settabss(L, to_luastring(\"namewhat\", true), ar.namewhat);\n    }\n    if (luastring_indexOf(options, 116 /* 't'.charCodeAt(0) */) > -1)\n        settabsb(L, to_luastring(\"istailcall\", true), ar.istailcall);\n    if (luastring_indexOf(options, 76 /* 'L'.charCodeAt(0) */) > -1)\n        treatstackoption(L, L1, to_luastring(\"activelines\", true));\n    if (luastring_indexOf(options, 102 /* 'f'.charCodeAt(0) */) > -1)\n        treatstackoption(L, L1, to_luastring(\"func\", true));\n    return 1;  /* return table */\n};\n\nconst db_getlocal = function(L) {\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let arg = thread.arg;\n    let ar = new lua_Debug();\n    let nvar = luaL_checkinteger(L, arg + 2);  /* local-variable index */\n    if (lua_isfunction(L, arg + 1)) {\n        lua_pushvalue(L, arg + 1);  /* push function */\n        lua_pushstring(L, lua_getlocal(L, null, nvar));  /* push local name */\n        return 1;  /* return only name (there is no value) */\n    } else {  /* stack-level argument */\n        let level = luaL_checkinteger(L, arg + 1);\n        if (!lua_getstack(L1, level, ar))  /* out of range? */\n            return luaL_argerror(L, arg+1, \"level out of range\");\n        checkstack(L, L1, 1);\n        let name = lua_getlocal(L1, ar, nvar);\n        if (name) {\n            lua_xmove(L1, L, 1);  /* move local value */\n            lua_pushstring(L, name);  /* push name */\n            lua_rotate(L, -2, 1);  /* re-order */\n            return 2;\n        }\n        else {\n            lua_pushnil(L);  /* no name (nor value) */\n            return 1;\n        }\n    }\n};\n\nconst db_setlocal = function(L) {\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let arg = thread.arg;\n    let ar = new lua_Debug();\n    let level = luaL_checkinteger(L, arg + 1);\n    let nvar = luaL_checkinteger(L, arg + 2);\n    if (!lua_getstack(L1, level, ar))  /* out of range? */\n        return luaL_argerror(L, arg + 1, \"level out of range\");\n    luaL_checkany(L, arg + 3);\n    lua_settop(L, arg + 3);\n    checkstack(L, L1, 1);\n    lua_xmove(L, L1, 1);\n    let name = lua_setlocal(L1, ar, nvar);\n    if (name === null)\n        lua_pop(L1, 1);  /* pop value (if not popped by 'lua_setlocal') */\n    lua_pushstring(L, name);\n    return 1;\n};\n\n/*\n** get (if 'get' is true) or set an upvalue from a closure\n*/\nconst auxupvalue = function(L, get) {\n    let n = luaL_checkinteger(L, 2);  /* upvalue index */\n    luaL_checktype(L, 1, LUA_TFUNCTION);  /* closure */\n    let name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);\n    if (name === null) return 0;\n    lua_pushstring(L, name);\n    lua_insert(L, -(get+1));  /* no-op if get is false */\n    return get + 1;\n};\n\n\nconst db_getupvalue = function(L) {\n    return auxupvalue(L, 1);\n};\n\nconst db_setupvalue = function(L) {\n    luaL_checkany(L, 3);\n    return auxupvalue(L, 0);\n};\n\n/*\n** Check whether a given upvalue from a given closure exists and\n** returns its index\n*/\nconst checkupval = function(L, argf, argnup) {\n    let nup = luaL_checkinteger(L, argnup);  /* upvalue index */\n    luaL_checktype(L, argf, LUA_TFUNCTION);  /* closure */\n    luaL_argcheck(L, (lua_getupvalue(L, argf, nup) !== null), argnup, \"invalid upvalue index\");\n    return nup;\n};\n\nconst db_upvalueid = function(L) {\n    let n = checkupval(L, 1, 2);\n    lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));\n    return 1;\n};\n\nconst db_upvaluejoin = function(L) {\n    let n1 = checkupval(L, 1, 2);\n    let n2 = checkupval(L, 3, 4);\n    luaL_argcheck(L, !lua_iscfunction(L, 1), 1, \"Lua function expected\");\n    luaL_argcheck(L, !lua_iscfunction(L, 3), 3, \"Lua function expected\");\n    lua_upvaluejoin(L, 1, n1, 3, n2);\n    return 0;\n};\n\n/*\n** The hook table at registry[HOOKKEY] maps threads to their current\n** hook function. (We only need the unique address of 'HOOKKEY'.)\n*/\nconst HOOKKEY = to_luastring(\"__hooks__\", true);\n\nconst hooknames = [\"call\", \"return\", \"line\", \"count\", \"tail call\"].map(e => to_luastring(e));\n\n/*\n** Call hook function registered at hook table for the current\n** thread (if there is one)\n*/\nconst hookf = function(L, ar) {\n    lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY);\n    let hooktable = lua_touserdata(L, -1);\n    let proxy = hooktable.get(L);\n    if (proxy) {  /* is there a hook function? */\n        proxy(L);\n        lua_pushstring(L, hooknames[ar.event]);  /* push event name */\n        if (ar.currentline >= 0)\n            lua_pushinteger(L, ar.currentline);  /* push current line */\n        else lua_pushnil(L);\n        lualib.lua_assert(lua_getinfo(L, to_luastring(\"lS\"), ar));\n        lua_call(L, 2, 0);  /* call hook function */\n    }\n};\n\n/*\n** Convert a string mask (for 'sethook') into a bit mask\n*/\nconst makemask = function(smask, count) {\n    let mask = 0;\n    if (luastring_indexOf(smask, 99 /* 'c'.charCodeAt(0) */) > -1) mask |= LUA_MASKCALL;\n    if (luastring_indexOf(smask, 114 /* 'r'.charCodeAt(0) */) > -1) mask |= LUA_MASKRET;\n    if (luastring_indexOf(smask, 108 /* 'l'.charCodeAt(0) */) > -1) mask |= LUA_MASKLINE;\n    if (count > 0) mask |= LUA_MASKCOUNT;\n    return mask;\n};\n\n/*\n** Convert a bit mask (for 'gethook') into a string mask\n*/\nconst unmakemask = function(mask, smask) {\n    let i = 0;\n    if (mask & LUA_MASKCALL) smask[i++] = 99 /* 'c'.charCodeAt(0) */;\n    if (mask & LUA_MASKRET) smask[i++] = 114 /* 'r'.charCodeAt(0) */;\n    if (mask & LUA_MASKLINE) smask[i++] = 108 /* 'l'.charCodeAt(0) */;\n    return smask.subarray(0, i);\n};\n\nconst db_sethook = function(L) {\n    let mask, count, func;\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let arg = thread.arg;\n    if (lua_isnoneornil(L, arg+1)) {  /* no hook? */\n        lua_settop(L, arg+1);\n        func = null; mask = 0; count = 0;  /* turn off hooks */\n    }\n    else {\n        const smask = luaL_checkstring(L, arg + 2);\n        luaL_checktype(L, arg+1, LUA_TFUNCTION);\n        count = luaL_optinteger(L, arg + 3, 0);\n        func = hookf; mask = makemask(smask, count);\n    }\n    /* as weak tables are not supported; use a JS weak-map */\n    let hooktable;\n    if (lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY) === LUA_TNIL) {\n        hooktable = new WeakMap();\n        lua_pushlightuserdata(L, hooktable);\n        lua_rawsetp(L, LUA_REGISTRYINDEX, HOOKKEY);  /* set it in position */\n    } else {\n        hooktable = lua_touserdata(L, -1);\n    }\n    let proxy = lua_toproxy(L, arg + 1);  /* value (hook function) */\n    hooktable.set(L1, proxy);\n    lua_sethook(L1, func, mask, count);\n    return 0;\n};\n\nconst db_gethook = function(L) {\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let buff = new Uint8Array(5);\n    let mask = lua_gethookmask(L1);\n    let hook = lua_gethook(L1);\n    if (hook === null)  /* no hook? */\n        lua_pushnil(L);\n    else if (hook !== hookf)  /* external hook? */\n        lua_pushliteral(L, \"external hook\");\n    else {  /* hook table must exist */\n        lua_rawgetp(L, LUA_REGISTRYINDEX, HOOKKEY);\n        let hooktable = lua_touserdata(L, -1);\n        let proxy = hooktable.get(L1);\n        proxy(L);\n    }\n    lua_pushstring(L, unmakemask(mask, buff));  /* 2nd result = mask */\n    lua_pushinteger(L, lua_gethookcount(L1));  /* 3rd result = count */\n    return 3;\n};\n\nconst db_traceback = function(L) {\n    let thread = getthread(L);\n    let L1 = thread.thread;\n    let arg = thread.arg;\n    let msg = lua_tostring(L, arg + 1);\n    if (msg === null && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */\n        lua_pushvalue(L, arg + 1);  /* return it untouched */\n    else {\n        let level = luaL_optinteger(L, arg + 2, L === L1 ? 1 : 0);\n        luaL_traceback(L, L1, msg, level);\n    }\n    return 1;\n};\n\nconst dblib = {\n    \"gethook\":      db_gethook,\n    \"getinfo\":      db_getinfo,\n    \"getlocal\":     db_getlocal,\n    \"getmetatable\": db_getmetatable,\n    \"getregistry\":  db_getregistry,\n    \"getupvalue\":   db_getupvalue,\n    \"getuservalue\": db_getuservalue,\n    \"sethook\":      db_sethook,\n    \"setlocal\":     db_setlocal,\n    \"setmetatable\": db_setmetatable,\n    \"setupvalue\":   db_setupvalue,\n    \"setuservalue\": db_setuservalue,\n    \"traceback\":    db_traceback,\n    \"upvalueid\":    db_upvalueid,\n    \"upvaluejoin\":  db_upvaluejoin\n};\n\nlet getinput;\nif (typeof process !== \"undefined\") { // Only with Node\n    const readlineSync = require('readline-sync');\n    readlineSync.setDefaultOptions({\n        prompt: 'lua_debug> '\n    });\n    getinput = function() {\n        return readlineSync.prompt();\n    };\n} else if (typeof window !== \"undefined\") {\n    /* if in browser use window.prompt. Doesn't work from web workers.\n       See https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt\n    */\n    getinput = function() {\n        let input = prompt(\"lua_debug>\", \"\");\n        return (input !== null) ? input : \"\";\n    };\n}\nif (getinput) {\n    dblib.debug = function(L) {\n        for (;;) {\n            let input = getinput();\n\n            if (input === \"cont\")\n                return 0;\n\n            if (input.length === 0)\n                continue;\n\n            let buffer = to_luastring(input);\n            if (luaL_loadbuffer(L, buffer, buffer.length, to_luastring(\"=(debug command)\", true))\n                || lua_pcall(L, 0, 0, 0)) {\n                lua_writestringerror(lua_tojsstring(L, -1), \"\\n\");\n            }\n            lua_settop(L, 0);  /* remove eventual returns */\n        }\n    };\n}\n\nconst luaopen_debug = function(L) {\n    luaL_newlib(L, dblib);\n    return 1;\n};\n\nmodule.exports.luaopen_debug = luaopen_debug;\n","\"use strict\";\n\nconst {\n    LUA_DIRSEP,\n    LUA_EXEC_DIR,\n    LUA_JSPATH_DEFAULT,\n    LUA_PATH_DEFAULT,\n    LUA_PATH_MARK,\n    LUA_PATH_SEP\n} = require('./luaconf.js');\nconst {\n    LUA_OK,\n    LUA_REGISTRYINDEX,\n    LUA_TNIL,\n    LUA_TTABLE,\n    lua_callk,\n    lua_createtable,\n    lua_getfield,\n    lua_insert,\n    lua_isfunction,\n    lua_isnil,\n    lua_isstring,\n    lua_newtable,\n    lua_pop,\n    lua_pushboolean,\n    lua_pushcclosure,\n    lua_pushcfunction,\n    lua_pushfstring,\n    lua_pushglobaltable,\n    lua_pushlightuserdata,\n    lua_pushliteral,\n    lua_pushlstring,\n    lua_pushnil,\n    lua_pushstring,\n    lua_pushvalue,\n    lua_rawgeti,\n    lua_rawgetp,\n    lua_rawseti,\n    lua_rawsetp,\n    lua_remove,\n    lua_setfield,\n    lua_setmetatable,\n    lua_settop,\n    lua_toboolean,\n    lua_tostring,\n    lua_touserdata,\n    lua_upvalueindex\n} = require('./lua.js');\nconst {\n    LUA_LOADED_TABLE,\n    LUA_PRELOAD_TABLE,\n    luaL_Buffer,\n    luaL_addvalue,\n    luaL_buffinit,\n    luaL_checkstring,\n    luaL_error,\n    luaL_getsubtable,\n    luaL_gsub,\n    luaL_len,\n    luaL_loadfile,\n    luaL_newlib,\n    luaL_optstring,\n    luaL_pushresult,\n    luaL_setfuncs\n} = require('./lauxlib.js');\nconst lualib = require('./lualib.js');\nconst {\n    luastring_indexOf,\n    to_jsstring,\n    to_luastring,\n    to_uristring\n} = require(\"./fengaricore.js\");\nconst fengari  = require('./fengari.js');\n\nconst global_env = (function() {\n    if (typeof process !== \"undefined\") {\n        /* node */\n        return global;\n    } else if (typeof window !== \"undefined\") {\n        /* browser window */\n        return window;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n        /* web worker */\n        return self;\n    } else {\n        /* unknown global env */\n        return (0, eval)('this'); /* use non-strict mode to get global env */\n    }\n})();\n\nconst JSLIBS = to_luastring(\"__JSLIBS__\");\nconst LUA_PATH_VAR = \"LUA_PATH\";\nconst LUA_JSPATH_VAR = \"LUA_JSPATH\";\n\nconst LUA_IGMARK = \"-\";\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a JS loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\nconst LUA_CSUBSEP = LUA_DIRSEP;\nconst LUA_LSUBSEP = LUA_DIRSEP;\n\n/* prefix for open functions in JS libraries */\nconst LUA_POF = to_luastring(\"luaopen_\");\n\n/* separator for open functions in JS libraries */\nconst LUA_OFSEP = to_luastring(\"_\");\nconst LIB_FAIL = \"open\";\n\nconst AUXMARK = to_luastring(\"\\x01\");\n\n\n/*\n** load JS library in file 'path'. If 'seeglb', load with all names in\n** the library global.\n** Returns the library; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nlet lsys_load;\nif (typeof process === \"undefined\") {\n    lsys_load = function(L, path, seeglb) {\n        path = to_uristring(path);\n        let xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", path, false);\n        xhr.send();\n\n        if (xhr.status < 200 || xhr.status >= 300) {\n            lua_pushstring(L, to_luastring(`${xhr.status}: ${xhr.statusText}`));\n            return null;\n        }\n\n        let code = xhr.response;\n        /* Add sourceURL comment to get path in debugger+tracebacks */\n        if (!/\\/\\/[#@] sourceURL=/.test(code))\n            code += \" //# sourceURL=\" + path;\n        let func;\n        try {\n            func = Function(\"fengari\", code);\n        } catch (e) {\n            lua_pushstring(L, to_luastring(`${e.name}: ${e.message}`));\n            return null;\n        }\n        let res = func(fengari);\n        if (typeof res === \"function\" || (typeof res === \"object\" && res !== null)) {\n            return res;\n        } else if (res === void 0) { /* assume library added symbols to global environment */\n            return global_env;\n        } else {\n            lua_pushstring(L, to_luastring(`library returned unexpected type (${typeof res})`));\n            return null;\n        }\n    };\n} else {\n    const pathlib = require('path');\n    lsys_load = function(L, path, seeglb) {\n        path = to_jsstring(path);\n        /* relative paths should be relative to cwd, not this js file */\n        path = pathlib.resolve(process.cwd(), path);\n        try {\n            return require(path);\n        } catch (e) {\n            lua_pushstring(L, to_luastring(e.message));\n            return null;\n        }\n    };\n}\n\n/*\n** Try to find a function named 'sym' in library 'lib'.\n** Returns the function; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nconst lsys_sym = function(L, lib, sym) {\n    let f = lib[to_jsstring(sym)];\n\n    if (f && typeof f === 'function')\n        return f;\n    else {\n        lua_pushfstring(L, to_luastring(\"undefined symbol: %s\"), sym);\n        return null;\n    }\n};\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nconst noenv = function(L) {\n    lua_getfield(L, LUA_REGISTRYINDEX, to_luastring(\"LUA_NOENV\"));\n    let b = lua_toboolean(L, -1);\n    lua_pop(L, 1);  /* remove value */\n    return b;\n};\n\nlet readable;\nif (typeof process !== \"undefined\") { // Only with Node\n    const fs = require('fs');\n\n    readable = function(filename) {\n        try {\n            let fd = fs.openSync(filename, 'r');\n            fs.closeSync(fd);\n        } catch (e) {\n            return false;\n        }\n        return true;\n    };\n} else {\n    readable = function(path) {\n        path = to_uristring(path);\n        let xhr = new XMLHttpRequest();\n        /* Following GET request done by searcher_Web will be cached */\n        xhr.open(\"GET\", path, false);\n        xhr.send();\n\n        return xhr.status >= 200 && xhr.status <= 299;\n    };\n}\n\n\n/* error codes for 'lookforfunc' */\nconst ERRLIB  = 1;\nconst ERRFUNC = 2;\n\n/*\n** Look for a C function named 'sym' in a dynamically loaded library\n** 'path'.\n** First, check whether the library is already loaded; if not, try\n** to load it.\n** Then, if 'sym' is '*', return true (as library has been loaded).\n** Otherwise, look for symbol 'sym' in the library and push a\n** C function with that symbol.\n** Return 0 and 'true' or a function in the stack; in case of\n** errors, return an error code and an error message in the stack.\n*/\nconst lookforfunc = function(L, path, sym) {\n    let reg = checkjslib(L, path);  /* check loaded JS libraries */\n    if (reg === null) {  /* must load library? */\n        reg = lsys_load(L, path, sym[0] === '*'.charCodeAt(0));  /* a global symbols if 'sym'=='*' */\n        if (reg === null) return ERRLIB;  /* unable to load library */\n        addtojslib(L, path, reg);\n    }\n    if (sym[0] === '*'.charCodeAt(0)) {  /* loading only library (no function)? */\n        lua_pushboolean(L, 1);  /* return 'true' */\n        return 0;  /* no errors */\n    }\n    else {\n        let f = lsys_sym(L, reg, sym);\n        if (f === null)\n            return ERRFUNC;  /* unable to find function */\n        lua_pushcfunction(L, f);  /* else create new function */\n        return 0;  /* no errors */\n    }\n};\n\nconst ll_loadlib = function(L) {\n    let path = luaL_checkstring(L, 1);\n    let init = luaL_checkstring(L, 2);\n    let stat = lookforfunc(L, path, init);\n    if (stat === 0)  /* no errors? */\n        return 1;  /* return the loaded function */\n    else {  /* error; error message is on stack top */\n        lua_pushnil(L);\n        lua_insert(L, -2);\n        lua_pushliteral(L, (stat === ERRLIB) ? LIB_FAIL : \"init\");\n        return 3;  /* return nil, error message, and where */\n    }\n};\n\nconst env = (function() {\n    if (typeof process !== \"undefined\") {\n        /* node */\n        return process.env;\n    } else {\n        return global_env;\n    }\n})();\n\n/*\n** Set a path\n*/\nconst setpath = function(L, fieldname, envname, dft) {\n    let nver = `${envname}${lualib.LUA_VERSUFFIX}`;\n    lua_pushstring(L, to_luastring(nver));\n    let path = env[nver];  /* use versioned name */\n    if (path === undefined)  /* no environment variable? */\n        path = env[envname];  /* try unversioned name */\n    if (path === undefined || noenv(L))  /* no environment variable? */\n        lua_pushstring(L, dft);  /* use default */\n    else {\n        /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n        path = luaL_gsub(\n            L,\n            to_luastring(path),\n            to_luastring(LUA_PATH_SEP + LUA_PATH_SEP, true),\n            to_luastring(LUA_PATH_SEP + to_jsstring(AUXMARK) + LUA_PATH_SEP, true)\n        );\n        luaL_gsub(L, path, AUXMARK, dft);\n        lua_remove(L, -2); /* remove result from 1st 'gsub' */\n    }\n    lua_setfield(L, -3, fieldname);  /* package[fieldname] = path value */\n    lua_pop(L, 1);  /* pop versioned variable name */\n};\n\n/*\n** return registry.JSLIBS[path]\n*/\nconst checkjslib = function(L, path) {\n    lua_rawgetp(L, LUA_REGISTRYINDEX, JSLIBS);\n    lua_getfield(L, -1, path);\n    let plib = lua_touserdata(L, -1);  /* plib = JSLIBS[path] */\n    lua_pop(L, 2);  /* pop JSLIBS table and 'plib' */\n    return plib;\n};\n\n/*\n** registry.JSLIBS[path] = plib        -- for queries\n** registry.JSLIBS[#JSLIBS + 1] = plib  -- also keep a list of all libraries\n*/\nconst addtojslib = function(L, path, plib) {\n    lua_rawgetp(L, LUA_REGISTRYINDEX, JSLIBS);\n    lua_pushlightuserdata(L, plib);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, -3, path);  /* JSLIBS[path] = plib */\n    lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* JSLIBS[#JSLIBS + 1] = plib */\n    lua_pop(L, 1);  /* pop JSLIBS table */\n};\n\nconst pushnexttemplate = function(L, path) {\n    while (path[0] === LUA_PATH_SEP.charCodeAt(0)) path = path.subarray(1);  /* skip separators */\n    if (path.length === 0) return null;  /* no more templates */\n    let l = luastring_indexOf(path, LUA_PATH_SEP.charCodeAt(0));  /* find next separator */\n    if (l < 0) l = path.length;\n    lua_pushlstring(L, path, l);  /* template */\n    return path.subarray(l);\n};\n\nconst searchpath = function(L, name, path, sep, dirsep) {\n    let msg = new luaL_Buffer();  /* to build error message */\n    luaL_buffinit(L, msg);\n    if (sep[0] !== 0)  /* non-empty separator? */\n        name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n    while ((path = pushnexttemplate(L, path)) !== null) {\n        let filename = luaL_gsub(L, lua_tostring(L, -1), to_luastring(LUA_PATH_MARK, true), name);\n        lua_remove(L, -2);  /* remove path template */\n        if (readable(filename))  /* does file exist and is readable? */\n            return filename;  /* return that file name */\n        lua_pushfstring(L, to_luastring(\"\\n\\tno file '%s'\"), filename);\n        lua_remove(L, -2);  /* remove file name */\n        luaL_addvalue(msg);\n    }\n    luaL_pushresult(msg);  /* create error message */\n    return null;  /* not found */\n};\n\nconst ll_searchpath = function(L) {\n    let f = searchpath(\n        L,\n        luaL_checkstring(L, 1),\n        luaL_checkstring(L, 2),\n        luaL_optstring(L, 3, \".\"),\n        luaL_optstring(L, 4, LUA_DIRSEP)\n    );\n    if (f !== null) return 1;\n    else {  /* error message is on top of the stack */\n        lua_pushnil(L);\n        lua_insert(L, -2);\n        return 2;  /* return nil + error message */\n    }\n};\n\nconst findfile = function(L, name, pname, dirsep) {\n    lua_getfield(L, lua_upvalueindex(1), pname);\n    let path = lua_tostring(L, -1);\n    if (path === null)\n        luaL_error(L, to_luastring(\"'package.%s' must be a string\"), pname);\n    return searchpath(L, name, path, to_luastring(\".\"), dirsep);\n};\n\nconst checkload = function(L, stat, filename) {\n    if (stat) {  /* module loaded successfully? */\n        lua_pushstring(L, filename);  /* will be 2nd argument to module */\n        return 2;  /* return open function and file name */\n    } else\n        return luaL_error(L, to_luastring(\"error loading module '%s' from file '%s':\\n\\t%s\"),\n            lua_tostring(L, 1), filename, lua_tostring(L, -1));\n};\n\nconst searcher_Lua = function(L) {\n    let name = luaL_checkstring(L, 1);\n    let filename = findfile(L, name, to_luastring(\"path\", true), to_luastring(LUA_LSUBSEP, true));\n    if (filename === null) return 1;  /* module not found in this path */\n    return checkload(L, luaL_loadfile(L, filename) === LUA_OK, filename);\n};\n\n/*\n** Try to find a load function for module 'modname' at file 'filename'.\n** First, change '.' to '_' in 'modname'; then, if 'modname' has\n** the form X-Y (that is, it has an \"ignore mark\"), build a function\n** name \"luaopen_X\" and look for it. (For compatibility, if that\n** fails, it also tries \"luaopen_Y\".) If there is no ignore mark,\n** look for a function named \"luaopen_modname\".\n*/\nconst loadfunc = function(L, filename, modname) {\n    let openfunc;\n    modname = luaL_gsub(L, modname, to_luastring(\".\"), LUA_OFSEP);\n    let mark = luastring_indexOf(modname, LUA_IGMARK.charCodeAt(0));\n    if (mark >= 0) {\n        openfunc = lua_pushlstring(L, modname, mark);\n        openfunc = lua_pushfstring(L, to_luastring(\"%s%s\"), LUA_POF, openfunc);\n        let stat = lookforfunc(L, filename, openfunc);\n        if (stat !== ERRFUNC) return stat;\n        modname = mark + 1;  /* else go ahead and try old-style name */\n    }\n    openfunc = lua_pushfstring(L, to_luastring(\"%s%s\"), LUA_POF, modname);\n    return lookforfunc(L, filename, openfunc);\n};\n\nconst searcher_C = function(L) {\n    let name = luaL_checkstring(L, 1);\n    let filename = findfile(L, name, to_luastring(\"jspath\", true), to_luastring(LUA_CSUBSEP, true));\n    if (filename === null) return 1;  /* module not found in this path */\n    return checkload(L, (loadfunc(L, filename, name) === 0), filename);\n};\n\nconst searcher_Croot = function(L) {\n    let name = luaL_checkstring(L, 1);\n    let p = luastring_indexOf(name, '.'.charCodeAt(0));\n    let stat;\n    if (p < 0) return 0;  /* is root */\n    lua_pushlstring(L, name, p);\n    let filename = findfile(L, lua_tostring(L, -1), to_luastring(\"jspath\", true), to_luastring(LUA_CSUBSEP, true));\n    if (filename === null) return 1;  /* root not found */\n    if ((stat = loadfunc(L, filename, name)) !== 0) {\n        if (stat != ERRFUNC)\n            return checkload(L, 0, filename);  /* real error */\n        else {  /* open function not found */\n            lua_pushstring(L, to_luastring(\"\\n\\tno module '%s' in file '%s'\"), name, filename);\n            return 1;\n        }\n    }\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;\n};\n\nconst searcher_preload = function(L) {\n    let name = luaL_checkstring(L, 1);\n    lua_getfield(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n    if (lua_getfield(L, -1, name) === LUA_TNIL)  /* not found? */\n        lua_pushfstring(L, to_luastring(\"\\n\\tno field package.preload['%s']\"), name);\n    return 1;\n};\n\nconst findloader = function(L, name, ctx, k) {\n    let msg = new luaL_Buffer();  /* to build error message */\n    luaL_buffinit(L, msg);\n    /* push 'package.searchers' to index 3 in the stack */\n    if (lua_getfield(L, lua_upvalueindex(1), to_luastring(\"searchers\", true)) !== LUA_TTABLE)\n        luaL_error(L, to_luastring(\"'package.searchers' must be a table\"));\n    let ctx2 = {name: name, i: 1, msg: msg, ctx: ctx, k: k};\n    return findloader_cont(L, LUA_OK, ctx2);\n};\n\nconst findloader_cont = function(L, status, ctx) {\n    /*  iterate over available searchers to find a loader */\n    for (; ; ctx.i++) {\n        if (status === LUA_OK) {\n            if (lua_rawgeti(L, 3, ctx.i) === LUA_TNIL) {  /* no more searchers? */\n                lua_pop(L, 1);  /* remove nil */\n                luaL_pushresult(ctx.msg);  /* create error message */\n                luaL_error(L, to_luastring(\"module '%s' not found:%s\"), ctx.name, lua_tostring(L, -1));\n            }\n            lua_pushstring(L, ctx.name);\n            lua_callk(L, 1, 2, ctx, findloader_cont);  /* call it */\n        } else {\n            status = LUA_OK;\n        }\n        if (lua_isfunction(L, -2))  /* did it find a loader? */\n            break;  /* module loader found */\n        else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n            lua_pop(L, 1);  /* remove extra return */\n            luaL_addvalue(ctx.msg);  /* concatenate error message */\n        }\n        else\n            lua_pop(L, 2);  /* remove both returns */\n    }\n    return ctx.k(L, LUA_OK, ctx.ctx);\n};\n\nconst ll_require = function(L) {\n    let name = luaL_checkstring(L, 1);\n    lua_settop(L, 1);  /* LOADED table will be at index 2 */\n    lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n    lua_getfield(L, 2, name);  /* LOADED[name] */\n    if (lua_toboolean(L, -1))  /* is it there? */\n        return 1;  /* package is already loaded */\n    /* else must load package */\n    lua_pop(L, 1);  /* remove 'getfield' result */\n    let ctx = name;\n    return findloader(L, name, ctx, ll_require_cont);\n};\n\nconst ll_require_cont = function(L, status, ctx) {\n    let name = ctx;\n    lua_pushstring(L, name);  /* pass name as argument to module loader */\n    lua_insert(L, -2);  /* name is 1st argument (before search data) */\n    lua_callk(L, 2, 1, ctx, ll_require_cont2);\n    return ll_require_cont2(L, LUA_OK, ctx);  /* run loader to load module */\n};\n\nconst ll_require_cont2 = function(L, status, ctx) {\n    let name = ctx;\n    if (!lua_isnil(L, -1))  /* non-nil return? */\n        lua_setfield(L, 2, name);  /* LOADED[name] = returned value */\n    if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */\n        lua_pushboolean(L, 1);  /* use true as result */\n        lua_pushvalue(L, -1);  /* extra copy to be returned */\n        lua_setfield(L, 2, name);  /* LOADED[name] = true */\n    }\n    return 1;\n};\n\nconst pk_funcs = {\n    \"loadlib\": ll_loadlib,\n    \"searchpath\": ll_searchpath\n};\n\nconst ll_funcs = {\n    \"require\": ll_require\n};\n\nconst createsearcherstable = function(L) {\n    let searchers = [searcher_preload, searcher_Lua, searcher_C, searcher_Croot, null];\n    /* create 'searchers' table */\n    lua_createtable(L);\n    /* fill it with predefined searchers */\n    for (let i = 0; searchers[i]; i++) {\n        lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n        lua_pushcclosure(L, searchers[i], 1);\n        lua_rawseti(L, -2, i+1);\n    }\n    lua_setfield(L, -2, to_luastring(\"searchers\", true));  /* put it in field 'searchers' */\n};\n\n/*\n** create table JSLIBS to keep track of loaded JS libraries,\n** setting a finalizer to close all libraries when closing state.\n*/\nconst createjslibstable = function(L) {\n    lua_newtable(L);  /* create JSLIBS table */\n    lua_createtable(L, 0, 1);  /* create metatable for JSLIBS */\n    lua_setmetatable(L, -2);\n    lua_rawsetp(L, LUA_REGISTRYINDEX, JSLIBS);  /* set JSLIBS table in registry */\n};\n\nconst luaopen_package = function(L) {\n    createjslibstable(L);\n    luaL_newlib(L, pk_funcs);  /* create 'package' table */\n    createsearcherstable(L);\n    /* set paths */\n    setpath(L, to_luastring(\"path\", true), LUA_PATH_VAR, LUA_PATH_DEFAULT);\n    setpath(L, to_luastring(\"jspath\", true), LUA_JSPATH_VAR, LUA_JSPATH_DEFAULT);\n    /* store config information */\n    lua_pushliteral(L, LUA_DIRSEP + \"\\n\" + LUA_PATH_SEP + \"\\n\" + LUA_PATH_MARK + \"\\n\" +\n                        LUA_EXEC_DIR + \"\\n\" + LUA_IGMARK + \"\\n\");\n    lua_setfield(L, -2, to_luastring(\"config\", true));\n    /* set field 'loaded' */\n    luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n    lua_setfield(L, -2, to_luastring(\"loaded\", true));\n    /* set field 'preload' */\n    luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n    lua_setfield(L, -2, to_luastring(\"preload\", true));\n    lua_pushglobaltable(L);\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n    luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n    lua_pop(L, 1);  /* pop global table */\n    return 1;  /* return 'package' table */\n};\n\nmodule.exports.luaopen_package = luaopen_package;\n","const {\n    lua_pushinteger,\n    lua_pushliteral,\n    lua_setfield\n} = require('./lua.js');\nconst {\n    luaL_newlib\n} = require('./lauxlib.js');\nconst {\n    FENGARI_AUTHORS,\n    FENGARI_COPYRIGHT,\n    FENGARI_RELEASE,\n    FENGARI_VERSION,\n    FENGARI_VERSION_MAJOR,\n    FENGARI_VERSION_MINOR,\n    FENGARI_VERSION_NUM,\n    FENGARI_VERSION_RELEASE,\n    to_luastring\n} = require(\"./fengaricore.js\");\n\nconst luaopen_fengari = function(L) {\n    luaL_newlib(L, {});\n    lua_pushliteral(L, FENGARI_AUTHORS);\n    lua_setfield(L, -2, to_luastring(\"AUTHORS\"));\n    lua_pushliteral(L, FENGARI_COPYRIGHT);\n    lua_setfield(L, -2, to_luastring(\"COPYRIGHT\"));\n    lua_pushliteral(L, FENGARI_RELEASE);\n    lua_setfield(L, -2, to_luastring(\"RELEASE\"));\n    lua_pushliteral(L, FENGARI_VERSION);\n    lua_setfield(L, -2, to_luastring(\"VERSION\"));\n    lua_pushliteral(L, FENGARI_VERSION_MAJOR);\n    lua_setfield(L, -2, to_luastring(\"VERSION_MAJOR\"));\n    lua_pushliteral(L, FENGARI_VERSION_MINOR);\n    lua_setfield(L, -2, to_luastring(\"VERSION_MINOR\"));\n    lua_pushinteger(L, FENGARI_VERSION_NUM);\n    lua_setfield(L, -2, to_luastring(\"VERSION_NUM\"));\n    lua_pushliteral(L, FENGARI_VERSION_RELEASE);\n    lua_setfield(L, -2, to_luastring(\"VERSION_RELEASE\"));\n    return 1;\n};\n\nmodule.exports.luaopen_fengari = luaopen_fengari;\n","\"use strict\";\r\n\r\nimport {\r\n\tFENGARI_AUTHORS,\r\n\tFENGARI_COPYRIGHT,\r\n\tFENGARI_RELEASE,\r\n\tFENGARI_VERSION,\r\n\tFENGARI_VERSION_MAJOR,\r\n\tFENGARI_VERSION_MINOR,\r\n\tFENGARI_VERSION_NUM,\r\n\tFENGARI_VERSION_RELEASE,\r\n\r\n\tluastring_eq,\r\n\tluastring_indexOf,\r\n\tluastring_of,\r\n\tto_jsstring,\r\n\tto_luastring,\r\n\tto_uristring,\r\n\r\n\tlua,\r\n\tlauxlib,\r\n\tlualib\r\n} from 'fengari';\r\nimport * as interop from 'fengari-interop';\r\n\r\nconst {\r\n\tLUA_ERRRUN,\r\n\tLUA_ERRSYNTAX,\r\n\tLUA_OK,\r\n\tLUA_VERSION_MAJOR,\r\n\tLUA_VERSION_MINOR,\r\n\tlua_Debug,\r\n\tlua_getinfo,\r\n\tlua_getstack,\r\n\tlua_gettop,\r\n\tlua_insert,\r\n\tlua_pcall,\r\n\tlua_pop,\r\n\tlua_pushcfunction,\r\n\tlua_pushstring,\r\n\tlua_remove,\r\n\tlua_setglobal,\r\n\tlua_tojsstring\r\n} = lua;\r\nconst {\r\n\tluaL_loadbuffer,\r\n\tluaL_newstate,\r\n\tluaL_requiref\r\n} = lauxlib;\r\nconst {\r\n\tcheckjs,\r\n\tluaopen_js,\r\n\tpush,\r\n\ttojs\r\n} = interop;\r\n\r\nexport {\r\n\tFENGARI_AUTHORS,\r\n\tFENGARI_COPYRIGHT,\r\n\tFENGARI_RELEASE,\r\n\tFENGARI_VERSION,\r\n\tFENGARI_VERSION_MAJOR,\r\n\tFENGARI_VERSION_MINOR,\r\n\tFENGARI_VERSION_NUM,\r\n\tFENGARI_VERSION_RELEASE,\r\n\r\n\tluastring_eq,\r\n\tluastring_indexOf,\r\n\tluastring_of,\r\n\tto_jsstring,\r\n\tto_luastring,\r\n\tto_uristring,\r\n\r\n\tlua,\r\n\tlauxlib,\r\n\tlualib,\r\n\tinterop\r\n};\r\n\r\nexport const L = luaL_newstate();\r\n\r\n/* open standard libraries */\r\nlualib.luaL_openlibs(L);\r\nluaL_requiref(L, to_luastring(\"js\"), luaopen_js, 1);\r\nlua_pop(L, 1); /* remove lib */\r\n\r\nlua_pushstring(L, to_luastring(FENGARI_COPYRIGHT));\r\nlua_setglobal(L, to_luastring(\"_COPYRIGHT\"));\r\n\r\n/* Helper function to load a JS string of Lua source */\r\nexport function load(source, chunkname) {\r\n\tif (typeof source == \"string\")\r\n\t\tsource = to_luastring(source);\r\n\telse if (!(source instanceof Uint8Array))\r\n\t\tthrow new TypeError(\"expects an array of bytes or javascript string\");\r\n\r\n\tchunkname = chunkname?to_luastring(chunkname):null;\r\n\tlet ok = luaL_loadbuffer(L, source, null, chunkname);\r\n\tlet res;\r\n\tif (ok === LUA_ERRSYNTAX) {\r\n\t\tres = new SyntaxError(lua_tojsstring(L, -1));\r\n\t} else {\r\n\t\tres = tojs(L, -1);\r\n\t}\r\n\tlua_pop(L, 1);\r\n\tif (ok !== LUA_OK) {\r\n\t\tthrow res;\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nif (typeof document !== 'undefined' && document instanceof HTMLDocument) {\r\n\t/* Have a document, e.g. we are in main browser window */\r\n\r\n\tconst crossorigin_to_credentials = function(crossorigin) {\r\n\t\tswitch(crossorigin) {\r\n\t\t\tcase \"anonymous\": return \"omit\";\r\n\t\t\tcase \"use-credentials\": return \"include\";\r\n\t\t\tdefault: return \"same-origin\";\r\n\t\t}\r\n\t};\r\n\r\n\tconst msghandler = function(L) {\r\n\t\tlet ar = new lua_Debug();\r\n\t\tif (lua_getstack(L, 2, ar))\r\n\t\t\tlua_getinfo(L, to_luastring(\"Sl\"), ar);\r\n\t\tpush(L, new ErrorEvent(\"error\", {\r\n\t\t\tbubbles: true,\r\n\t\t\tcancelable: true,\r\n\t\t\tmessage: lua_tojsstring(L, 1),\r\n\t\t\terror: tojs(L, 1),\r\n\t\t\tfilename: ar.short_src ? to_jsstring(ar.short_src) : void 0,\r\n\t\t\tlineno: ar.currentline > 0 ? ar.currentline : void 0\r\n\t\t}));\r\n\t\treturn 1;\r\n\t};\r\n\r\n\tconst run_lua_script = function(tag, code, chunkname) {\r\n\t\tlet ok = luaL_loadbuffer(L, code, null, chunkname);\r\n\t\tlet e;\r\n\t\tif (ok === LUA_ERRSYNTAX) {\r\n\t\t\tlet msg = lua_tojsstring(L, -1);\r\n\t\t\tlet filename = tag.src?tag.src:document.location;\r\n\t\t\tlet lineno = void 0; /* TODO: extract out of msg */\r\n\t\t\tlet syntaxerror = new SyntaxError(msg, filename, lineno);\r\n\t\t\te = new ErrorEvent(\"error\", {\r\n\t\t\t\tmessage: msg,\r\n\t\t\t\terror: syntaxerror,\r\n\t\t\t\tfilename: filename,\r\n\t\t\t\tlineno: lineno\r\n\t\t\t});\r\n\t\t} else if (ok === LUA_OK) {\r\n\t\t\t/* insert message handler below function */\r\n\t\t\tlet base = lua_gettop(L);\r\n\t\t\tlua_pushcfunction(L, msghandler);\r\n\t\t\tlua_insert(L, base);\r\n\t\t\t/* set document.currentScript.\r\n\t\t\t   We can't set it normally; but we can create a getter for it, then remove the getter */\r\n\t\t\tObject.defineProperty(document, 'currentScript', {\r\n\t\t\t\tvalue: tag,\r\n\t\t\t\tconfigurable: true\r\n\t\t\t});\r\n\t\t\tok = lua_pcall(L, 0, 0, base);\r\n\t\t\t/* Remove the currentScript getter installed above; this restores normal behaviour */\r\n\t\t\tdelete document.currentScript;\r\n\t\t\t/* Remove message handler */\r\n\t\t\tlua_remove(L, base);\r\n\t\t\t/* Check if normal error that msghandler would have handled */\r\n\t\t\tif (ok === LUA_ERRRUN) {\r\n\t\t\t\te = checkjs(L, -1);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ok !== LUA_OK) {\r\n\t\t\tif (e === void 0) {\r\n\t\t\t\te = new ErrorEvent(\"error\", {\r\n\t\t\t\t\tmessage: lua_tojsstring(L, -1),\r\n\t\t\t\t\terror: tojs(L, -1)\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tlua_pop(L, 1);\r\n\t\t\tif (window.dispatchEvent(e)) {\r\n\t\t\t\tconsole.error(\"uncaught exception\", e.error);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tconst process_xhr_response = function(xhr, tag, chunkname) {\r\n\t\tif (xhr.status >= 200 && xhr.status < 300) {\r\n\t\t\tlet code = xhr.response;\r\n\t\t\tif (typeof code === \"string\") {\r\n\t\t\t\tcode = to_luastring(xhr.response);\r\n\t\t\t} else { /* is an array buffer */\r\n\t\t\t\tcode = new Uint8Array(code);\r\n\t\t\t}\r\n\t\t\t/* TODO: subresource integrity check? */\r\n\t\t\trun_lua_script(tag, code, chunkname);\r\n\t\t} else {\r\n\t\t\ttag.dispatchEvent(new Event(\"error\"));\r\n\t\t}\r\n\t};\r\n\r\n\tconst run_lua_script_tag = function(tag) {\r\n\t\tif (tag.src) {\r\n\t\t\tlet chunkname = to_luastring(\"@\"+tag.src);\r\n\t\t\t/* JS script tags are async after document has loaded */\r\n\t\t\tif (document.readyState === \"complete\" || tag.async) {\r\n\t\t\t\tif (typeof fetch === \"function\") {\r\n\t\t\t\t\tfetch(tag.src, {\r\n\t\t\t\t\t\tmethod: \"GET\",\r\n\t\t\t\t\t\tcredentials: crossorigin_to_credentials(tag.crossorigin),\r\n\t\t\t\t\t\tredirect: \"follow\",\r\n\t\t\t\t\t\tintegrity: tag.integrity\r\n\t\t\t\t\t}).then(function(resp) {\r\n\t\t\t\t\t\tif (resp.ok) {\r\n\t\t\t\t\t\t\treturn resp.arrayBuffer();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow new Error(\"unable to fetch\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}).then(function(buffer) {\r\n\t\t\t\t\t\tlet code = new Uint8Array(buffer);\r\n\t\t\t\t\t\trun_lua_script(tag, code, chunkname);\r\n\t\t\t\t\t}).catch(function(reason) {\r\n\t\t\t\t\t\ttag.dispatchEvent(new Event(\"error\"));\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet xhr = new XMLHttpRequest();\r\n\t\t\t\t\txhr.open(\"GET\", tag.src, true);\r\n\t\t\t\t\txhr.responseType = \"arraybuffer\";\r\n\t\t\t\t\txhr.onreadystatechange = function() {\r\n\t\t\t\t\t\tif (xhr.readyState === 4)\r\n\t\t\t\t\t\t\tprocess_xhr_response(xhr, tag, chunkname);\r\n\t\t\t\t\t};\r\n\t\t\t\t\txhr.send();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t/* Needs to be synchronous: use an XHR */\r\n\t\t\t\tlet xhr = new XMLHttpRequest();\r\n\t\t\t\txhr.open(\"GET\", tag.src, false);\r\n\t\t\t\txhr.send();\r\n\t\t\t\tprocess_xhr_response(xhr, tag, chunkname);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet code = to_luastring(tag.innerHTML);\r\n\t\t\tlet chunkname = tag.id ? to_luastring(\"=\"+tag.id) : code;\r\n\t\t\trun_lua_script(tag, code, chunkname);\r\n\t\t}\r\n\t};\r\n\r\n\tconst contentTypeRegexp = /^(.*?\\/.*?)([\\t ]*;.*)?$/;\r\n\tconst luaVersionRegex = /^(\\d+)\\.(\\d+)$/;\r\n\tconst try_tag = function(tag) {\r\n\t\tif (tag.tagName !== \"SCRIPT\")\r\n\t\t\treturn;\r\n\r\n\t\t/* strip off mime type parameters */\r\n\t\tlet contentTypeMatch = contentTypeRegexp.exec(tag.type);\r\n\t\tif (!contentTypeMatch)\r\n\t\t\treturn;\r\n\t\tlet mimetype = contentTypeMatch[1];\r\n\t\tif (mimetype !== \"application/lua\" && mimetype !== \"text/lua\")\r\n\t\t\treturn;\r\n\r\n\t\tif (tag.hasAttribute(\"lua-version\")) {\r\n\t\t\tlet lua_version = luaVersionRegex.exec(tag.getAttribute(\"lua-version\"));\r\n\t\t\tif (!lua_version || lua_version[1] !== LUA_VERSION_MAJOR || lua_version[2] !== LUA_VERSION_MINOR)\r\n\t\t\t\treturn;\r\n\t\t}\r\n\r\n\t\trun_lua_script_tag(tag);\r\n\t};\r\n\r\n\tif (typeof MutationObserver !== 'undefined') {\r\n\t\t/* watch for new script tags added to document */\r\n\t\t(new MutationObserver(function(records, observer) {\r\n\t\t\tfor (let i=0; i<records.length; i++) {\r\n\t\t\t\tlet record = records[i];\r\n\t\t\t\tfor (let j=0; j<record.addedNodes.length; j++) {\r\n\t\t\t\t\ttry_tag(record.addedNodes[j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})).observe(document, {\r\n\t\t\tchildList: true,\r\n\t\t\tsubtree: true\r\n\t\t});\r\n\t} else if (console.warn) {\r\n\t\tconsole.warn(\"fengari-web: MutationObserver not found; lua script tags will not be run when inserted\");\r\n\t}\r\n\r\n\t/* the query selector here is slightly liberal,\r\n\t   more checks occur in try_tag */\r\n\tconst selector = 'script[type^=\"application/lua\"], script[type^=\"text/lua\"]';\r\n\r\n\t/* try to run existing script tags */\r\n\tArray.prototype.forEach.call(document.querySelectorAll(selector), try_tag);\r\n}\r\n","\"use strict\";\n\nconst {\n    LUA_MULTRET,\n    LUA_OPADD,\n    LUA_OPBAND,\n    LUA_OPBNOT,\n    LUA_OPBOR,\n    LUA_OPBXOR,\n    LUA_OPDIV,\n    LUA_OPIDIV,\n    LUA_OPMOD,\n    LUA_OPSHL,\n    LUA_OPSHR,\n    LUA_OPUNM,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TLIGHTUSERDATA,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TTABLE\n    },\n    to_luastring\n} = require('./defs.js');\nconst { lua_assert } = require(\"./llimits.js\");\nconst llex     = require('./llex.js');\nconst lobject  = require('./lobject.js');\nconst lopcodes = require('./lopcodes.js');\nconst lparser  = require('./lparser.js');\nconst ltable   = require('./ltable.js');\nconst lvm      = require('./lvm.js');\n\nconst OpCodesI = lopcodes.OpCodesI;\nconst TValue   = lobject.TValue;\n\n/* Maximum number of registers in a Lua function (must fit in 8 bits) */\nconst MAXREGS = 255;\n\n/*\n** Marks the end of a patch list. It is an invalid value both as an absolute\n** address, and as a list link (would link an element to itself).\n*/\nconst NO_JUMP = -1;\n\nconst BinOpr = {\n    OPR_ADD:      0,\n    OPR_SUB:      1,\n    OPR_MUL:      2,\n    OPR_MOD:      3,\n    OPR_POW:      4,\n    OPR_DIV:      5,\n    OPR_IDIV:     6,\n    OPR_BAND:     7,\n    OPR_BOR:      8,\n    OPR_BXOR:     9,\n    OPR_SHL:      10,\n    OPR_SHR:      11,\n    OPR_CONCAT:   12,\n    OPR_EQ:       13,\n    OPR_LT:       14,\n    OPR_LE:       15,\n    OPR_NE:       16,\n    OPR_GT:       17,\n    OPR_GE:       18,\n    OPR_AND:      19,\n    OPR_OR:       20,\n    OPR_NOBINOPR: 21\n};\n\nconst UnOpr = {\n    OPR_MINUS:    0,\n    OPR_BNOT:     1,\n    OPR_NOT:      2,\n    OPR_LEN:      3,\n    OPR_NOUNOPR:  4\n};\n\nconst hasjumps = function(e) {\n    return e.t !== e.f;\n};\n\n/*\n** If expression is a numeric constant returns either true or a new TValue\n** (depending on 'make_tvalue'). Otherwise, returns false.\n*/\nconst tonumeral = function(e, make_tvalue) {\n    let ek = lparser.expkind;\n    if (hasjumps(e))\n        return false;  /* not a numeral */\n    switch (e.k) {\n        case ek.VKINT:\n            if (make_tvalue) {\n                return new TValue(LUA_TNUMINT, e.u.ival);\n            }\n            return true;\n        case ek.VKFLT:\n            if (make_tvalue) {\n                return new TValue(LUA_TNUMFLT, e.u.nval);\n            }\n            return true;\n        default: return false;\n    }\n};\n\n/*\n** Create a OP_LOADNIL instruction, but try to optimize: if the previous\n** instruction is also OP_LOADNIL and ranges are compatible, adjust\n** range of previous instruction instead of emitting a new one. (For\n** instance, 'local a; local b' will generate a single opcode.)\n*/\nconst luaK_nil = function(fs, from, n) {\n    let previous;\n    let l = from + n - 1;  /* last register to set nil */\n    if (fs.pc > fs.lasttarget) {  /* no jumps to current position? */\n        previous = fs.f.code[fs.pc-1];\n        if (previous.opcode === OpCodesI.OP_LOADNIL) {  /* previous is LOADNIL? */\n            let pfrom = previous.A;  /* get previous range */\n            let pl = pfrom + previous.B;\n            if ((pfrom <= from && from <= pl + 1) ||\n                    (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */\n                if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */\n                if (pl > l) l = pl;  /* l = max(l, pl) */\n                lopcodes.SETARG_A(previous, from);\n                lopcodes.SETARG_B(previous, l - from);\n                return;\n            }\n        }  /* else go through */\n    }\n    luaK_codeABC(fs, OpCodesI.OP_LOADNIL, from, n - 1, 0);  /* else no optimization */\n};\n\nconst getinstruction = function(fs, e) {\n    return fs.f.code[e.u.info];\n};\n\n/*\n** Gets the destination address of a jump instruction. Used to traverse\n** a list of jumps.\n*/\nconst getjump = function(fs, pc) {\n    let offset = fs.f.code[pc].sBx;\n    if (offset === NO_JUMP)  /* point to itself represents end of list */\n        return NO_JUMP;  /* end of list */\n    else\n        return pc + 1 + offset;  /* turn offset into absolute position */\n};\n\n/*\n** Fix jump instruction at position 'pc' to jump to 'dest'.\n** (Jump addresses are relative in Lua)\n*/\nconst fixjump = function(fs, pc, dest) {\n    let jmp = fs.f.code[pc];\n    let offset = dest - (pc + 1);\n    lua_assert(dest !== NO_JUMP);\n    if (Math.abs(offset) > lopcodes.MAXARG_sBx)\n        llex.luaX_syntaxerror(fs.ls, to_luastring(\"control structure too long\", true));\n    lopcodes.SETARG_sBx(jmp, offset);\n};\n\n/*\n** Concatenate jump-list 'l2' into jump-list 'l1'\n*/\nconst luaK_concat = function(fs, l1, l2) {\n    if (l2 === NO_JUMP) return l1;  /* nothing to concatenate? */\n    else if (l1 === NO_JUMP)  /* no original list? */\n        l1 = l2;\n    else {\n        let list = l1;\n        let next = getjump(fs, list);\n        while (next !== NO_JUMP) {  /* find last element */\n            list = next;\n            next = getjump(fs, list);\n        }\n        fixjump(fs, list, l2);\n    }\n\n    return l1;\n};\n\n/*\n** Create a jump instruction and return its position, so its destination\n** can be fixed later (with 'fixjump'). If there are jumps to\n** this position (kept in 'jpc'), link them all together so that\n** 'patchlistaux' will fix all them directly to the final destination.\n*/\nconst luaK_jump = function (fs) {\n    let jpc = fs.jpc;  /* save list of jumps to here */\n    fs.jpc = NO_JUMP;  /* no more jumps to here */\n    let j = luaK_codeAsBx(fs, OpCodesI.OP_JMP, 0, NO_JUMP);\n    j = luaK_concat(fs, j, jpc);  /* keep them on hold */\n    return j;\n};\n\nconst luaK_jumpto = function(fs, t) {\n    return luaK_patchlist(fs, luaK_jump(fs), t);\n};\n\n/*\n** Code a 'return' instruction\n*/\nconst luaK_ret = function(fs, first, nret) {\n    luaK_codeABC(fs, OpCodesI.OP_RETURN, first, nret + 1, 0);\n};\n\n/*\n** Code a \"conditional jump\", that is, a test or comparison opcode\n** followed by a jump. Return jump position.\n*/\nconst condjump = function(fs, op, A, B, C) {\n    luaK_codeABC(fs, op, A, B, C);\n    return luaK_jump(fs);\n};\n\n/*\n** returns current 'pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\nconst luaK_getlabel = function(fs) {\n    fs.lasttarget = fs.pc;\n    return fs.pc;\n};\n\n/*\n** Returns the position of the instruction \"controlling\" a given\n** jump (that is, its condition), or the jump itself if it is\n** unconditional.\n*/\nconst getjumpcontroloffset = function(fs, pc) {\n    if (pc >= 1 && lopcodes.testTMode(fs.f.code[pc - 1].opcode))\n        return pc - 1;\n    else\n        return pc;\n};\nconst getjumpcontrol = function(fs, pc) {\n    return fs.f.code[getjumpcontroloffset(fs, pc)];\n};\n\n/*\n** Patch destination register for a TESTSET instruction.\n** If instruction in position 'node' is not a TESTSET, return 0 (\"fails\").\n** Otherwise, if 'reg' is not 'NO_REG', set it as the destination\n** register. Otherwise, change instruction to a simple 'TEST' (produces\n** no register value)\n*/\nconst patchtestreg = function(fs, node, reg) {\n    let pc = getjumpcontroloffset(fs, node);\n    let i = fs.f.code[pc];\n    if (i.opcode !== OpCodesI.OP_TESTSET)\n        return false;  /* cannot patch other instructions */\n    if (reg !== lopcodes.NO_REG && reg !== i.B)\n        lopcodes.SETARG_A(i, reg);\n    else {\n        /* no register to put value or register already has the value;\n           change instruction to simple test */\n        fs.f.code[pc] = lopcodes.CREATE_ABC(OpCodesI.OP_TEST, i.B, 0, i.C);\n    }\n    return true;\n};\n\n/*\n** Traverse a list of tests ensuring no one produces a value\n*/\nconst removevalues = function(fs, list) {\n    for (; list !== NO_JUMP; list = getjump(fs, list))\n        patchtestreg(fs, list, lopcodes.NO_REG);\n};\n\n/*\n** Traverse a list of tests, patching their destination address and\n** registers: tests producing values jump to 'vtarget' (and put their\n** values in 'reg'), other tests jump to 'dtarget'.\n*/\nconst patchlistaux = function(fs, list, vtarget, reg, dtarget) {\n    while (list !== NO_JUMP) {\n        let next = getjump(fs, list);\n        if (patchtestreg(fs, list, reg))\n            fixjump(fs, list, vtarget);\n        else\n            fixjump(fs, list, dtarget);  /* jump to default target */\n        list = next;\n    }\n};\n\n/*\n** Ensure all pending jumps to current position are fixed (jumping\n** to current position with no values) and reset list of pending\n** jumps\n*/\nconst dischargejpc = function(fs) {\n    patchlistaux(fs, fs.jpc, fs.pc, lopcodes.NO_REG, fs.pc);\n    fs.jpc = NO_JUMP;\n};\n\n/*\n** Add elements in 'list' to list of pending jumps to \"here\"\n** (current position)\n*/\nconst luaK_patchtohere = function(fs, list) {\n    luaK_getlabel(fs);  /* mark \"here\" as a jump target */\n    fs.jpc = luaK_concat(fs, fs.jpc, list);\n};\n\n/*\n** Path all jumps in 'list' to jump to 'target'.\n** (The assert means that we cannot fix a jump to a forward address\n** because we only know addresses once code is generated.)\n*/\nconst luaK_patchlist = function(fs, list, target) {\n    if (target === fs.pc)  /* 'target' is current position? */\n        luaK_patchtohere(fs, list);  /* add list to pending jumps */\n    else {\n        lua_assert(target < fs.pc);\n        patchlistaux(fs, list, target, lopcodes.NO_REG, target);\n    }\n};\n\n/*\n** Path all jumps in 'list' to close upvalues up to given 'level'\n** (The assertion checks that jumps either were closing nothing\n** or were closing higher levels, from inner blocks.)\n*/\nconst luaK_patchclose = function(fs, list, level) {\n    level++;  /* argument is +1 to reserve 0 as non-op */\n    for (; list !== NO_JUMP; list = getjump(fs, list)) {\n        let ins = fs.f.code[list];\n        lua_assert(ins.opcode === OpCodesI.OP_JMP && (ins.A === 0 || ins.A >= level));\n        lopcodes.SETARG_A(ins, level);\n    }\n};\n\n/*\n** Emit instruction 'i', checking for array sizes and saving also its\n** line information. Return 'i' position.\n*/\nconst luaK_code = function(fs, i) {\n    let f = fs.f;\n    dischargejpc(fs);  /* 'pc' will change */\n    /* put new instruction in code array */\n    f.code[fs.pc] = i;\n    f.lineinfo[fs.pc] = fs.ls.lastline;\n    return fs.pc++;\n};\n\n/*\n** Format and emit an 'iABC' instruction. (Assertions check consistency\n** of parameters versus opcode.)\n*/\nconst luaK_codeABC = function(fs, o, a, b, c) {\n    lua_assert(lopcodes.getOpMode(o) === lopcodes.iABC);\n    lua_assert(lopcodes.getBMode(o) !== lopcodes.OpArgN || b === 0);\n    lua_assert(lopcodes.getCMode(o) !== lopcodes.OpArgN || c === 0);\n    lua_assert(a <= lopcodes.MAXARG_A && b <= lopcodes.MAXARG_B && c <= lopcodes.MAXARG_C);\n    return luaK_code(fs, lopcodes.CREATE_ABC(o, a, b, c));\n};\n\n/*\n** Format and emit an 'iABx' instruction.\n*/\nconst luaK_codeABx = function(fs, o, a, bc) {\n    lua_assert(lopcodes.getOpMode(o) === lopcodes.iABx || lopcodes.getOpMode(o) === lopcodes.iAsBx);\n    lua_assert(lopcodes.getCMode(o) === lopcodes.OpArgN);\n    lua_assert(a <= lopcodes.MAXARG_A && bc <= lopcodes.MAXARG_Bx);\n    return luaK_code(fs, lopcodes.CREATE_ABx(o, a, bc));\n};\n\nconst luaK_codeAsBx = function(fs,o,A,sBx) {\n    return luaK_codeABx(fs, o, A, (sBx) + lopcodes.MAXARG_sBx);\n};\n\n/*\n** Emit an \"extra argument\" instruction (format 'iAx')\n*/\nconst codeextraarg = function(fs, a) {\n    lua_assert(a <= lopcodes.MAXARG_Ax);\n    return luaK_code(fs, lopcodes.CREATE_Ax(OpCodesI.OP_EXTRAARG, a));\n};\n\n/*\n** Emit a \"load constant\" instruction, using either 'OP_LOADK'\n** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'\n** instruction with \"extra argument\".\n*/\nconst luaK_codek = function(fs, reg, k) {\n    if (k <= lopcodes.MAXARG_Bx)\n        return luaK_codeABx(fs, OpCodesI.OP_LOADK, reg, k);\n    else {\n        let p = luaK_codeABx(fs, OpCodesI.OP_LOADKX, reg, 0);\n        codeextraarg(fs, k);\n        return p;\n    }\n};\n\n/*\n** Check register-stack level, keeping track of its maximum size\n** in field 'maxstacksize'\n*/\nconst luaK_checkstack = function(fs, n) {\n    let newstack = fs.freereg + n;\n    if (newstack > fs.f.maxstacksize) {\n        if (newstack >= MAXREGS)\n            llex.luaX_syntaxerror(fs.ls, to_luastring(\"function or expression needs too many registers\", true));\n        fs.f.maxstacksize = newstack;\n    }\n};\n\n/*\n** Reserve 'n' registers in register stack\n*/\nconst luaK_reserveregs = function(fs, n) {\n    luaK_checkstack(fs, n);\n    fs.freereg += n;\n};\n\n/*\n** Free register 'reg', if it is neither a constant index nor\n** a local variable.\n*/\nconst freereg = function(fs, reg) {\n    if (!lopcodes.ISK(reg) && reg >= fs.nactvar) {\n        fs.freereg--;\n        lua_assert(reg === fs.freereg);\n    }\n};\n\n/*\n** Free register used by expression 'e' (if any)\n*/\nconst freeexp = function(fs, e) {\n    if (e.k === lparser.expkind.VNONRELOC)\n        freereg(fs, e.u.info);\n};\n\n/*\n** Free registers used by expressions 'e1' and 'e2' (if any) in proper\n** order.\n*/\nconst freeexps = function(fs, e1, e2) {\n    let r1 = (e1.k === lparser.expkind.VNONRELOC) ? e1.u.info : -1;\n    let r2 = (e2.k === lparser.expkind.VNONRELOC) ? e2.u.info : -1;\n    if (r1 > r2) {\n        freereg(fs, r1);\n        freereg(fs, r2);\n    }\n    else {\n        freereg(fs, r2);\n        freereg(fs, r1);\n    }\n};\n\n\n/*\n** Add constant 'v' to prototype's list of constants (field 'k').\n** Use scanner's table to cache position of constants in constant list\n** and try to reuse constants. Because some values should not be used\n** as keys (nil cannot be a key, integer keys can collapse with float\n** keys), the caller must provide a useful 'key' for indexing the cache.\n*/\nconst addk = function(fs, key, v) {\n    let f = fs.f;\n    let idx = ltable.luaH_get(fs.L, fs.ls.h, key);  /* index scanner table */\n    if (idx.ttisinteger()) {  /* is there an index there? */\n        let k = idx.value;\n        /* correct value? (warning: must distinguish floats from integers!) */\n        if (k < fs.nk && f.k[k].ttype() === v.ttype() && f.k[k].value === v.value)\n            return k;  /* reuse index */\n    }\n    /* constant not found; create a new entry */\n    let k = fs.nk;\n    ltable.luaH_setfrom(fs.L, fs.ls.h, key, new lobject.TValue(LUA_TNUMINT, k));\n    f.k[k] = v;\n    fs.nk++;\n    return k;\n};\n\n/*\n** Add a string to list of constants and return its index.\n*/\nconst luaK_stringK = function(fs, s) {\n    let o = new TValue(LUA_TLNGSTR, s);\n    return addk(fs, o, o);  /* use string itself as key */\n};\n\n\n/*\n** Add an integer to list of constants and return its index.\n** Integers use userdata as keys to avoid collision with floats with\n** same value.\n*/\nconst luaK_intK = function(fs, n) {\n    let k = new TValue(LUA_TLIGHTUSERDATA, n);\n    let o = new TValue(LUA_TNUMINT, n);\n    return addk(fs, k, o);\n};\n\n/*\n** Add a float to list of constants and return its index.\n*/\nconst luaK_numberK = function(fs, r) {\n    let o = new TValue(LUA_TNUMFLT, r);\n    return addk(fs, o, o);  /* use number itself as key */\n};\n\n\n/*\n** Add a boolean to list of constants and return its index.\n*/\nconst boolK = function(fs, b) {\n    let o = new TValue(LUA_TBOOLEAN, b);\n    return addk(fs, o, o);  /* use boolean itself as key */\n};\n\n\n/*\n** Add nil to list of constants and return its index.\n*/\nconst nilK = function(fs) {\n    let v = new TValue(LUA_TNIL, null);\n    let k = new TValue(LUA_TTABLE, fs.ls.h);\n    /* cannot use nil as key; instead use table itself to represent nil */\n    return addk(fs, k, v);\n};\n\n/*\n** Fix an expression to return the number of results 'nresults'.\n** Either 'e' is a multi-ret expression (function call or vararg)\n** or 'nresults' is LUA_MULTRET (as any expression can satisfy that).\n*/\nconst luaK_setreturns = function(fs, e, nresults) {\n    let ek = lparser.expkind;\n    if (e.k === ek.VCALL) {  /* expression is an open function call? */\n        lopcodes.SETARG_C(getinstruction(fs, e), nresults + 1);\n    }\n    else if (e.k === ek.VVARARG) {\n        let pc = getinstruction(fs, e);\n        lopcodes.SETARG_B(pc, nresults + 1);\n        lopcodes.SETARG_A(pc, fs.freereg);\n        luaK_reserveregs(fs, 1);\n    }\n    else lua_assert(nresults === LUA_MULTRET);\n};\n\nconst luaK_setmultret = function(fs, e) {\n    luaK_setreturns(fs, e, LUA_MULTRET);\n};\n\n/*\n** Fix an expression to return one result.\n** If expression is not a multi-ret expression (function call or\n** vararg), it already returns one result, so nothing needs to be done.\n** Function calls become VNONRELOC expressions (as its result comes\n** fixed in the base register of the call), while vararg expressions\n** become VRELOCABLE (as OP_VARARG puts its results where it wants).\n** (Calls are created returning one result, so that does not need\n** to be fixed.)\n*/\nconst luaK_setoneret = function(fs, e) {\n    let ek = lparser.expkind;\n    if (e.k === ek.VCALL) {  /* expression is an open function call? */\n        /* already returns 1 value */\n        lua_assert(getinstruction(fs, e).C === 2);\n        e.k = ek.VNONRELOC;  /* result has fixed position */\n        e.u.info = getinstruction(fs, e).A;\n    } else if (e.k === ek.VVARARG) {\n        lopcodes.SETARG_B(getinstruction(fs, e), 2);\n        e.k = ek.VRELOCABLE;  /* can relocate its simple result */\n    }\n};\n\n/*\n** Ensure that expression 'e' is not a variable.\n*/\nconst luaK_dischargevars = function(fs, e) {\n    let ek = lparser.expkind;\n\n    switch (e.k) {\n        case ek.VLOCAL: {  /* already in a register */\n            e.k =  ek.VNONRELOC;  /* becomes a non-relocatable value */\n            break;\n        }\n        case ek.VUPVAL: {  /* move value to some (pending) register */\n            e.u.info = luaK_codeABC(fs, OpCodesI.OP_GETUPVAL, 0, e.u.info, 0);\n            e.k = ek.VRELOCABLE;\n            break;\n        }\n        case ek.VINDEXED: {\n            let op;\n            freereg(fs, e.u.ind.idx);\n            if (e.u.ind.vt === ek.VLOCAL) {  /* is 't' in a register? */\n                freereg(fs, e.u.ind.t);\n                op = OpCodesI.OP_GETTABLE;\n            } else {\n                lua_assert(e.u.ind.vt === ek.VUPVAL);\n                op = OpCodesI.OP_GETTABUP;  /* 't' is in an upvalue */\n            }\n            e.u.info = luaK_codeABC(fs, op, 0, e.u.ind.t, e.u.ind.idx);\n            e.k = ek.VRELOCABLE;\n            break;\n        }\n        case ek.VVARARG: case ek.VCALL: {\n            luaK_setoneret(fs, e);\n            break;\n        }\n        default: break;  /* there is one value available (somewhere) */\n    }\n};\n\nconst code_loadbool = function(fs, A, b, jump) {\n    luaK_getlabel(fs);  /* those instructions may be jump targets */\n    return luaK_codeABC(fs, OpCodesI.OP_LOADBOOL, A, b, jump);\n};\n\n/*\n** Ensures expression value is in register 'reg' (and therefore\n** 'e' will become a non-relocatable expression).\n*/\nconst discharge2reg = function(fs, e, reg) {\n    let ek = lparser.expkind;\n    luaK_dischargevars(fs, e);\n    switch (e.k) {\n        case ek.VNIL: {\n            luaK_nil(fs, reg, 1);\n            break;\n        }\n        case ek.VFALSE: case ek.VTRUE: {\n            luaK_codeABC(fs, OpCodesI.OP_LOADBOOL, reg, e.k === ek.VTRUE, 0);\n            break;\n        }\n        case ek.VK: {\n            luaK_codek(fs, reg, e.u.info);\n            break;\n        }\n        case ek.VKFLT: {\n            luaK_codek(fs, reg, luaK_numberK(fs, e.u.nval));\n            break;\n        }\n        case ek.VKINT: {\n            luaK_codek(fs, reg, luaK_intK(fs, e.u.ival));\n            break;\n        }\n        case ek.VRELOCABLE: {\n            let pc = getinstruction(fs, e);\n            lopcodes.SETARG_A(pc, reg);  /* instruction will put result in 'reg' */\n            break;\n        }\n        case ek.VNONRELOC: {\n            if (reg !== e.u.info)\n                luaK_codeABC(fs, OpCodesI.OP_MOVE, reg, e.u.info, 0);\n            break;\n        }\n        default: {\n            lua_assert(e.k === ek.VJMP);\n            return;  /* nothing to do... */\n        }\n    }\n    e.u.info = reg;\n    e.k = ek.VNONRELOC;\n};\n\n/*\n** Ensures expression value is in any register.\n*/\nconst discharge2anyreg = function(fs, e) {\n    if (e.k !== lparser.expkind.VNONRELOC) {  /* no fixed register yet? */\n        luaK_reserveregs(fs, 1);  /* get a register */\n        discharge2reg(fs, e, fs.freereg-1);  /* put value there */\n    }\n};\n\n/*\n** check whether list has any jump that do not produce a value\n** or produce an inverted value\n*/\nconst need_value = function(fs, list) {\n    for (; list !== NO_JUMP; list = getjump(fs, list)) {\n        let i = getjumpcontrol(fs, list);\n        if (i.opcode !== OpCodesI.OP_TESTSET) return true;\n    }\n    return false;  /* not found */\n};\n\n/*\n** Ensures final expression result (including results from its jump\n** lists) is in register 'reg'.\n** If expression has jumps, need to patch these jumps either to\n** its final position or to \"load\" instructions (for those tests\n** that do not produce values).\n*/\nconst exp2reg = function(fs, e, reg) {\n    let ek = lparser.expkind;\n    discharge2reg(fs, e, reg);\n    if (e.k === ek.VJMP)  /* expression itself is a test? */\n        e.t = luaK_concat(fs, e.t, e.u.info);  /* put this jump in 't' list */\n    if (hasjumps(e)) {\n        let final;  /* position after whole expression */\n        let p_f = NO_JUMP;  /* position of an eventual LOAD false */\n        let p_t = NO_JUMP;  /* position of an eventual LOAD true */\n        if (need_value(fs, e.t) || need_value(fs, e.f)) {\n            let fj = (e.k === ek.VJMP) ? NO_JUMP : luaK_jump(fs);\n            p_f = code_loadbool(fs, reg, 0, 1);\n            p_t = code_loadbool(fs, reg, 1, 0);\n            luaK_patchtohere(fs, fj);\n        }\n        final = luaK_getlabel(fs);\n        patchlistaux(fs, e.f, final, reg, p_f);\n        patchlistaux(fs, e.t, final, reg, p_t);\n    }\n    e.f = e.t = NO_JUMP;\n    e.u.info = reg;\n    e.k = ek.VNONRELOC;\n};\n\n/*\n** Ensures final expression result (including results from its jump\n** lists) is in next available register.\n*/\nconst luaK_exp2nextreg = function(fs, e) {\n    luaK_dischargevars(fs, e);\n    freeexp(fs, e);\n    luaK_reserveregs(fs, 1);\n    exp2reg(fs, e, fs.freereg - 1);\n};\n\n\n/*\n** Ensures final expression result (including results from its jump\n** lists) is in some (any) register and return that register.\n*/\nconst luaK_exp2anyreg = function(fs, e) {\n    luaK_dischargevars(fs, e);\n    if (e.k === lparser.expkind.VNONRELOC) {  /* expression already has a register? */\n        if (!hasjumps(e))  /* no jumps? */\n            return e.u.info;  /* result is already in a register */\n        if (e.u.info >= fs.nactvar) {  /* reg. is not a local? */\n            exp2reg(fs, e, e.u.info);  /* put final result in it */\n            return e.u.info;\n        }\n    }\n    luaK_exp2nextreg(fs, e);  /* otherwise, use next available register */\n    return e.u.info;\n};\n\n/*\n** Ensures final expression result is either in a register or in an\n** upvalue.\n*/\nconst luaK_exp2anyregup = function(fs, e) {\n    if (e.k !== lparser.expkind.VUPVAL || hasjumps(e))\n        luaK_exp2anyreg(fs, e);\n};\n\n/*\n** Ensures final expression result is either in a register or it is\n** a constant.\n*/\nconst luaK_exp2val = function(fs, e) {\n    if (hasjumps(e))\n        luaK_exp2anyreg(fs, e);\n    else\n        luaK_dischargevars(fs, e);\n};\n\n/*\n** Ensures final expression result is in a valid R/K index\n** (that is, it is either in a register or in 'k' with an index\n** in the range of R/K indices).\n** Returns R/K index.\n*/\nconst luaK_exp2RK = function(fs, e) {\n    let ek = lparser.expkind;\n    let vk = false;\n    luaK_exp2val(fs, e);\n    switch (e.k) {  /* move constants to 'k' */\n        case ek.VTRUE: e.u.info = boolK(fs, true); vk = true; break;\n        case ek.VFALSE: e.u.info = boolK(fs, false); vk = true; break;\n        case ek.VNIL: e.u.info = nilK(fs); vk = true; break;\n        case ek.VKINT: e.u.info = luaK_intK(fs, e.u.ival); vk = true; break;\n        case ek.VKFLT: e.u.info = luaK_numberK(fs, e.u.nval); vk = true; break;\n        case ek.VK: vk = true; break;\n        default: break;\n    }\n\n    if (vk) {\n        e.k = ek.VK;\n        if (e.u.info <= lopcodes.MAXINDEXRK)  /* constant fits in 'argC'? */\n            return lopcodes.RKASK(e.u.info);\n    }\n\n    /* not a constant in the right range: put it in a register */\n    return luaK_exp2anyreg(fs, e);\n};\n\n/*\n** Generate code to store result of expression 'ex' into variable 'var'.\n*/\nconst luaK_storevar = function(fs, vr, ex) {\n    let ek = lparser.expkind;\n    switch (vr.k) {\n        case ek.VLOCAL: {\n            freeexp(fs, ex);\n            exp2reg(fs, ex, vr.u.info);  /* compute 'ex' into proper place */\n            return;\n        }\n        case ek.VUPVAL: {\n            let e = luaK_exp2anyreg(fs, ex);\n            luaK_codeABC(fs, OpCodesI.OP_SETUPVAL, e, vr.u.info, 0);\n            break;\n        }\n        case ek.VINDEXED: {\n            let op = (vr.u.ind.vt === ek.VLOCAL) ? OpCodesI.OP_SETTABLE : OpCodesI.OP_SETTABUP;\n            let e = luaK_exp2RK(fs, ex);\n            luaK_codeABC(fs, op, vr.u.ind.t, vr.u.ind.idx, e);\n            break;\n        }\n    }\n    freeexp(fs, ex);\n};\n\n\n/*\n** Emit SELF instruction (convert expression 'e' into 'e:key(e,').\n*/\nconst luaK_self = function(fs, e, key) {\n    luaK_exp2anyreg(fs, e);\n    let ereg = e.u.info;  /* register where 'e' was placed */\n    freeexp(fs, e);\n    e.u.info = fs.freereg;  /* base register for op_self */\n    e.k = lparser.expkind.VNONRELOC;  /* self expression has a fixed register */\n    luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */\n    luaK_codeABC(fs, OpCodesI.OP_SELF, e.u.info, ereg, luaK_exp2RK(fs, key));\n    freeexp(fs, key);\n};\n\n/*\n** Negate condition 'e' (where 'e' is a comparison).\n*/\nconst negatecondition = function(fs, e) {\n    let pc = getjumpcontrol(fs, e.u.info);\n    lua_assert(lopcodes.testTMode(pc.opcode) && pc.opcode !== OpCodesI.OP_TESTSET && pc.opcode !== OpCodesI.OP_TEST);\n    lopcodes.SETARG_A(pc, !(pc.A));\n};\n\n/*\n** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'\n** is true, code will jump if 'e' is true.) Return jump position.\n** Optimize when 'e' is 'not' something, inverting the condition\n** and removing the 'not'.\n*/\nconst jumponcond = function(fs, e, cond) {\n    if (e.k === lparser.expkind.VRELOCABLE) {\n        let ie = getinstruction(fs, e);\n        if (ie.opcode === OpCodesI.OP_NOT) {\n            fs.pc--;  /* remove previous OP_NOT */\n            return condjump(fs, OpCodesI.OP_TEST, ie.B, 0, !cond);\n        }\n        /* else go through */\n    }\n    discharge2anyreg(fs, e);\n    freeexp(fs, e);\n    return condjump(fs, OpCodesI.OP_TESTSET, lopcodes.NO_REG, e.u.info, cond);\n};\n\n/*\n** Emit code to go through if 'e' is true, jump otherwise.\n*/\nconst luaK_goiftrue = function(fs, e) {\n    let ek = lparser.expkind;\n    let pc;  /* pc of new jump */\n    luaK_dischargevars(fs, e);\n    switch (e.k) {\n        case ek.VJMP: {  /* condition? */\n            negatecondition(fs, e);  /* jump when it is false */\n            pc = e.u.info;  /* save jump position */\n            break;\n        }\n        case ek.VK: case ek.VKFLT: case ek.VKINT: case ek.VTRUE: {\n            pc = NO_JUMP;  /* always true; do nothing */\n            break;\n        }\n        default: {\n            pc = jumponcond(fs, e, 0);  /* jump when false */\n            break;\n        }\n    }\n    e.f = luaK_concat(fs, e.f, pc);  /* insert new jump in false list */\n    luaK_patchtohere(fs, e.t);  /* true list jumps to here (to go through) */\n    e.t = NO_JUMP;\n};\n\n/*\n** Emit code to go through if 'e' is false, jump otherwise.\n*/\nconst luaK_goiffalse = function(fs, e) {\n    let ek = lparser.expkind;\n    let pc;  /* pc of new jump */\n    luaK_dischargevars(fs, e);\n    switch (e.k) {\n        case ek.VJMP: {\n            pc = e.u.info;  /* already jump if true */\n            break;\n        }\n        case ek.VNIL: case ek.VFALSE: {\n            pc = NO_JUMP;  /* always false; do nothing */\n            break;\n        }\n        default: {\n            pc = jumponcond(fs, e, 1);  /* jump if true */\n            break;\n        }\n    }\n    e.t = luaK_concat(fs, e.t, pc);  /* insert new jump in 't' list */\n    luaK_patchtohere(fs, e.f);  /* false list jumps to here (to go through) */\n    e.f = NO_JUMP;\n};\n\n/*\n** Code 'not e', doing constant folding.\n*/\nconst codenot = function(fs, e) {\n    let ek = lparser.expkind;\n    luaK_dischargevars(fs, e);\n    switch (e.k) {\n        case ek.VNIL: case ek.VFALSE: {\n            e.k = ek.VTRUE;  /* true === not nil === not false */\n            break;\n        }\n        case ek.VK: case ek.VKFLT: case ek.VKINT: case ek.VTRUE: {\n            e.k = ek.VFALSE;  /* false === not \"x\" === not 0.5 === not 1 === not true */\n            break;\n        }\n        case ek.VJMP: {\n            negatecondition(fs, e);\n            break;\n        }\n        case ek.VRELOCABLE:\n        case ek.VNONRELOC: {\n            discharge2anyreg(fs, e);\n            freeexp(fs, e);\n            e.u.info = luaK_codeABC(fs, OpCodesI.OP_NOT, 0, e.u.info, 0);\n            e.k = ek.VRELOCABLE;\n            break;\n        }\n    }\n    /* interchange true and false lists */\n    { let temp = e.f; e.f = e.t; e.t = temp; }\n    removevalues(fs, e.f);  /* values are useless when negated */\n    removevalues(fs, e.t);\n};\n\n/*\n** Create expression 't[k]'. 't' must have its final result already in a\n** register or upvalue.\n*/\nconst luaK_indexed = function(fs, t, k) {\n    let ek = lparser.expkind;\n    lua_assert(!hasjumps(t) && (lparser.vkisinreg(t.k) || t.k === ek.VUPVAL));\n    t.u.ind.t = t.u.info;  /* register or upvalue index */\n    t.u.ind.idx = luaK_exp2RK(fs, k);  /* R/K index for key */\n    t.u.ind.vt = (t.k === ek.VUPVAL) ? ek.VUPVAL : ek.VLOCAL;\n    t.k = ek.VINDEXED;\n};\n\n/*\n** Return false if folding can raise an error.\n** Bitwise operations need operands convertible to integers; division\n** operations cannot have 0 as divisor.\n*/\nconst validop = function(op, v1, v2) {\n    switch (op) {\n        case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:\n        case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  /* conversion errors */\n            return (lvm.tointeger(v1) !== false && lvm.tointeger(v2) !== false);\n        }\n        case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  /* division by 0 */\n            return (v2.value !== 0);\n        default: return 1;  /* everything else is valid */\n    }\n};\n\n/*\n** Try to \"constant-fold\" an operation; return 1 iff successful.\n** (In this case, 'e1' has the final result.)\n*/\nconst constfolding = function(op, e1, e2) {\n    let ek = lparser.expkind;\n    let v1, v2;\n    if (!(v1 = tonumeral(e1, true)) || !(v2 = tonumeral(e2, true)) || !validop(op, v1, v2))\n        return 0;  /* non-numeric operands or not safe to fold */\n    let res = new TValue(); /* FIXME */\n    lobject.luaO_arith(null, op, v1, v2, res);  /* does operation */\n    if (res.ttisinteger()) {\n        e1.k = ek.VKINT;\n        e1.u.ival = res.value;\n    }\n    else {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */\n        let n = res.value;\n        if (isNaN(n) || n === 0)\n            return false;\n        e1.k = ek.VKFLT;\n        e1.u.nval = n;\n    }\n    return true;\n};\n\n/*\n** Emit code for unary expressions that \"produce values\"\n** (everything but 'not').\n** Expression to produce final result will be encoded in 'e'.\n*/\nconst codeunexpval = function(fs, op, e, line) {\n    let r = luaK_exp2anyreg(fs, e);  /* opcodes operate only on registers */\n    freeexp(fs, e);\n    e.u.info = luaK_codeABC(fs, op, 0, r, 0);  /* generate opcode */\n    e.k = lparser.expkind.VRELOCABLE;  /* all those operations are relocatable */\n    luaK_fixline(fs, line);\n};\n\n/*\n** Emit code for binary expressions that \"produce values\"\n** (everything but logical operators 'and'/'or' and comparison\n** operators).\n** Expression to produce final result will be encoded in 'e1'.\n** Because 'luaK_exp2RK' can free registers, its calls must be\n** in \"stack order\" (that is, first on 'e2', which may have more\n** recent registers to be released).\n*/\nconst codebinexpval = function(fs, op, e1, e2, line) {\n    let rk2 = luaK_exp2RK(fs, e2);  /* both operands are \"RK\" */\n    let rk1 = luaK_exp2RK(fs, e1);\n    freeexps(fs, e1, e2);\n    e1.u.info = luaK_codeABC(fs, op, 0, rk1, rk2);  /* generate opcode */\n    e1.k = lparser.expkind.VRELOCABLE;  /* all those operations are relocatable */\n    luaK_fixline(fs, line);\n};\n\n\n/*\n** Emit code for comparisons.\n** 'e1' was already put in R/K form by 'luaK_infix'.\n*/\nconst codecomp = function(fs, opr, e1, e2) {\n    let ek = lparser.expkind;\n\n    let rk1;\n    if (e1.k === ek.VK)\n        rk1 = lopcodes.RKASK(e1.u.info);\n    else {\n        lua_assert(e1.k === ek.VNONRELOC);\n        rk1 = e1.u.info;\n    }\n\n    let rk2 = luaK_exp2RK(fs, e2);\n    freeexps(fs, e1, e2);\n    switch (opr) {\n        case BinOpr.OPR_NE: {  /* '(a ~= b)' ==> 'not (a === b)' */\n            e1.u.info = condjump(fs, OpCodesI.OP_EQ, 0, rk1, rk2);\n            break;\n        }\n        case BinOpr.OPR_GT: case BinOpr.OPR_GE: {\n            /* '(a > b)' ==> '(b < a)';  '(a >= b)' ==> '(b <= a)' */\n            let op = (opr - BinOpr.OPR_NE) + OpCodesI.OP_EQ;\n            e1.u.info = condjump(fs, op, 1, rk2, rk1);  /* invert operands */\n            break;\n        }\n        default: {  /* '==', '<', '<=' use their own opcodes */\n            let op = (opr - BinOpr.OPR_EQ) + OpCodesI.OP_EQ;\n            e1.u.info = condjump(fs, op, 1, rk1, rk2);\n            break;\n        }\n    }\n    e1.k = ek.VJMP;\n};\n\n/*\n** Apply prefix operation 'op' to expression 'e'.\n*/\nconst luaK_prefix = function(fs, op, e, line) {\n    let ef = new lparser.expdesc();\n    ef.k = lparser.expkind.VKINT;\n    ef.u.ival = ef.u.nval = ef.u.info = 0;\n    ef.t = NO_JUMP;\n    ef.f = NO_JUMP;\n    switch (op) {\n        case UnOpr.OPR_MINUS: case UnOpr.OPR_BNOT:  /* use 'ef' as fake 2nd operand */\n            if (constfolding(op + LUA_OPUNM, e, ef))\n                break;\n            /* FALLTHROUGH */\n        case UnOpr.OPR_LEN:\n            codeunexpval(fs, op + OpCodesI.OP_UNM, e, line);\n            break;\n        case UnOpr.OPR_NOT: codenot(fs, e); break;\n    }\n};\n\n/*\n** Process 1st operand 'v' of binary operation 'op' before reading\n** 2nd operand.\n*/\nconst luaK_infix = function(fs, op, v) {\n    switch (op) {\n        case BinOpr.OPR_AND: {\n            luaK_goiftrue(fs, v);  /* go ahead only if 'v' is true */\n            break;\n        }\n        case BinOpr.OPR_OR: {\n            luaK_goiffalse(fs, v);  /* go ahead only if 'v' is false */\n            break;\n        }\n        case BinOpr.OPR_CONCAT: {\n            luaK_exp2nextreg(fs, v);  /* operand must be on the 'stack' */\n            break;\n        }\n        case BinOpr.OPR_ADD: case BinOpr.OPR_SUB:\n        case BinOpr.OPR_MUL: case BinOpr.OPR_DIV: case BinOpr.OPR_IDIV:\n        case BinOpr.OPR_MOD: case BinOpr.OPR_POW:\n        case BinOpr.OPR_BAND: case BinOpr.OPR_BOR: case BinOpr.OPR_BXOR:\n        case BinOpr.OPR_SHL: case BinOpr.OPR_SHR: {\n            if (!tonumeral(v, false))\n                luaK_exp2RK(fs, v);\n            /* else keep numeral, which may be folded with 2nd operand */\n            break;\n        }\n        default: {\n            luaK_exp2RK(fs, v);\n            break;\n        }\n    }\n};\n\n/*\n** Finalize code for binary operation, after reading 2nd operand.\n** For '(a .. b .. c)' (which is '(a .. (b .. c))', because\n** concatenation is right associative), merge second CONCAT into first\n** one.\n*/\nconst luaK_posfix = function(fs, op, e1, e2, line) {\n    let ek = lparser.expkind;\n    switch (op) {\n        case BinOpr.OPR_AND: {\n            lua_assert(e1.t === NO_JUMP);  /* list closed by 'luK_infix' */\n            luaK_dischargevars(fs, e2);\n            e2.f = luaK_concat(fs, e2.f, e1.f);\n            e1.to(e2);\n            break;\n        }\n        case BinOpr.OPR_OR: {\n            lua_assert(e1.f === NO_JUMP);  /* list closed by 'luK_infix' */\n            luaK_dischargevars(fs, e2);\n            e2.t = luaK_concat(fs, e2.t, e1.t);\n            e1.to(e2);\n            break;\n        }\n        case BinOpr.OPR_CONCAT: {\n            luaK_exp2val(fs, e2);\n            let ins = getinstruction(fs, e2);\n            if (e2.k === ek.VRELOCABLE && ins.opcode === OpCodesI.OP_CONCAT) {\n                lua_assert(e1.u.info === ins.B - 1);\n                freeexp(fs, e1);\n                lopcodes.SETARG_B(ins, e1.u.info);\n                e1.k = ek.VRELOCABLE; e1.u.info = e2.u.info;\n            }\n            else {\n                luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */\n                codebinexpval(fs, OpCodesI.OP_CONCAT, e1, e2, line);\n            }\n            break;\n        }\n        case BinOpr.OPR_ADD: case BinOpr.OPR_SUB: case BinOpr.OPR_MUL: case BinOpr.OPR_DIV:\n        case BinOpr.OPR_IDIV: case BinOpr.OPR_MOD: case BinOpr.OPR_POW:\n        case BinOpr.OPR_BAND: case BinOpr.OPR_BOR: case BinOpr.OPR_BXOR:\n        case BinOpr.OPR_SHL: case BinOpr.OPR_SHR: {\n            if (!constfolding(op + LUA_OPADD, e1, e2))\n                codebinexpval(fs, op + OpCodesI.OP_ADD, e1, e2, line);\n            break;\n        }\n        case BinOpr.OPR_EQ: case BinOpr.OPR_LT: case BinOpr.OPR_LE:\n        case BinOpr.OPR_NE: case BinOpr.OPR_GT: case BinOpr.OPR_GE: {\n            codecomp(fs, op, e1, e2);\n            break;\n        }\n    }\n\n    return e1;\n};\n\n/*\n** Change line information associated with current position.\n*/\nconst luaK_fixline = function(fs, line) {\n    fs.f.lineinfo[fs.pc - 1] = line;\n};\n\n/*\n** Emit a SETLIST instruction.\n** 'base' is register that keeps table;\n** 'nelems' is #table plus those to be stored now;\n** 'tostore' is number of values (in registers 'base + 1',...) to add to\n** table (or LUA_MULTRET to add up to stack top).\n*/\nconst luaK_setlist = function(fs, base, nelems, tostore) {\n    let c =  (nelems - 1)/lopcodes.LFIELDS_PER_FLUSH + 1;\n    let b = (tostore === LUA_MULTRET) ? 0 : tostore;\n    lua_assert(tostore !== 0 && tostore <= lopcodes.LFIELDS_PER_FLUSH);\n    if (c <= lopcodes.MAXARG_C)\n        luaK_codeABC(fs, OpCodesI.OP_SETLIST, base, b, c);\n    else if (c <= lopcodes.MAXARG_Ax) {\n        luaK_codeABC(fs, OpCodesI.OP_SETLIST, base, b, 0);\n        codeextraarg(fs, c);\n    }\n    else\n        llex.luaX_syntaxerror(fs.ls, to_luastring(\"constructor too long\", true));\n    fs.freereg = base + 1;  /* free registers with list values */\n};\n\n\nmodule.exports.BinOpr             = BinOpr;\nmodule.exports.NO_JUMP            = NO_JUMP;\nmodule.exports.UnOpr              = UnOpr;\nmodule.exports.getinstruction     = getinstruction;\nmodule.exports.luaK_checkstack    = luaK_checkstack;\nmodule.exports.luaK_code          = luaK_code;\nmodule.exports.luaK_codeABC       = luaK_codeABC;\nmodule.exports.luaK_codeABx       = luaK_codeABx;\nmodule.exports.luaK_codeAsBx      = luaK_codeAsBx;\nmodule.exports.luaK_codek         = luaK_codek;\nmodule.exports.luaK_concat        = luaK_concat;\nmodule.exports.luaK_dischargevars = luaK_dischargevars;\nmodule.exports.luaK_exp2RK        = luaK_exp2RK;\nmodule.exports.luaK_exp2anyreg    = luaK_exp2anyreg;\nmodule.exports.luaK_exp2anyregup  = luaK_exp2anyregup;\nmodule.exports.luaK_exp2nextreg   = luaK_exp2nextreg;\nmodule.exports.luaK_exp2val       = luaK_exp2val;\nmodule.exports.luaK_fixline       = luaK_fixline;\nmodule.exports.luaK_getlabel      = luaK_getlabel;\nmodule.exports.luaK_goiffalse     = luaK_goiffalse;\nmodule.exports.luaK_goiftrue      = luaK_goiftrue;\nmodule.exports.luaK_indexed       = luaK_indexed;\nmodule.exports.luaK_infix         = luaK_infix;\nmodule.exports.luaK_intK          = luaK_intK;\nmodule.exports.luaK_jump          = luaK_jump;\nmodule.exports.luaK_jumpto        = luaK_jumpto;\nmodule.exports.luaK_nil           = luaK_nil;\nmodule.exports.luaK_numberK       = luaK_numberK;\nmodule.exports.luaK_patchclose    = luaK_patchclose;\nmodule.exports.luaK_patchlist     = luaK_patchlist;\nmodule.exports.luaK_patchtohere   = luaK_patchtohere;\nmodule.exports.luaK_posfix        = luaK_posfix;\nmodule.exports.luaK_prefix        = luaK_prefix;\nmodule.exports.luaK_reserveregs   = luaK_reserveregs;\nmodule.exports.luaK_ret           = luaK_ret;\nmodule.exports.luaK_self          = luaK_self;\nmodule.exports.luaK_setlist       = luaK_setlist;\nmodule.exports.luaK_setmultret    = luaK_setmultret;\nmodule.exports.luaK_setoneret     = luaK_setoneret;\nmodule.exports.luaK_setreturns    = luaK_setreturns;\nmodule.exports.luaK_storevar      = luaK_storevar;\nmodule.exports.luaK_stringK       = luaK_stringK;\n","\"use strict\";\n\nconst {\n    LUA_SIGNATURE,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR\n    },\n    thread_status: { LUA_ERRSYNTAX },\n    is_luastring,\n    luastring_eq,\n    to_luastring\n} = require('./defs.js');\nconst ldo      = require('./ldo.js');\nconst lfunc    = require('./lfunc.js');\nconst lobject  = require('./lobject.js');\nconst {\n    MAXARG_sBx,\n    POS_A,\n    POS_Ax,\n    POS_B,\n    POS_Bx,\n    POS_C,\n    POS_OP,\n    SIZE_A,\n    SIZE_Ax,\n    SIZE_B,\n    SIZE_Bx,\n    SIZE_C,\n    SIZE_OP\n} = require('./lopcodes.js');\nconst { lua_assert } = require(\"./llimits.js\");\nconst { luaS_bless } = require('./lstring.js');\nconst {\n    luaZ_read,\n    ZIO\n} = require('./lzio.js');\n\nlet LUAC_DATA = [0x19, 0x93, 13, 10, 0x1a, 10];\n\nclass BytecodeParser {\n\n    constructor(L, Z, name) {\n        this.intSize = 4;\n        this.size_tSize = 4;\n        this.instructionSize = 4;\n        this.integerSize = 4;\n        this.numberSize = 8;\n\n        lua_assert(Z instanceof ZIO, \"BytecodeParser only operates on a ZIO\");\n        lua_assert(is_luastring(name));\n\n        if (name[0] === 64 /* ('@').charCodeAt(0) */ || name[0] === 61 /* ('=').charCodeAt(0) */)\n            this.name = name.subarray(1);\n        else if (name[0] == LUA_SIGNATURE[0])\n            this.name = to_luastring(\"binary string\", true);\n        else\n            this.name = name;\n\n        this.L = L;\n        this.Z = Z;\n\n        // Used to do buffer to number conversions\n        this.arraybuffer = new ArrayBuffer(\n            Math.max(this.intSize, this.size_tSize, this.instructionSize, this.integerSize, this.numberSize)\n        );\n        this.dv = new DataView(this.arraybuffer);\n        this.u8 = new Uint8Array(this.arraybuffer);\n    }\n\n    read(size) {\n        let u8 = new Uint8Array(size);\n        if(luaZ_read(this.Z, u8, 0, size) !== 0)\n            this.error(\"truncated\");\n        return u8;\n    }\n\n    LoadByte() {\n        if (luaZ_read(this.Z, this.u8, 0, 1) !== 0)\n            this.error(\"truncated\");\n        return this.u8[0];\n    }\n\n    LoadInt() {\n        if (luaZ_read(this.Z, this.u8, 0, this.intSize) !== 0)\n            this.error(\"truncated\");\n        return this.dv.getInt32(0, true);\n    }\n\n    LoadNumber() {\n        if (luaZ_read(this.Z, this.u8, 0, this.numberSize) !== 0)\n            this.error(\"truncated\");\n        return this.dv.getFloat64(0, true);\n    }\n\n    LoadInteger() {\n        if (luaZ_read(this.Z, this.u8, 0, this.integerSize) !== 0)\n            this.error(\"truncated\");\n        return this.dv.getInt32(0, true);\n    }\n\n    LoadSize_t() {\n        return this.LoadInteger();\n    }\n\n    LoadString() {\n        let size = this.LoadByte();\n        if (size === 0xFF)\n            size = this.LoadSize_t();\n        if (size === 0)\n            return null;\n        return luaS_bless(this.L, this.read(size-1));\n    }\n\n    /* creates a mask with 'n' 1 bits at position 'p' */\n    static MASK1(n, p) {\n        return ((~((~0)<<(n)))<<(p));\n    }\n\n    LoadCode(f) {\n        let n = this.LoadInt();\n        let p = BytecodeParser;\n\n        for (let i = 0; i < n; i++) {\n            if (luaZ_read(this.Z, this.u8, 0, this.instructionSize) !== 0)\n                this.error(\"truncated\");\n            let ins = this.dv.getUint32(0, true);\n            f.code[i] = {\n                code:   ins,\n                opcode: (ins >> POS_OP) & p.MASK1(SIZE_OP, 0),\n                A:      (ins >> POS_A)  & p.MASK1(SIZE_A,  0),\n                B:      (ins >> POS_B)  & p.MASK1(SIZE_B,  0),\n                C:      (ins >> POS_C)  & p.MASK1(SIZE_C,  0),\n                Bx:     (ins >> POS_Bx) & p.MASK1(SIZE_Bx, 0),\n                Ax:     (ins >> POS_Ax) & p.MASK1(SIZE_Ax, 0),\n                sBx:    ((ins >> POS_Bx) & p.MASK1(SIZE_Bx, 0)) - MAXARG_sBx\n            };\n        }\n    }\n\n    LoadConstants(f) {\n        let n = this.LoadInt();\n\n        for (let i = 0; i < n; i++) {\n            let t = this.LoadByte();\n\n            switch (t) {\n                case LUA_TNIL:\n                    f.k.push(new lobject.TValue(LUA_TNIL, null));\n                    break;\n                case LUA_TBOOLEAN:\n                    f.k.push(new lobject.TValue(LUA_TBOOLEAN, this.LoadByte() !== 0));\n                    break;\n                case LUA_TNUMFLT:\n                    f.k.push(new lobject.TValue(LUA_TNUMFLT, this.LoadNumber()));\n                    break;\n                case LUA_TNUMINT:\n                    f.k.push(new lobject.TValue(LUA_TNUMINT, this.LoadInteger()));\n                    break;\n                case LUA_TSHRSTR:\n                case LUA_TLNGSTR:\n                    f.k.push(new lobject.TValue(LUA_TLNGSTR, this.LoadString()));\n                    break;\n                default:\n                    this.error(`unrecognized constant '${t}'`);\n            }\n        }\n    }\n\n    LoadProtos(f) {\n        let n = this.LoadInt();\n\n        for (let i = 0; i < n; i++) {\n            f.p[i] = new lfunc.Proto(this.L);\n            this.LoadFunction(f.p[i], f.source);\n        }\n    }\n\n    LoadUpvalues(f) {\n        let n = this.LoadInt();\n\n        for (let i = 0; i < n; i++) {\n            f.upvalues[i] = {\n                name:    null,\n                instack: this.LoadByte(),\n                idx:     this.LoadByte()\n            };\n        }\n    }\n\n    LoadDebug(f) {\n        let n = this.LoadInt();\n        for (let i = 0; i < n; i++)\n            f.lineinfo[i] = this.LoadInt();\n\n        n = this.LoadInt();\n        for (let i = 0; i < n; i++) {\n            f.locvars[i] = {\n                varname: this.LoadString(),\n                startpc: this.LoadInt(),\n                endpc:   this.LoadInt()\n            };\n        }\n\n        n = this.LoadInt();\n        for (let i = 0; i < n; i++) {\n            f.upvalues[i].name = this.LoadString();\n        }\n    }\n\n    LoadFunction(f, psource) {\n        f.source = this.LoadString();\n        if (f.source === null)  /* no source in dump? */\n            f.source = psource;  /* reuse parent's source */\n        f.linedefined = this.LoadInt();\n        f.lastlinedefined = this.LoadInt();\n        f.numparams = this.LoadByte();\n        f.is_vararg = this.LoadByte() !== 0;\n        f.maxstacksize = this.LoadByte();\n        this.LoadCode(f);\n        this.LoadConstants(f);\n        this.LoadUpvalues(f);\n        this.LoadProtos(f);\n        this.LoadDebug(f);\n    }\n\n    checkliteral(s, msg) {\n        let buff = this.read(s.length);\n        if (!luastring_eq(buff, s))\n            this.error(msg);\n    }\n\n    checkHeader() {\n        this.checkliteral(LUA_SIGNATURE.subarray(1), \"not a\"); /* 1st char already checked */\n\n        if (this.LoadByte() !== 0x53)\n            this.error(\"version mismatch in\");\n\n        if (this.LoadByte() !== 0)\n            this.error(\"format mismatch in\");\n\n        this.checkliteral(LUAC_DATA, \"corrupted\");\n\n        this.intSize         = this.LoadByte();\n        this.size_tSize      = this.LoadByte();\n        this.instructionSize = this.LoadByte();\n        this.integerSize     = this.LoadByte();\n        this.numberSize      = this.LoadByte();\n\n        this.checksize(this.intSize, 4, \"int\");\n        this.checksize(this.size_tSize, 4, \"size_t\");\n        this.checksize(this.instructionSize, 4, \"instruction\");\n        this.checksize(this.integerSize, 4, \"integer\");\n        this.checksize(this.numberSize, 8, \"number\");\n\n        if (this.LoadInteger() !== 0x5678)\n            this.error(\"endianness mismatch in\");\n\n        if (this.LoadNumber() !== 370.5)\n            this.error(\"float format mismatch in\");\n\n    }\n\n    error(why) {\n        lobject.luaO_pushfstring(this.L, to_luastring(\"%s: %s precompiled chunk\"), this.name, to_luastring(why));\n        ldo.luaD_throw(this.L, LUA_ERRSYNTAX);\n    }\n\n    checksize(byte, size, tname) {\n        if (byte !== size)\n            this.error(`${tname} size mismatch in`);\n    }\n}\n\nconst luaU_undump = function(L, Z, name) {\n    let S = new BytecodeParser(L, Z, name);\n    S.checkHeader();\n    let cl = lfunc.luaF_newLclosure(L, S.LoadByte());\n    ldo.luaD_inctop(L);\n    L.stack[L.top-1].setclLvalue(cl);\n    cl.p = new lfunc.Proto(L);\n    S.LoadFunction(cl.p, null);\n    lua_assert(cl.nupvalues === cl.p.upvalues.length);\n    /* luai_verifycode */\n    return cl;\n};\n\nmodule.exports.luaU_undump = luaU_undump;\n","\"use strict\";\n\nconst {\n    LUA_SIGNATURE,\n    LUA_VERSION_MAJOR,\n    LUA_VERSION_MINOR,\n    constant_types: {\n        LUA_TBOOLEAN,\n        LUA_TLNGSTR,\n        LUA_TNIL,\n        LUA_TNUMFLT,\n        LUA_TNUMINT,\n        LUA_TSHRSTR\n    },\n    luastring_of\n} = require('./defs.js');\n\nconst LUAC_DATA    = luastring_of(25, 147, 13, 10, 26, 10);\nconst LUAC_INT     = 0x5678;\nconst LUAC_NUM     = 370.5;\nconst LUAC_VERSION = Number(LUA_VERSION_MAJOR) * 16 + Number(LUA_VERSION_MINOR);\nconst LUAC_FORMAT  = 0;   /* this is the official format */\n\nclass DumpState {\n    constructor() {\n        this.L = null;\n        this.write = null;\n        this.data = null;\n        this.strip = NaN;\n        this.status = NaN;\n    }\n}\n\nconst DumpBlock = function(b, size, D) {\n    if (D.status === 0 && size > 0)\n        D.status = D.writer(D.L, b, size, D.data);\n};\n\nconst DumpByte = function(y, D) {\n    DumpBlock(luastring_of(y), 1, D);\n};\n\nconst DumpInt = function(x, D) {\n    let ab = new ArrayBuffer(4);\n    let dv = new DataView(ab);\n    dv.setInt32(0, x, true);\n    let t = new Uint8Array(ab);\n    DumpBlock(t, 4, D);\n};\n\nconst DumpInteger = function(x, D) {\n    let ab = new ArrayBuffer(4);\n    let dv = new DataView(ab);\n    dv.setInt32(0, x, true);\n    let t = new Uint8Array(ab);\n    DumpBlock(t, 4, D);\n};\n\nconst DumpNumber = function(x, D) {\n    let ab = new ArrayBuffer(8);\n    let dv = new DataView(ab);\n    dv.setFloat64(0, x, true);\n    let t = new Uint8Array(ab);\n    DumpBlock(t, 8, D);\n};\n\nconst DumpString = function(s, D) {\n    if (s === null)\n        DumpByte(0, D);\n    else {\n        let size = s.tsslen() + 1;\n        let str = s.getstr();\n        if (size < 0xFF)\n            DumpByte(size, D);\n        else {\n            DumpByte(0xFF, D);\n            DumpInteger(size, D);\n        }\n        DumpBlock(str, size - 1, D);  /* no need to save '\\0' */\n    }\n};\n\nconst DumpCode = function(f, D) {\n    let s = f.code.map(e => e.code);\n    DumpInt(s.length, D);\n\n    for (let i = 0; i < s.length; i++)\n        DumpInt(s[i], D);\n};\n\nconst DumpConstants = function(f, D) {\n    let n = f.k.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++) {\n        let o = f.k[i];\n        DumpByte(o.ttype(), D);\n        switch (o.ttype()) {\n            case LUA_TNIL:\n                break;\n            case LUA_TBOOLEAN:\n                DumpByte(o.value ? 1 : 0, D);\n                break;\n            case LUA_TNUMFLT:\n                DumpNumber(o.value, D);\n                break;\n            case LUA_TNUMINT:\n                DumpInteger(o.value, D);\n                break;\n            case LUA_TSHRSTR:\n            case LUA_TLNGSTR:\n                DumpString(o.tsvalue(), D);\n                break;\n        }\n    }\n};\n\nconst DumpProtos = function(f, D) {\n    let n = f.p.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++)\n        DumpFunction(f.p[i], f.source, D);\n};\n\nconst DumpUpvalues = function(f, D) {\n    let n = f.upvalues.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++) {\n        DumpByte(f.upvalues[i].instack ? 1 : 0, D);\n        DumpByte(f.upvalues[i].idx, D);\n    }\n};\n\nconst DumpDebug = function(f, D) {\n    let n = D.strip ? 0 : f.lineinfo.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++)\n        DumpInt(f.lineinfo[i], D);\n    n = D.strip ? 0 : f.locvars.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++) {\n        DumpString(f.locvars[i].varname, D);\n        DumpInt(f.locvars[i].startpc, D);\n        DumpInt(f.locvars[i].endpc, D);\n    }\n    n = D.strip ? 0 : f.upvalues.length;\n    DumpInt(n, D);\n    for (let i = 0; i < n; i++)\n        DumpString(f.upvalues[i].name, D);\n};\n\nconst DumpFunction = function(f, psource, D) {\n    if (D.strip || f.source === psource)\n        DumpString(null, D);  /* no debug info or same source as its parent */\n    else\n        DumpString(f.source, D);\n    DumpInt(f.linedefined, D);\n    DumpInt(f.lastlinedefined, D);\n    DumpByte(f.numparams, D);\n    DumpByte(f.is_vararg?1:0, D);\n    DumpByte(f.maxstacksize, D);\n    DumpCode(f, D);\n    DumpConstants(f, D);\n    DumpUpvalues(f, D);\n    DumpProtos(f, D);\n    DumpDebug(f, D);\n};\n\nconst DumpHeader = function(D) {\n    DumpBlock(LUA_SIGNATURE, LUA_SIGNATURE.length, D);\n    DumpByte(LUAC_VERSION, D);\n    DumpByte(LUAC_FORMAT, D);\n    DumpBlock(LUAC_DATA, LUAC_DATA.length, D);\n    DumpByte(4, D); // intSize\n    DumpByte(4, D); // size_tSize\n    DumpByte(4, D); // instructionSize\n    DumpByte(4, D); // integerSize\n    DumpByte(8, D); // numberSize\n    DumpInteger(LUAC_INT, D);\n    DumpNumber(LUAC_NUM, D);\n};\n\n/*\n** dump Lua function as precompiled chunk\n*/\nconst luaU_dump = function(L, f, w, data, strip) {\n    let D = new DumpState();\n    D.L = L;\n    D.writer = w;\n    D.data = data;\n    D.strip = strip;\n    D.status = 0;\n    DumpHeader(D);\n    DumpByte(f.upvalues.length, D);\n    DumpFunction(f, null, D);\n    return D.status;\n};\n\nmodule.exports.luaU_dump = luaU_dump;\n","/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (Array.isArray(parse_tree[i])) {\n                match = parse_tree[i] // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]))\n                        }\n                        arg = arg[match[2][k]]\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(match[8])) {\n                    is_positive = arg >= 0\n                }\n\n                switch (match[8]) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)\n                        break\n                    case 'e':\n                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(match[8])) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(match[8]) && (!is_positive || match[3])) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '\n                    pad_length = match[6] - (sign + arg).length\n                    pad = match[6] ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n                parse_tree.push(match)\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (typeof exports !== 'undefined') {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (typeof define === 'function' && define['amd']) {\n            define(function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            })\n        }\n    }\n    /* eslint-enable quote-props */\n}()\n","\"use strict\";\n\nconst { lua_pop } = require('./lua.js');\nconst { luaL_requiref } = require('./lauxlib.js');\nconst { to_luastring } = require(\"./fengaricore.js\");\n\nconst loadedlibs = {};\n\n/* export before requiring lualib.js */\nconst luaL_openlibs = function(L) {\n    /* \"require\" functions from 'loadedlibs' and set results to global table */\n    for (let lib in loadedlibs) {\n        luaL_requiref(L, to_luastring(lib), loadedlibs[lib], 1);\n        lua_pop(L, 1); /* remove lib */\n    }\n};\nmodule.exports.luaL_openlibs = luaL_openlibs;\n\nconst lualib = require('./lualib.js');\nconst { luaopen_base }      = require('./lbaselib.js');\nconst { luaopen_coroutine } = require('./lcorolib.js');\nconst { luaopen_debug }     = require('./ldblib.js');\nconst { luaopen_math }      = require('./lmathlib.js');\nconst { luaopen_package }   = require('./loadlib.js');\nconst { luaopen_os }        = require('./loslib.js');\nconst { luaopen_string }    = require('./lstrlib.js');\nconst { luaopen_table }     = require('./ltablib.js');\nconst { luaopen_utf8 }      = require('./lutf8lib.js');\n\nloadedlibs[\"_G\"] = luaopen_base,\nloadedlibs[lualib.LUA_LOADLIBNAME] = luaopen_package;\nloadedlibs[lualib.LUA_COLIBNAME] = luaopen_coroutine;\nloadedlibs[lualib.LUA_TABLIBNAME] = luaopen_table;\nloadedlibs[lualib.LUA_OSLIBNAME] = luaopen_os;\nloadedlibs[lualib.LUA_STRLIBNAME] = luaopen_string;\nloadedlibs[lualib.LUA_MATHLIBNAME] = luaopen_math;\nloadedlibs[lualib.LUA_UTF8LIBNAME] = luaopen_utf8;\nloadedlibs[lualib.LUA_DBLIBNAME] = luaopen_debug;\nif (typeof process !== \"undefined\")\n    loadedlibs[lualib.LUA_IOLIBNAME] = require('./liolib.js').luaopen_io;\n\n/* Extension: fengari library */\nconst { luaopen_fengari } = require('./fengarilib.js');\nloadedlibs[lualib.LUA_FENGARILIBNAME] = luaopen_fengari;\n"],"sourceRoot":""}